{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"source/img/操作系统(1)/操作系统引导.png","path":"img/操作系统(1)/操作系统引导.png","modified":1,"renderable":0},{"_id":"source/img/操作系统(1)/虚拟机.png","path":"img/操作系统(1)/虚拟机.png","modified":1,"renderable":0},{"_id":"source/img/操作系统(2)/PCB.png","path":"img/操作系统(2)/PCB.png","modified":1,"renderable":0},{"_id":"source/img/操作系统(2)/进程的特征.png","path":"img/操作系统(2)/进程的特征.png","modified":1,"renderable":0},{"_id":"source/img/操作系统(2)/进程的组成.png","path":"img/操作系统(2)/进程的组成.png","modified":1,"renderable":0},{"_id":"source/img/数据库(4)/代数关系式.png","path":"img/数据库(4)/代数关系式.png","modified":1,"renderable":0},{"_id":"source/img/数据库(4)/外键模式图.png","path":"img/数据库(4)/外键模式图.png","modified":1,"renderable":0},{"_id":"source/img/数据库(4)/数据库实例.png","path":"img/数据库(4)/数据库实例.png","modified":1,"renderable":0},{"_id":"source/img/数据库(4)/模式图.png","path":"img/数据库(4)/模式图.png","modified":1,"renderable":0},{"_id":"source/img/数据库(5)/数据库关系图.png","path":"img/数据库(5)/数据库关系图.png","modified":1,"renderable":0},{"_id":"source/img/数据库(5)/表操作顺序.png","path":"img/数据库(5)/表操作顺序.png","modified":1,"renderable":0},{"_id":"source/img/数据库(6)/数据库三层次结构.png","path":"img/数据库(6)/数据库三层次结构.png","modified":1,"renderable":0},{"_id":"source/img/数据库(6)/格式转换_1.png","path":"img/数据库(6)/格式转换_1.png","modified":1,"renderable":0},{"_id":"source/img/数据库(6)/格式转换_3.png","path":"img/数据库(6)/格式转换_3.png","modified":1,"renderable":0},{"_id":"source/img/数据库(6)/格式转换_2.png","path":"img/数据库(6)/格式转换_2.png","modified":1,"renderable":0},{"_id":"source/img/数据库(6)/格式转换_4.png","path":"img/数据库(6)/格式转换_4.png","modified":1,"renderable":0},{"_id":"source/img/数据库(6)/视图映射.png","path":"img/数据库(6)/视图映射.png","modified":1,"renderable":0},{"_id":"source/img/数据库(7)/DBS设计.png","path":"img/数据库(7)/DBS设计.png","modified":1,"renderable":0},{"_id":"source/img/数据库(7)/ER_1.png","path":"img/数据库(7)/ER_1.png","modified":1,"renderable":0},{"_id":"source/img/数据库(7)/三元关系.png","path":"img/数据库(7)/三元关系.png","modified":1,"renderable":0},{"_id":"source/img/数据库(7)/复合属性.png","path":"img/数据库(7)/复合属性.png","modified":1,"renderable":0},{"_id":"source/img/数据库(7)/数据库整体设计过程.png","path":"img/数据库(7)/数据库整体设计过程.png","modified":1,"renderable":0},{"_id":"source/img/数据库(7)/设计过程.png","path":"img/数据库(7)/设计过程.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(1)/V模型和W模型.png","path":"img/软件工程(1)/V模型和W模型.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(1)/增量模型.png","path":"img/软件工程(1)/增量模型.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(1)/快速应用开发模型.png","path":"img/软件工程(1)/快速应用开发模型.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(1)/构件组装模型.png","path":"img/软件工程(1)/构件组装模型.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(1)/模型开发特定及适用场合.png","path":"img/软件工程(1)/模型开发特定及适用场合.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(1)/演化模型.png","path":"img/软件工程(1)/演化模型.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(1)/螺旋模型.png","path":"img/软件工程(1)/螺旋模型.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(1)/软件生命周期.png","path":"img/软件工程(1)/软件生命周期.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/UML9个基本图(1).png","path":"img/软件工程(2)/UML9个基本图(1).png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/UML9个基本图(2).png","path":"img/软件工程(2)/UML9个基本图(2).png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/UML类_关联和依赖.png","path":"img/软件工程(2)/UML类_关联和依赖.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/UML类_属性.png","path":"img/软件工程(2)/UML类_属性.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/UML类_方法.png","path":"img/软件工程(2)/UML类_方法.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/UML类_类和接口.png","path":"img/软件工程(2)/UML类_类和接口.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/UML类_组合和聚合.png","path":"img/软件工程(2)/UML类_组合和聚合.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/UML类_继承和实现.png","path":"img/软件工程(2)/UML类_继承和实现.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/UML类结构.png","path":"img/软件工程(2)/UML类结构.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/UML视图.png","path":"img/软件工程(2)/UML视图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/关系箭头总览.png","path":"img/软件工程(2)/关系箭头总览.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/关系类型及其说明以及表示符号.png","path":"img/软件工程(2)/关系类型及其说明以及表示符号.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/关联箭头总览.png","path":"img/软件工程(2)/关联箭头总览.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/医院挂号处.png","path":"img/软件工程(2)/医院挂号处.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/协作图.png","path":"img/软件工程(2)/协作图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/基本用例与子用例(1).png","path":"img/软件工程(2)/基本用例与子用例(1).png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/基本用例与子用例(2).png","path":"img/软件工程(2)/基本用例与子用例(2).png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/对象图.png","path":"img/软件工程(2)/对象图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/操作契约.png","path":"img/软件工程(2)/操作契约.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/油画关系图.png","path":"img/软件工程(2)/油画关系图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/活动图.png","path":"img/软件工程(2)/活动图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/状态图.png","path":"img/软件工程(2)/状态图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/用例图.png","path":"img/软件工程(2)/用例图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/用例模型基本结构.png","path":"img/软件工程(2)/用例模型基本结构.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/类图.png","path":"img/软件工程(2)/类图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/系统顺序图(1).png","path":"img/软件工程(2)/系统顺序图(1).png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/系统顺序图(2).png","path":"img/软件工程(2)/系统顺序图(2).png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/组件图.png","path":"img/软件工程(2)/组件图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/自然界UML图.png","path":"img/软件工程(2)/自然界UML图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/部署图.png","path":"img/软件工程(2)/部署图.png","modified":1,"renderable":0},{"_id":"source/img/软件工程(2)/顺序图.png","path":"img/软件工程(2)/顺序图.png","modified":1,"renderable":0},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/SLAM-1.md","hash":"a7d58776b422cb1b4b50122557e7351e49419692","modified":1734668849408},{"_id":"source/_posts/基于视图差的深度估计.md","hash":"1617eabeb34d6f2175a07374fa4d4d739bed811a","modified":1760600379208},{"_id":"source/_posts/操作系统-1.md","hash":"df10f7ae15d9e356eb42bf8786b49db356480c35","modified":1734668849409},{"_id":"source/_posts/操作系统-2.md","hash":"7c43feff87196c36d613e1a55e5f7c1ce6fec81c","modified":1734668849409},{"_id":"source/_posts/数据库-1.md","hash":"96fb863b8ffc9c5e6c3a7cf29d48939c2c463a1d","modified":1734916122460},{"_id":"source/_posts/数据库-2.md","hash":"1e167d14a190f19298e0bee5d43471fa3bf8f819","modified":1734916122460},{"_id":"source/_posts/数据库-3.md","hash":"6c538726116d599b33344767e73584868f8a6ef8","modified":1734916122460},{"_id":"source/_posts/数据库-4.md","hash":"ba3f12e6c6aec86c03d23686d51c3acc49d0da47","modified":1734916122460},{"_id":"source/_posts/数据库-5.md","hash":"c90e95001a9a47b3429c6f6ea79bd77187ae909a","modified":1734916122460},{"_id":"source/_posts/数据库-6.md","hash":"3043dc0a486cff7d29ffcf7a6c7989458d77e557","modified":1734916122460},{"_id":"source/_posts/数据库-7.md","hash":"42ec0c4779b4c59dbdfe2cddaae581f62371590a","modified":1735127961653},{"_id":"source/_posts/数据库-8.md","hash":"56ff22dc7514de1707e20e33c92ff563a0b119e8","modified":1735363969686},{"_id":"source/_posts/软件工程-1.md","hash":"5130e81d656188b210651aa8890eb00ff8b65bd0","modified":1734668849409},{"_id":"source/_posts/软件工程-2.md","hash":"c769cdc4547eb3e7b64638bca89f08bd1c1288ab","modified":1734668849410},{"_id":"source/_posts/软件工程-3.md","hash":"77f7663d47ee6a8726961cee205178f2c52da154","modified":1734668849410},{"_id":"source/_posts/远程连接X11VNC+SSH.md","hash":"f8e16541f0a3d64d64f9050e2399faac52107eb0","modified":1734668849410},{"_id":"source/_posts/项目介绍心得.md","hash":"cf466460595bef278c2f3b5539bdde640dce890d","modified":1734668849410},{"_id":"source/about/index.md","hash":"53a8a778c822d072e741b15d4d6c89fe24431375","modified":1734668849410},{"_id":"source/img/数据库(6)/视图映射.png","hash":"061dfcf7cc696e1986a50fdceca030406f89f138","modified":1734916122468},{"_id":"source/img/软件工程(2)/UML类结构.png","hash":"3422fe834d293eedd06660faa694e5e28584aff5","modified":1734668849433},{"_id":"source/img/软件工程(2)/基本用例与子用例(1).png","hash":"3ed52eea17a6eccd32e2b933f96090d28ee36d15","modified":1734668849438},{"_id":"source/img/软件工程(2)/基本用例与子用例(2).png","hash":"965cd9e7402dc2e2f3762d67edb6279820572815","modified":1734668849438},{"_id":"source/img/数据库(7)/三元关系.png","hash":"e8284e8cd01e820af447f9a8d4fb4b3669effc90","modified":1735125906091},{"_id":"source/img/数据库(7)/复合属性.png","hash":"92562719c6cb72aa6d78fb2b54faf38247dedc53","modified":1735126875689},{"_id":"source/img/数据库(7)/数据库整体设计过程.png","hash":"f06e6db37e1a60fe22ab4ac0b40d54a3282568a8","modified":1735124632178},{"_id":"source/img/数据库(7)/设计过程.png","hash":"3876d15816a18e9276bbdb60b449c0284588b218","modified":1735124632179},{"_id":"source/img/软件工程(2)/UML9个基本图(1).png","hash":"2f1bceaeeafe4502a9d679f1eca1d090403ba898","modified":1734668849429},{"_id":"source/img/软件工程(2)/UML类_继承和实现.png","hash":"c5a7dc3296fe964e171dbb3bb19ba46a9e445a23","modified":1734668849433},{"_id":"source/img/软件工程(2)/UML视图.png","hash":"02536a105266065803a590fc3e0c7ed66761649d","modified":1734668849433},{"_id":"source/img/软件工程(2)/操作契约.png","hash":"82435184a0bc008d9debe51423876d4aa7ac7748","modified":1734668849439},{"_id":"source/img/软件工程(2)/油画关系图.png","hash":"ddb83a5c3c8e9c7e58967f2587e3bac02497b2cd","modified":1734668849439},{"_id":"source/img/软件工程(2)/活动图.png","hash":"ccaf7315032860503c9ac024b5ce98e282526da3","modified":1734668849439},{"_id":"source/img/软件工程(2)/系统顺序图(1).png","hash":"cb82fc4b8a3c714e19497d79d0421ce1b9cdf6da","modified":1734668849443},{"_id":"source/img/数据库(6)/数据库三层次结构.png","hash":"b8b55c9fd57e8fbc13a488f26bc3c69c2fc76e4c","modified":1734916122464},{"_id":"source/img/软件工程(1)/构件组装模型.png","hash":"87ceb3e54f077bed51b0badceba161fbd68154ac","modified":1734668849424},{"_id":"source/img/软件工程(2)/UML类_关联和依赖.png","hash":"05a4370784f3845a7900671480e10108e6af8036","modified":1734668849430},{"_id":"source/img/软件工程(2)/UML类_方法.png","hash":"1c0aa2c9395de0e868dafbf9fa0ed359da3d6469","modified":1734668849431},{"_id":"source/img/软件工程(2)/系统顺序图(2).png","hash":"ce8e6cb13b7d693f20bdbdd13907a882e914e5a8","modified":1734668849443},{"_id":"source/img/操作系统(1)/虚拟机.png","hash":"ced9402d74ece591de3397d341a98efbe93758d1","modified":1734668849413},{"_id":"source/img/数据库(4)/代数关系式.png","hash":"6e6f81f0517e6ce752d85d09280c193aed8440dc","modified":1734916122461},{"_id":"source/img/数据库(5)/表操作顺序.png","hash":"4dd6762c0c088b134367a6f2b4797881bb215e67","modified":1734916122463},{"_id":"source/img/软件工程(1)/快速应用开发模型.png","hash":"aa6704661ee7b36d3f45ae6bba8f90c33aba7e51","modified":1734668849422},{"_id":"source/img/软件工程(1)/演化模型.png","hash":"f9f09b2445315cef690de8296ec835dacc280bdf","modified":1734668849427},{"_id":"source/img/软件工程(1)/软件生命周期.png","hash":"c34e4c7b19ec8cc66887cbd4aea5c3a8faa948e0","modified":1734668849429},{"_id":"source/img/软件工程(2)/UML9个基本图(2).png","hash":"83a752b209354f1ff8087aadf8485a85b6829fc5","modified":1734668849430},{"_id":"source/img/软件工程(2)/UML类_属性.png","hash":"04a43f54e88aa4298c8b85418e91a22c495b1d8e","modified":1734668849430},{"_id":"source/img/软件工程(2)/UML类_组合和聚合.png","hash":"a73959160d378aba7c8970bf3ba23818787fd396","modified":1734668849432},{"_id":"source/img/软件工程(2)/关系类型及其说明以及表示符号.png","hash":"54324cdded8fbe8c9dd82cbcc2b9421f222c7e18","modified":1734668849435},{"_id":"source/img/软件工程(2)/医院挂号处.png","hash":"13c8b13aa8a237613afaa57d55387a90af480168","modified":1734668849437},{"_id":"source/img/软件工程(2)/对象图.png","hash":"45f66022f6f8557763e893962d6fa529fa42a262","modified":1734668849438},{"_id":"source/img/软件工程(2)/状态图.png","hash":"c190598bfd6bfce29ff7522099fd61ed2b315294","modified":1734668849440},{"_id":"source/img/软件工程(2)/组件图.png","hash":"f9327bd4b65cb54347c66c26929f8df4956af057","modified":1734668849444},{"_id":"source/img/软件工程(1)/V模型和W模型.png","hash":"d68f32a9f068b4a4722db4ce8a69bc122a77313f","modified":1734668849421},{"_id":"source/img/软件工程(1)/螺旋模型.png","hash":"41bd09a0bd4c0809ad14242a88dfd718b09fd921","modified":1734668849428},{"_id":"source/img/软件工程(2)/协作图.png","hash":"7a97afc5affe204f543a0a80d3702f4a0aadae68","modified":1734668849437},{"_id":"source/img/软件工程(2)/用例图.png","hash":"9dafd7b2887bec06fdd572ddea2bb96d26b5c712","modified":1734668849441},{"_id":"source/img/软件工程(2)/用例模型基本结构.png","hash":"c074ea9559e1148594fcecb429eb7454140d12e1","modified":1734668849442},{"_id":"source/img/软件工程(2)/类图.png","hash":"4fcabacfbb96613fdddacfc648cdc68d5d3db047","modified":1734668849442},{"_id":"source/img/软件工程(2)/自然界UML图.png","hash":"3f0906562c068e2e76d0a13bc7394428fe8aef69","modified":1734668849444},{"_id":"source/img/软件工程(2)/顺序图.png","hash":"a0ccc15bc127df02d5047886750045dd1083e7e6","modified":1734668849446},{"_id":"source/img/操作系统(1)/操作系统引导.png","hash":"f590a06c604678641abb1f3d971385dc217edf65","modified":1734668849411},{"_id":"source/img/数据库(4)/外键模式图.png","hash":"f757281bbc6d37a43929be63bffdd5bc92b572c9","modified":1734668849418},{"_id":"source/img/数据库(4)/数据库实例.png","hash":"eef5f03b6117840f6d912eacfd620a411c0666fb","modified":1734668849418},{"_id":"source/img/软件工程(1)/增量模型.png","hash":"7a0df1d0d30ef4280cea385ba45284a8dae05d51","modified":1734668849422},{"_id":"source/img/数据库(6)/格式转换_3.png","hash":"874086b911c147dffd3469f3cc2864ec230f20af","modified":1734916122467},{"_id":"source/img/数据库(6)/格式转换_4.png","hash":"6e53d06b2ddd7db0143983623abd365d81d7677b","modified":1734916122468},{"_id":"source/img/数据库(7)/ER_1.png","hash":"60c15d70b0a3bbd040ed57915e0f0031a235ecc5","modified":1735124632178},{"_id":"source/img/软件工程(2)/UML类_类和接口.png","hash":"390028803059bee792c9aa7776facf5ccb3621c5","modified":1734668849432},{"_id":"source/img/软件工程(2)/关联箭头总览.png","hash":"8cd652a5c5a2c21698ce6bddc081e7d08d5b4e8d","modified":1734668849436},{"_id":"source/img/软件工程(2)/部署图.png","hash":"821e8e1d7b781fa2125b4e68f829f5a45259890e","modified":1734668849445},{"_id":"source/img/数据库(5)/数据库关系图.png","hash":"792753ff0181124b452cd05ebae9a8ce82b7d204","modified":1734916122463},{"_id":"source/img/数据库(7)/DBS设计.png","hash":"0777383758fa6b2a1ae2ad81705325fef94332b2","modified":1735124632177},{"_id":"source/img/操作系统(2)/进程的组成.png","hash":"482562701d9a056a8e880562312ff1996e56d5e2","modified":1734668849417},{"_id":"source/img/数据库(4)/模式图.png","hash":"bbec28c777d99642b12c51e698f8988d27131085","modified":1734668849420},{"_id":"source/img/数据库(6)/格式转换_2.png","hash":"8f37489fb213717b1f0b002dec04538a95849320","modified":1734916122466},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1760601227384},{"_id":"source/img/操作系统(2)/进程的特征.png","hash":"d55ab923e2466a7da7abbd5541ffe7b6c34f313d","modified":1734668849417},{"_id":"source/img/数据库(6)/格式转换_1.png","hash":"e9b9ab936d8679e59c643320844aee594fe1e2ff","modified":1734916122465},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1760601227289},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"7746460fc2eba7439b494c46aa9b5ded81370819","modified":1760601227367},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"58dccef1d98b472dc4e6f4693c2297b0c9c5afba","modified":1760601227385},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"ff9b0e1fb9dba665af2f1e4a577f8cb9e840464b","modified":1760601227367},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"9c580471257f5a32bee701a059a45ea96755dcdc","modified":1760601227385},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"7c1a0c9f6186b6643b19d3980f055329bdb4efa4","modified":1760601227385},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"026ddf1a49bf8ddfef6ed86ab4d6af143c1dd95f","modified":1760601227385},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"550b95d3614a64592f02666938d235e9f11e449e","modified":1760601227385},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"a60847136709bb95586a98d9d67b50390a8d2c96","modified":1760601227386},{"_id":"node_modules/hexo-theme-fluid/languages/ru.yml","hash":"93818f8bf07195fb1ebffbb5210e531b0e3a6ec4","modified":1760601227386},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"51c2b4d64c6992a39bfd2586a1bdf5fbbbdf0175","modified":1760601227386},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"e1043de394f6dcf5c0647adcfdefe60637f78426","modified":1760601227386},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"052e9fc19c753f53fdc083c7fb098e3668880140","modified":1760601227301},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1760601227310},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1760601227299},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1760601227316},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"e62d2e25cae57e8469e3f48c9d17be1fd284a969","modified":1760601227385},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1760601227320},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"33c3317cdcee062789de2336dd8d0cc7f86d3650","modified":1760601227338},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1760601227339},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1760601227339},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1760601227346},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1760601227350},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"9bf0d357a607a282f3b9cb04525a4df0cc2a8b76","modified":1760601227347},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1760601227351},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1760601227309},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1760601227319},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1760601227323},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1760601227319},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"40c8b0852873032e7aaef3f68e8ea08706cdef13","modified":1760601227333},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"1dadb118d580280524ed0a5f69bd34d234a92276","modified":1760601227326},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"67be642f99482c07904474f410cfbc2f99003288","modified":1760601227336},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1760601227337},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1760601227340},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1760601227346},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1760601227348},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1760601227356},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1760601227362},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/index-generator.js","hash":"9159fc22fa84a7b605dd15fe4104f01fe9c71147","modified":1760601227360},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"82bb06686158ebe160a631c79f156cd4fde35656","modified":1760601227364},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1760601227360},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1760601227348},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"9ac5ddad06e9b0e6015ce531430018182a4bc0fa","modified":1760601227362},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d3e75f53c59674d171309e50702954671f31f1a4","modified":1760601227363},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1760601227356},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1760601227357},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1760601227359},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1760601227361},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"8e67b522c47aa250860e3fe2c733f1f958a506c0","modified":1760601227357},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1760601227363},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1760601227364},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1760601227365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"966689d7c5e4320008285395fbaa2751f6209be5","modified":1760601227365},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"4d48c424e47ff9a17a563167ea5f480890267adf","modified":1760601227367},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1760601227355},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"6eaf53cf4bfc756a65bda18184cf8998a12c861d","modified":1760601227355},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1760601227358},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1760601227361},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/fold.js","hash":"73e4fd12ce3e47981479391ed354b7d9d3279f70","modified":1760601227357},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1760601227362},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"e3b456a079e5dc0032473b516c865b20f83d2c26","modified":1760601227363},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/crypto.js","hash":"ae4ad8a188ef5b3fa6818b01629fc962b3de8551","modified":1760601227356},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1760601227355},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1760601227363},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1760601227364},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1760601227364},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1760601227376},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1760601227378},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1760601227297},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1760601227367},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1760601227377},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1760601227369},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1760601227369},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1760601227354},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1760601227355},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1760601227357},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1760601227353},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1760601227359},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1760601227361},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1760601227363},{"_id":"node_modules/hexo-theme-fluid/source/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1760601227364},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1760601227362},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1760601227366},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1760601227384},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1760601227322},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1760601227327},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/discuss.ejs","hash":"98d065b58ce06b7d18bff3c974e96fa0f34ae03a","modified":1760601227329},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1760601227330},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1760601227335},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1760601227336},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1760601227347},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"d84bcb5ccd78470a60c067fc914ac0ac67ac8777","modified":1760601227352},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1760601227352},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1760601227353},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"3d08c73b77e412d2f06a24d9344565fc7dbc76f8","modified":1760601227353},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"954a29b58d72647d20450da270b5d8fb2e0824f5","modified":1760601227350},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1760601227314},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1760601227312},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"37d750428772d7c71ba36ce0c2540780d90fadea","modified":1760601227345},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1760601227308},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1760601227323},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1760601227332},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"e6dcbf1c2f56314d56bb46b50aca86ff68cacebd","modified":1760601227304},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"0fff24cf5bf99fbe5c56c292e2eac4a89bf29db4","modified":1760601227331},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1760601227338},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1760601227341},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"03ac02762f801970d1c4e73d6ec8d4c503780e50","modified":1760601227342},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"f345374885cd6a334f09a11f59c443b5d577c06c","modified":1760601227352},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1760601227346},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/moment.ejs","hash":"4ff3fb1b60ccc95a0af3bbdbd0757fedefc088b5","modified":1760601227344},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1760601227317},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"cbfa32c5f5973133afd043853b24f8200455cb2d","modified":1760601227325},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"375974ec017696e294dc12469fb0ae257800dc2d","modified":1760601227343},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"54dd479dbb440126e4ddd9d902229db5afaaae98","modified":1760601227344},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1760601227349},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1760601227351},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1760601227349},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1760601227356},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"c19ac8050b82c3676b0332a56099ccfcc36d9d52","modified":1760601227358},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1760601227360},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"a5fe1deccb73b5f578797dbb11038efc15f63ce8","modified":1760601227359},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"bd8376e1cf7892dc2daa58f2f443574be559fdbf","modified":1760601227359},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1760601227361},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1760601227362},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1760601227371},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1760601227371},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1760601227371},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1760601227380},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1760601227371},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1760601227369},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1760601227370},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"85492ef64d7e5f70f0f7e46d570bbc911e686d7e","modified":1760601227374},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1760601227378},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/print.styl","hash":"166afbc596ea4b552bad7290ec372d25ec34db7b","modified":1760601227382},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1760601227377},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1760601227372},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1760601227372},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"25fb6fa4c783b847c632584c49a7e1593cdb2f5d","modified":1760601227377},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1760601227373},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1760601227378},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1760601227374},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1760601227376},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"7eee3f78296a3c81849a5415d1d43dcc6e03e6aa","modified":1760601227381},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1760601227378},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1760601227384},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"c96d36aa8fe20f0c3c1a29ee2473cd8064b10f73","modified":1760601227381},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1760601227370},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1760601227370},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1760601227372},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1760601227373},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1760601227374},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1760601227375},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1760601227375},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"d42b748f2f49ef32aafb1a21d75991d2459da927","modified":1760601227376},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1760601227379},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1760601227380},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1760601227379},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1760601227380},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1760601227382},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1760601227383},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1760601227383},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1760601227384},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1760601227340},{"_id":"source/img/软件工程(2)/关系箭头总览.png","hash":"ca11f897027c1b8e21ce21b01dbce0002f40f90b","modified":1734668849434},{"_id":"source/img/操作系统(2)/PCB.png","hash":"08f82fdf91488e84e11cf5122f6706f879f5c31b","modified":1734668849414},{"_id":"source/img/软件工程(1)/模型开发特定及适用场合.png","hash":"a83fbb1bbfd032b77d5be956448879cd2216ccbf","modified":1734668849427},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1760601227368},{"_id":"public/local-search.xml","hash":"cd7a9dc04813dd572e3fa9aa561147fe78f88f34","modified":1760601283460},{"_id":"public/about/index.html","hash":"ccb2ada52b6127594e14de32c47809a44ae41533","modified":1760601283460},{"_id":"public/2024/12/27/数据库-8/index.html","hash":"11e3f7899dcea70ab1f46c4d2b97d621d68f4d87","modified":1760601283460},{"_id":"public/2024/12/22/数据库-7/index.html","hash":"2288c67693d057c2cc89580aa28d275001c3abfb","modified":1760601283460},{"_id":"public/2024/12/22/数据库-6/index.html","hash":"0216081f96ed8b480cba3a547effd969ca878608","modified":1760601283460},{"_id":"public/2024/12/21/数据库-5/index.html","hash":"de8ca382e3cc96d97f8b5a33390740045dea424f","modified":1760601283460},{"_id":"public/2024/12/20/数据库-4/index.html","hash":"d38024b305dd252753fb2d4925ce1a701f1e7004","modified":1760601283460},{"_id":"public/2024/11/01/项目介绍心得/index.html","hash":"ca8ca00ab82c576436a179c152a510baf213188a","modified":1760601283460},{"_id":"public/2024/11/01/数据库-3/index.html","hash":"1d24657b875c6de7b058d13c2fc7ebab2eb07c58","modified":1760601283460},{"_id":"public/2024/10/31/软件工程-3/index.html","hash":"aa0ea6ab956ec01b1d5bde5681f85a9bfafa0b33","modified":1760601283460},{"_id":"public/2024/10/24/操作系统-2/index.html","hash":"fbc2269f6e763f3e4fe1446b47a09a56cb37e7f6","modified":1760601283460},{"_id":"public/2024/10/23/软件工程-2/index.html","hash":"e25360a0c09ac1e7d823c1c82e8fd3575c4f2b3c","modified":1760601283460},{"_id":"public/2024/10/23/基于视图差的深度估计/index.html","hash":"a7bb53cdea683784ee64f9408565cbe49800a318","modified":1760601283460},{"_id":"public/2024/10/23/软件工程-1/index.html","hash":"e8ce35aa524dc8aa28258051a4731820f1701787","modified":1760601283460},{"_id":"public/2024/10/18/操作系统-1/index.html","hash":"6df272111e6d096025d1cc8457df51668bf65832","modified":1760601283460},{"_id":"public/2024/10/17/远程连接X11VNC+SSH/index.html","hash":"901f446afbcf9ccac04b5caefb09a20807cec9c1","modified":1760601283460},{"_id":"public/2024/10/05/数据库-2/index.html","hash":"955bc8cd75d25a7fe2a3854dc0af5ef08598732e","modified":1760601283460},{"_id":"public/2024/10/03/SLAM-1/index.html","hash":"6d948705b8a16ee68b51dcd84a426501290d6f6f","modified":1760601283460},{"_id":"public/2024/10/01/数据库-1/index.html","hash":"b5abefcb4fb2d8425f8e7fadf222d93d4f24e7f1","modified":1760601283460},{"_id":"public/archives/index.html","hash":"fb10c354a9e2ed7d150ba6d29d2341070cf78c54","modified":1760601283460},{"_id":"public/archives/page/2/index.html","hash":"707adad91896b66a57f1375ea71b25bc3acc46f8","modified":1760601283460},{"_id":"public/archives/2024/index.html","hash":"7916174121a6e1801d92251fb27bb2c309a24a88","modified":1760601283460},{"_id":"public/archives/2024/page/2/index.html","hash":"92123b22b29dd4bb925d6770819b917a9fb09d9f","modified":1760601283460},{"_id":"public/archives/2024/10/index.html","hash":"e5987f2cbbfcfe82521a55cac4a393fb3923415d","modified":1760601283460},{"_id":"public/archives/2024/11/index.html","hash":"8f3c600d1053a237f6ac72b40b7597538fcf5cc8","modified":1760601283460},{"_id":"public/archives/2024/12/index.html","hash":"a773742a6e73949d460c183031caec10869f5b97","modified":1760601283460},{"_id":"public/index.html","hash":"aac19afc501ac4943f2ef2476b1f9a93e910d74b","modified":1760601283460},{"_id":"public/page/2/index.html","hash":"a0901835b1091a5b551de0250b3d5d12afe74edb","modified":1760601283460},{"_id":"public/tags/三维视觉/index.html","hash":"0092feb8ea7634b933a591bdb8cc91e9b392057d","modified":1760601283460},{"_id":"public/tags/SLAM/index.html","hash":"ea2437e7b954971ed2f1403c8760a28bf4cb2529","modified":1760601283460},{"_id":"public/tags/学习笔记/index.html","hash":"c7bb5fd71fb8c006e004d4bd774e2c4aa79cc513","modified":1760601283460},{"_id":"public/tags/学习笔记/page/2/index.html","hash":"0ea1a60b14e9b826f8b67a85d33a51e99afcb788","modified":1760601283460},{"_id":"public/tags/深度估计/index.html","hash":"b0b0eaf516316e3ef3c277b2abf23f426ca6cc10","modified":1760601283460},{"_id":"public/tags/论文阅读总结/index.html","hash":"12c2e1eaa7bbb5ad52932019ef162a48d46c8794","modified":1760601283460},{"_id":"public/tags/数据库/index.html","hash":"7d083a571d7ebc4f658d381f4e4295c58dae8480","modified":1760601283460},{"_id":"public/tags/Archlinux/index.html","hash":"8fe24d137cde1cf21cec259e636512eb7c02d1f9","modified":1760601283460},{"_id":"public/404.html","hash":"4c853b6ae3f2a18b773ae3179cc48aa350f2fa2d","modified":1760601283460},{"_id":"public/tags/index.html","hash":"3827fc36e66090b7323b6cb930f167c4033f291b","modified":1760601283460},{"_id":"public/categories/index.html","hash":"684e84d7f0501250153fe8ae2099fd0563a47067","modified":1760601283460},{"_id":"public/links/index.html","hash":"fb496eb182c5e84f1b93030e9561a03b1bc175f6","modified":1760601283460},{"_id":"public/img/数据库(6)/视图映射.png","hash":"061dfcf7cc696e1986a50fdceca030406f89f138","modified":1760601283460},{"_id":"public/img/软件工程(2)/UML类结构.png","hash":"3422fe834d293eedd06660faa694e5e28584aff5","modified":1760601283460},{"_id":"public/img/软件工程(2)/基本用例与子用例(1).png","hash":"3ed52eea17a6eccd32e2b933f96090d28ee36d15","modified":1760601283460},{"_id":"public/img/软件工程(2)/基本用例与子用例(2).png","hash":"965cd9e7402dc2e2f3762d67edb6279820572815","modified":1760601283460},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1760601283460},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1760601283460},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1760601283460},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1760601283460},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1760601283460},{"_id":"public/img/数据库(7)/三元关系.png","hash":"e8284e8cd01e820af447f9a8d4fb4b3669effc90","modified":1760601283460},{"_id":"public/img/数据库(7)/复合属性.png","hash":"92562719c6cb72aa6d78fb2b54faf38247dedc53","modified":1760601283460},{"_id":"public/img/数据库(7)/数据库整体设计过程.png","hash":"f06e6db37e1a60fe22ab4ac0b40d54a3282568a8","modified":1760601283460},{"_id":"public/img/数据库(7)/设计过程.png","hash":"3876d15816a18e9276bbdb60b449c0284588b218","modified":1760601283460},{"_id":"public/img/软件工程(2)/UML9个基本图(1).png","hash":"2f1bceaeeafe4502a9d679f1eca1d090403ba898","modified":1760601283460},{"_id":"public/img/软件工程(2)/UML类_继承和实现.png","hash":"c5a7dc3296fe964e171dbb3bb19ba46a9e445a23","modified":1760601283460},{"_id":"public/img/软件工程(2)/UML视图.png","hash":"02536a105266065803a590fc3e0c7ed66761649d","modified":1760601283460},{"_id":"public/img/软件工程(2)/操作契约.png","hash":"82435184a0bc008d9debe51423876d4aa7ac7748","modified":1760601283460},{"_id":"public/img/软件工程(2)/油画关系图.png","hash":"ddb83a5c3c8e9c7e58967f2587e3bac02497b2cd","modified":1760601283460},{"_id":"public/img/软件工程(2)/活动图.png","hash":"ccaf7315032860503c9ac024b5ce98e282526da3","modified":1760601283460},{"_id":"public/img/软件工程(2)/系统顺序图(1).png","hash":"cb82fc4b8a3c714e19497d79d0421ce1b9cdf6da","modified":1760601283460},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1760601283460},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1760601283460},{"_id":"public/css/main.css","hash":"14ebd9b515085666cee29bbcbe362ad3604ab62a","modified":1760601283460},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1760601283460},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1760601283460},{"_id":"public/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1760601283460},{"_id":"public/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1760601283460},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1760601283460},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1760601283460},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1760601283460},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1760601283460},{"_id":"public/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1760601283460},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1760601283460},{"_id":"public/img/数据库(6)/数据库三层次结构.png","hash":"b8b55c9fd57e8fbc13a488f26bc3c69c2fc76e4c","modified":1760601283460},{"_id":"public/img/软件工程(1)/构件组装模型.png","hash":"87ceb3e54f077bed51b0badceba161fbd68154ac","modified":1760601283460},{"_id":"public/img/软件工程(2)/UML类_关联和依赖.png","hash":"05a4370784f3845a7900671480e10108e6af8036","modified":1760601283460},{"_id":"public/img/软件工程(2)/UML类_方法.png","hash":"1c0aa2c9395de0e868dafbf9fa0ed359da3d6469","modified":1760601283460},{"_id":"public/img/软件工程(2)/系统顺序图(2).png","hash":"ce8e6cb13b7d693f20bdbdd13907a882e914e5a8","modified":1760601283460},{"_id":"public/img/操作系统(1)/虚拟机.png","hash":"ced9402d74ece591de3397d341a98efbe93758d1","modified":1760601283460},{"_id":"public/img/数据库(4)/代数关系式.png","hash":"6e6f81f0517e6ce752d85d09280c193aed8440dc","modified":1760601283460},{"_id":"public/img/数据库(5)/表操作顺序.png","hash":"4dd6762c0c088b134367a6f2b4797881bb215e67","modified":1760601283460},{"_id":"public/img/软件工程(1)/快速应用开发模型.png","hash":"aa6704661ee7b36d3f45ae6bba8f90c33aba7e51","modified":1760601283460},{"_id":"public/img/软件工程(1)/演化模型.png","hash":"f9f09b2445315cef690de8296ec835dacc280bdf","modified":1760601283460},{"_id":"public/img/软件工程(2)/UML9个基本图(2).png","hash":"83a752b209354f1ff8087aadf8485a85b6829fc5","modified":1760601283460},{"_id":"public/img/软件工程(1)/软件生命周期.png","hash":"c34e4c7b19ec8cc66887cbd4aea5c3a8faa948e0","modified":1760601283460},{"_id":"public/img/软件工程(2)/UML类_属性.png","hash":"04a43f54e88aa4298c8b85418e91a22c495b1d8e","modified":1760601283460},{"_id":"public/img/软件工程(2)/UML类_组合和聚合.png","hash":"a73959160d378aba7c8970bf3ba23818787fd396","modified":1760601283460},{"_id":"public/img/软件工程(2)/关系类型及其说明以及表示符号.png","hash":"54324cdded8fbe8c9dd82cbcc2b9421f222c7e18","modified":1760601283460},{"_id":"public/img/软件工程(2)/医院挂号处.png","hash":"13c8b13aa8a237613afaa57d55387a90af480168","modified":1760601283460},{"_id":"public/img/软件工程(2)/对象图.png","hash":"45f66022f6f8557763e893962d6fa529fa42a262","modified":1760601283460},{"_id":"public/img/软件工程(2)/状态图.png","hash":"c190598bfd6bfce29ff7522099fd61ed2b315294","modified":1760601283460},{"_id":"public/img/软件工程(2)/组件图.png","hash":"f9327bd4b65cb54347c66c26929f8df4956af057","modified":1760601283460},{"_id":"public/img/软件工程(1)/V模型和W模型.png","hash":"d68f32a9f068b4a4722db4ce8a69bc122a77313f","modified":1760601283460},{"_id":"public/img/软件工程(1)/螺旋模型.png","hash":"41bd09a0bd4c0809ad14242a88dfd718b09fd921","modified":1760601283460},{"_id":"public/img/软件工程(2)/协作图.png","hash":"7a97afc5affe204f543a0a80d3702f4a0aadae68","modified":1760601283460},{"_id":"public/img/软件工程(2)/用例图.png","hash":"9dafd7b2887bec06fdd572ddea2bb96d26b5c712","modified":1760601283460},{"_id":"public/img/软件工程(2)/用例模型基本结构.png","hash":"c074ea9559e1148594fcecb429eb7454140d12e1","modified":1760601283460},{"_id":"public/img/软件工程(2)/类图.png","hash":"4fcabacfbb96613fdddacfc648cdc68d5d3db047","modified":1760601283460},{"_id":"public/img/软件工程(2)/自然界UML图.png","hash":"3f0906562c068e2e76d0a13bc7394428fe8aef69","modified":1760601283460},{"_id":"public/img/软件工程(2)/顺序图.png","hash":"a0ccc15bc127df02d5047886750045dd1083e7e6","modified":1760601283460},{"_id":"public/img/操作系统(1)/操作系统引导.png","hash":"f590a06c604678641abb1f3d971385dc217edf65","modified":1760601283460},{"_id":"public/img/数据库(4)/外键模式图.png","hash":"f757281bbc6d37a43929be63bffdd5bc92b572c9","modified":1760601283460},{"_id":"public/img/数据库(4)/数据库实例.png","hash":"eef5f03b6117840f6d912eacfd620a411c0666fb","modified":1760601283460},{"_id":"public/img/软件工程(1)/增量模型.png","hash":"7a0df1d0d30ef4280cea385ba45284a8dae05d51","modified":1760601283460},{"_id":"public/img/数据库(6)/格式转换_3.png","hash":"874086b911c147dffd3469f3cc2864ec230f20af","modified":1760601283460},{"_id":"public/img/数据库(6)/格式转换_4.png","hash":"6e53d06b2ddd7db0143983623abd365d81d7677b","modified":1760601283460},{"_id":"public/img/数据库(7)/ER_1.png","hash":"60c15d70b0a3bbd040ed57915e0f0031a235ecc5","modified":1760601283460},{"_id":"public/img/软件工程(2)/UML类_类和接口.png","hash":"390028803059bee792c9aa7776facf5ccb3621c5","modified":1760601283460},{"_id":"public/img/软件工程(2)/关联箭头总览.png","hash":"8cd652a5c5a2c21698ce6bddc081e7d08d5b4e8d","modified":1760601283460},{"_id":"public/img/软件工程(2)/部署图.png","hash":"821e8e1d7b781fa2125b4e68f829f5a45259890e","modified":1760601283460},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1760601283460},{"_id":"public/img/数据库(5)/数据库关系图.png","hash":"792753ff0181124b452cd05ebae9a8ce82b7d204","modified":1760601283460},{"_id":"public/img/数据库(7)/DBS设计.png","hash":"0777383758fa6b2a1ae2ad81705325fef94332b2","modified":1760601283460},{"_id":"public/img/操作系统(2)/进程的组成.png","hash":"482562701d9a056a8e880562312ff1996e56d5e2","modified":1760601283460},{"_id":"public/img/数据库(4)/模式图.png","hash":"bbec28c777d99642b12c51e698f8988d27131085","modified":1760601283460},{"_id":"public/img/数据库(6)/格式转换_2.png","hash":"8f37489fb213717b1f0b002dec04538a95849320","modified":1760601283460},{"_id":"public/img/操作系统(2)/进程的特征.png","hash":"d55ab923e2466a7da7abbd5541ffe7b6c34f313d","modified":1760601283460},{"_id":"public/img/数据库(6)/格式转换_1.png","hash":"e9b9ab936d8679e59c643320844aee594fe1e2ff","modified":1760601283460},{"_id":"public/img/软件工程(2)/关系箭头总览.png","hash":"ca11f897027c1b8e21ce21b01dbce0002f40f90b","modified":1760601283460},{"_id":"public/img/操作系统(2)/PCB.png","hash":"08f82fdf91488e84e11cf5122f6706f879f5c31b","modified":1760601283460},{"_id":"public/img/软件工程(1)/模型开发特定及适用场合.png","hash":"a83fbb1bbfd032b77d5be956448879cd2216ccbf","modified":1760601283460}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2024-09-30T11:49:36.000Z","layout":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2024-09-30 19:49:36\nlayout: about\n---\n","updated":"2024-12-20T04:27:29.410Z","path":"about/index.html","comments":1,"_id":"cmgt4jot100006d6e35zg355t","content":"","excerpt":"","more":""}],"Post":[{"title":"SLAM(1)","date":"2024-10-03T02:45:51.000Z","_content":"本文主要介绍SLAM最基础的纯视觉版本 ORB-SLAM。该版本SLAM通过单目相机，提取坐标中的特征点，循环检测以实现较为精准的定位。\n### 补充知识\n#### 词袋模型\n对于一张图片进行词袋模型建立，需要一下三步:\n1. 对于图像进行整体特征检测，投射入特征空间，然后进行聚类。\n2. 对于聚类产生的类，取每个类的中心为一个单词。\n3. 每次增加的图像增加的特征点加入特征空间，然后根据其对于各个类的距离进行分类.\n   \n由此实现对每张图的词袋表示。\n#### 基于词袋模型的图像检索\n\n对于图片的词袋模型搜索，常常采用TF-IDF(Term frequency(词频因子)-inverse document frequency(逆文档频率因子))\n- 文档 *i* 中出现频率越高的词，其重要性越高。\n- 数据库中包含单词 *j* 的文档越多，该单词对于文档的区分性越低，重要性也就越低。\n$$\n    t_j=\\frac{n_{ij}}{n_i} \\log(\\frac{N}{n_j})\n$$\n在整个图像搜索过程中，采用倒排索引方法，索引值是特征编号，而不是图像编号。相对于图像所以，单词的数量在一定阈值后不会随着图像的增加而增加。故而其索引数量从图像数量N变成了特征点数量 $n_j$ 。同时在检索之后一般进行空间验证，以保证获取的点具有几何一致性，最终获取重排结果。\n\n#### 优化问题\n**ORB_SLAM**中的典型优化函数：\n1. **GlobalBundleAdjustment** 除第一帧摄像机位置外，全部的地图点和关键帧相机优化(初始化)\n2. **LocalBundleAdjustment** 优化部分地图点和关键帧的位姿\n3. **PoseOptimization** 仅优化单帧摄像位姿(3D-2D重投影最小化、运动跟踪、参考帧跟踪、局部地图跟踪、重定位)\n4. **OptimizeEssentialGraph** 本质图优化全部相机位姿(回环检测)\n5. **OptimizeSim3** 优化两个关键帧和关键帧共有的地图点(回环检测)\n#### 生成树\n对于连通图进行遍历，过程中所经过的边和顶点的组合可以看做是一个普通树，通常成为生成树。\n连通图中的生成树必须满足一下两个条件：\n1. 包含连通图中的所有顶点\n2. 任意两条顶点之间有且只有一条通路\n\n### SLAM介绍\n**Simultaneous Localization and Mapping (SLAM)**\n- Localization：传感器的位置和姿态\n- Mapping：地图构建\n- SLAM：同时定位和建图\n- 应用场景：定位，导航，避障，重建，交互\n\n在整个地图构建的过程中，根据地图的特点可以分为：拓扑地图、2D栅格地图、3D网格地图、3D点云地图\n  \n### ORB-SLAM详解\n在**ORB-SLAM**中\n- 一般会同时运行三个线程：\n  - 跟踪：确定当前帧位姿\n  - 建图：完成局部地图构建\n  - 回环修整：回环检测以及基于回环信息修正系统漂移\n- 数据中心中，会存储\n  1. 视觉词典\n  2. 关键帧词袋数据库。\n- 数据中心存储的数据包含\n  1. 地图点\n       - 世界坐标系下的3D坐标\n       - 观测方向，即所有可以观测到该特征点的视图所产生的观测方向均值\n       - 最具表达性的ORB特征描述子\n       - 该点能被观测到的最大距离和最小距离\n  2. 关键帧\n       - 摄像机位姿\n       - 内参数\n       - 全部ORB特征描述符，是否有地图点对应\n  3. 共视图\n       - 一种无向有全图，节点为关键帧，如果两个阶段共享的地图数大于阈值(至少15个)则存在一条边，其权重设置为共享地图的个数\n  4. 本质图\n       - 共视图的子图，保留所有节点，边数量相较于共视图更少，其作用是加速会还矫正的计算\n        $本质图 = 生成树 + 共视图边权重超过100的边 + 回环边$\n#### 跟踪\n**目标**: 构建初始的地图点云，第一个摄像机作为世界坐标系。\n  1. 计算特征点匹配，匹配数要大于预定义门限\n  2. 同时计算基础矩阵F与单应矩阵H(注：匹配点可能来自同一平面)\n  3. 分别计算F和H误差，选择最合理的矩阵\n  4. 对F或者H进行分解，三角化重构出初始地图点\n  5. 使用**GlobalBA**进行优化，即关键帧位姿与重构的地图点都参与优化\n\n**基于前一帧的估计**：\n  1. 如果前一帧跟踪成功，利用上一帧的运动模型估计当前帧的相机位姿\n  2. 依据估计的R和T，将前一帧观测到的地图点投影到当前帧\n  3. 如果成功找到足够多的点，则依照2D-3D对应点计算相机位姿(EPnP)；如果失败则转到全局重定位。  \n  4. 在全局重定位中，计算当前帧的词袋，在数据库中进行检索，找到匹配度大于某个门限的候选参考关键帧，并对于每个候选参考关键帧进行特征点匹配和PnP计算操作，实现迭代优化，求解计算机位姿\n  5. \n**局部地图跟踪：**\n  1. 寻找候选“局部地图点”\n     - 建立共视图中与当前帧相练的关键帧集合$K_1$以及与$K_1$相连的关键帧集合$K_2$\n     - $K_1+K_2$看到的全部地图点构成\"局部地图点\"集合\n     - $K_1$与当前帧相似度最高的设为$K_{ref}$\n  2. 筛选地图点\n     - 无法引申到当前帧的地图点舍弃\n     - 当前点视图方向和该地图点的平均视图方向$n$满足$v*n < \\cos(60^\\circ)$ \n     - 计算地图点到该帧摄像机中心的距离$d$,如果$d \\notin [d_{min}, d_{max}],则该地图点舍弃$\n     - 计算尺度$\\frac{d}{d_{min}}$，在该帧中，对于所有未匹配的ORB特征描述子，检测在该尺度下是否有3D点的投影与其匹配，若匹配则将该未匹配的特征描述子与3D点建立联系\n  3. 使用所有未被筛选掉的2D-3D点对应当前帧进行位姿优化\n\n**关键帧需要满足的条件：**\n  1. 距离上次全局重定位已经经历了超过20帧(刚重定位的帧位姿可能不够准确)\n  2.  局部地图线程空闲\n  3.  或者距离上次关键帧插入超过了20帧(场景变化)\n  4.  当前至少有50个关键点(该帧特征充足，可信度高)\n  5.  当前帧和$K_{ref}$共视点相似比小于90%\n\n#### 建图\n**关键帧插入：**\n- 更新共视图，增加新的节点$K_i$，更新共视图链接关系\n- 更新生成树的节点关系\n- 计算该新增关键帧的词袋表示，为新建地图点做准备\n\n**地图点剔除**\n- 最近增加的地图点必须通过如下测试，才可以留在地图中\n  - 实际观测比例大于理论的25%\n  - 地图点被创建后，再经过三个关键帧都可以观测到它\n- 通过测试过的地图点，只在如下情况时会被删除\n  - 任何时间下观测它的关键帧个数小于3(通常发生在删除关键帧时) \n\n**对于当前帧$K_I$中没有被特征匹配的特征点进行如下处理：**\n  - 在共视图中选取共视程度最高且基线宽度大于某阈值的关键帧进行特征点匹配和三角化，对重构结果进行尺度、重投影误差、视差(不易过小)、正向深度检验。\n  - 通过检验的点再投影到其他视图中，能匹配成功则建立“地图点-关键帧特征点”的对应关系。\n\n**优化局部地图**\n  - 当前帧(位姿)与共视关键帧(位姿)，及其它们看到的所有地图点(空间坐标)，参与局部BA优化。\n  - 所有能看到上述地图点单与当前关键帧没有共视关系的关键帧参与局部BA，但它们的位姿在优化过程中固定不变。  \n\n**局部关键帧剔除**\n当场景不发生变化时，控制关键帧的数量。如果当前90%的地图点都可以被至少其他三个关键帧在相同或者更精细的尺度观测到，则该关键帧被剔除。\n\n#### 回环修整\n**回环候选帧检测**\n  1. 回环候选关键帧产生\n    - 在共视图中计算$K_i$与所邻居的BOW向量相似性，保存最低分数，记作$s_{min}$\n    - 分数低于$s_{min}$的帧不做备选，与当前帧$K_i$直接相连的帧不做备选\n  2. 确认回环关键帧\n   \n**对于每一个候选回环关键帧$K_j$**\n  1. 计算其与当前关键帧$K_i$的特征匹配，建立3D-3D点对应\n  2. 利用RANSAC方法估计其与当前帧的相似变换$S_{ij}$(7个自由度)\n  3. 利用$S_{ij}$搜索两帧之间更多点对应\n  4. 基于点对应优化$S_{ij}$直至有足够多内点，则接受当前候选回环关键帧，并记为$K_i$，其相似变换记为$S_{jl}$\n\n**回环融合**\n  1. 基于相似性矩阵$S_{il}$修正当前帧$K_i$(及其共视帧位姿)\n  2. 特征点匹配与地图匹配融合：将回环帧$K_i$及其共视帧可见的地图点投影到当前帧$K_i$及其共视关键帧，寻找匹配并融合\n  3. 连接关系更新:融合过程中涉及到的关键帧的边均需要更新，包括回环边\n  - 每条边的误差为:\n    $$\n    e_{ij} = \\log(S_{ij}S_{jw}S_{iw}^{-1})\n    $$\n  - 本质图上的总误差为：\n    $$\n    C = \\sum_{i,j}{e_{i,j}^T\\Lambda{e_{ij}}}    \\\\\n    其中，{\\Lambda}_{i,j}为单位矩阵\n    $$\n\n\n","source":"_posts/SLAM-1.md","raw":"---\ntitle: SLAM(1)\ndate: 2024-10-03 10:45:51\ntags:\n    - 三维视觉\n    - SLAM\n    - 学习笔记\n---\n本文主要介绍SLAM最基础的纯视觉版本 ORB-SLAM。该版本SLAM通过单目相机，提取坐标中的特征点，循环检测以实现较为精准的定位。\n### 补充知识\n#### 词袋模型\n对于一张图片进行词袋模型建立，需要一下三步:\n1. 对于图像进行整体特征检测，投射入特征空间，然后进行聚类。\n2. 对于聚类产生的类，取每个类的中心为一个单词。\n3. 每次增加的图像增加的特征点加入特征空间，然后根据其对于各个类的距离进行分类.\n   \n由此实现对每张图的词袋表示。\n#### 基于词袋模型的图像检索\n\n对于图片的词袋模型搜索，常常采用TF-IDF(Term frequency(词频因子)-inverse document frequency(逆文档频率因子))\n- 文档 *i* 中出现频率越高的词，其重要性越高。\n- 数据库中包含单词 *j* 的文档越多，该单词对于文档的区分性越低，重要性也就越低。\n$$\n    t_j=\\frac{n_{ij}}{n_i} \\log(\\frac{N}{n_j})\n$$\n在整个图像搜索过程中，采用倒排索引方法，索引值是特征编号，而不是图像编号。相对于图像所以，单词的数量在一定阈值后不会随着图像的增加而增加。故而其索引数量从图像数量N变成了特征点数量 $n_j$ 。同时在检索之后一般进行空间验证，以保证获取的点具有几何一致性，最终获取重排结果。\n\n#### 优化问题\n**ORB_SLAM**中的典型优化函数：\n1. **GlobalBundleAdjustment** 除第一帧摄像机位置外，全部的地图点和关键帧相机优化(初始化)\n2. **LocalBundleAdjustment** 优化部分地图点和关键帧的位姿\n3. **PoseOptimization** 仅优化单帧摄像位姿(3D-2D重投影最小化、运动跟踪、参考帧跟踪、局部地图跟踪、重定位)\n4. **OptimizeEssentialGraph** 本质图优化全部相机位姿(回环检测)\n5. **OptimizeSim3** 优化两个关键帧和关键帧共有的地图点(回环检测)\n#### 生成树\n对于连通图进行遍历，过程中所经过的边和顶点的组合可以看做是一个普通树，通常成为生成树。\n连通图中的生成树必须满足一下两个条件：\n1. 包含连通图中的所有顶点\n2. 任意两条顶点之间有且只有一条通路\n\n### SLAM介绍\n**Simultaneous Localization and Mapping (SLAM)**\n- Localization：传感器的位置和姿态\n- Mapping：地图构建\n- SLAM：同时定位和建图\n- 应用场景：定位，导航，避障，重建，交互\n\n在整个地图构建的过程中，根据地图的特点可以分为：拓扑地图、2D栅格地图、3D网格地图、3D点云地图\n  \n### ORB-SLAM详解\n在**ORB-SLAM**中\n- 一般会同时运行三个线程：\n  - 跟踪：确定当前帧位姿\n  - 建图：完成局部地图构建\n  - 回环修整：回环检测以及基于回环信息修正系统漂移\n- 数据中心中，会存储\n  1. 视觉词典\n  2. 关键帧词袋数据库。\n- 数据中心存储的数据包含\n  1. 地图点\n       - 世界坐标系下的3D坐标\n       - 观测方向，即所有可以观测到该特征点的视图所产生的观测方向均值\n       - 最具表达性的ORB特征描述子\n       - 该点能被观测到的最大距离和最小距离\n  2. 关键帧\n       - 摄像机位姿\n       - 内参数\n       - 全部ORB特征描述符，是否有地图点对应\n  3. 共视图\n       - 一种无向有全图，节点为关键帧，如果两个阶段共享的地图数大于阈值(至少15个)则存在一条边，其权重设置为共享地图的个数\n  4. 本质图\n       - 共视图的子图，保留所有节点，边数量相较于共视图更少，其作用是加速会还矫正的计算\n        $本质图 = 生成树 + 共视图边权重超过100的边 + 回环边$\n#### 跟踪\n**目标**: 构建初始的地图点云，第一个摄像机作为世界坐标系。\n  1. 计算特征点匹配，匹配数要大于预定义门限\n  2. 同时计算基础矩阵F与单应矩阵H(注：匹配点可能来自同一平面)\n  3. 分别计算F和H误差，选择最合理的矩阵\n  4. 对F或者H进行分解，三角化重构出初始地图点\n  5. 使用**GlobalBA**进行优化，即关键帧位姿与重构的地图点都参与优化\n\n**基于前一帧的估计**：\n  1. 如果前一帧跟踪成功，利用上一帧的运动模型估计当前帧的相机位姿\n  2. 依据估计的R和T，将前一帧观测到的地图点投影到当前帧\n  3. 如果成功找到足够多的点，则依照2D-3D对应点计算相机位姿(EPnP)；如果失败则转到全局重定位。  \n  4. 在全局重定位中，计算当前帧的词袋，在数据库中进行检索，找到匹配度大于某个门限的候选参考关键帧，并对于每个候选参考关键帧进行特征点匹配和PnP计算操作，实现迭代优化，求解计算机位姿\n  5. \n**局部地图跟踪：**\n  1. 寻找候选“局部地图点”\n     - 建立共视图中与当前帧相练的关键帧集合$K_1$以及与$K_1$相连的关键帧集合$K_2$\n     - $K_1+K_2$看到的全部地图点构成\"局部地图点\"集合\n     - $K_1$与当前帧相似度最高的设为$K_{ref}$\n  2. 筛选地图点\n     - 无法引申到当前帧的地图点舍弃\n     - 当前点视图方向和该地图点的平均视图方向$n$满足$v*n < \\cos(60^\\circ)$ \n     - 计算地图点到该帧摄像机中心的距离$d$,如果$d \\notin [d_{min}, d_{max}],则该地图点舍弃$\n     - 计算尺度$\\frac{d}{d_{min}}$，在该帧中，对于所有未匹配的ORB特征描述子，检测在该尺度下是否有3D点的投影与其匹配，若匹配则将该未匹配的特征描述子与3D点建立联系\n  3. 使用所有未被筛选掉的2D-3D点对应当前帧进行位姿优化\n\n**关键帧需要满足的条件：**\n  1. 距离上次全局重定位已经经历了超过20帧(刚重定位的帧位姿可能不够准确)\n  2.  局部地图线程空闲\n  3.  或者距离上次关键帧插入超过了20帧(场景变化)\n  4.  当前至少有50个关键点(该帧特征充足，可信度高)\n  5.  当前帧和$K_{ref}$共视点相似比小于90%\n\n#### 建图\n**关键帧插入：**\n- 更新共视图，增加新的节点$K_i$，更新共视图链接关系\n- 更新生成树的节点关系\n- 计算该新增关键帧的词袋表示，为新建地图点做准备\n\n**地图点剔除**\n- 最近增加的地图点必须通过如下测试，才可以留在地图中\n  - 实际观测比例大于理论的25%\n  - 地图点被创建后，再经过三个关键帧都可以观测到它\n- 通过测试过的地图点，只在如下情况时会被删除\n  - 任何时间下观测它的关键帧个数小于3(通常发生在删除关键帧时) \n\n**对于当前帧$K_I$中没有被特征匹配的特征点进行如下处理：**\n  - 在共视图中选取共视程度最高且基线宽度大于某阈值的关键帧进行特征点匹配和三角化，对重构结果进行尺度、重投影误差、视差(不易过小)、正向深度检验。\n  - 通过检验的点再投影到其他视图中，能匹配成功则建立“地图点-关键帧特征点”的对应关系。\n\n**优化局部地图**\n  - 当前帧(位姿)与共视关键帧(位姿)，及其它们看到的所有地图点(空间坐标)，参与局部BA优化。\n  - 所有能看到上述地图点单与当前关键帧没有共视关系的关键帧参与局部BA，但它们的位姿在优化过程中固定不变。  \n\n**局部关键帧剔除**\n当场景不发生变化时，控制关键帧的数量。如果当前90%的地图点都可以被至少其他三个关键帧在相同或者更精细的尺度观测到，则该关键帧被剔除。\n\n#### 回环修整\n**回环候选帧检测**\n  1. 回环候选关键帧产生\n    - 在共视图中计算$K_i$与所邻居的BOW向量相似性，保存最低分数，记作$s_{min}$\n    - 分数低于$s_{min}$的帧不做备选，与当前帧$K_i$直接相连的帧不做备选\n  2. 确认回环关键帧\n   \n**对于每一个候选回环关键帧$K_j$**\n  1. 计算其与当前关键帧$K_i$的特征匹配，建立3D-3D点对应\n  2. 利用RANSAC方法估计其与当前帧的相似变换$S_{ij}$(7个自由度)\n  3. 利用$S_{ij}$搜索两帧之间更多点对应\n  4. 基于点对应优化$S_{ij}$直至有足够多内点，则接受当前候选回环关键帧，并记为$K_i$，其相似变换记为$S_{jl}$\n\n**回环融合**\n  1. 基于相似性矩阵$S_{il}$修正当前帧$K_i$(及其共视帧位姿)\n  2. 特征点匹配与地图匹配融合：将回环帧$K_i$及其共视帧可见的地图点投影到当前帧$K_i$及其共视关键帧，寻找匹配并融合\n  3. 连接关系更新:融合过程中涉及到的关键帧的边均需要更新，包括回环边\n  - 每条边的误差为:\n    $$\n    e_{ij} = \\log(S_{ij}S_{jw}S_{iw}^{-1})\n    $$\n  - 本质图上的总误差为：\n    $$\n    C = \\sum_{i,j}{e_{i,j}^T\\Lambda{e_{ij}}}    \\\\\n    其中，{\\Lambda}_{i,j}为单位矩阵\n    $$\n\n\n","slug":"SLAM-1","published":1,"updated":"2024-12-20T04:27:29.408Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot200016d6e9boq76ca","content":"<p>本文主要介绍SLAM最基础的纯视觉版本 ORB-SLAM。该版本SLAM通过单目相机，提取坐标中的特征点，循环检测以实现较为精准的定位。</p>\n<h3 id=\"补充知识\"><a href=\"#补充知识\" class=\"headerlink\" title=\"补充知识\"></a>补充知识</h3><h4 id=\"词袋模型\"><a href=\"#词袋模型\" class=\"headerlink\" title=\"词袋模型\"></a>词袋模型</h4><p>对于一张图片进行词袋模型建立，需要一下三步:</p>\n<ol>\n<li>对于图像进行整体特征检测，投射入特征空间，然后进行聚类。</li>\n<li>对于聚类产生的类，取每个类的中心为一个单词。</li>\n<li>每次增加的图像增加的特征点加入特征空间，然后根据其对于各个类的距离进行分类.</li>\n</ol>\n<p>由此实现对每张图的词袋表示。</p>\n<h4 id=\"基于词袋模型的图像检索\"><a href=\"#基于词袋模型的图像检索\" class=\"headerlink\" title=\"基于词袋模型的图像检索\"></a>基于词袋模型的图像检索</h4><p>对于图片的词袋模型搜索，常常采用TF-IDF(Term frequency(词频因子)-inverse document frequency(逆文档频率因子))</p>\n<ul>\n<li>文档 <em>i</em> 中出现频率越高的词，其重要性越高。</li>\n<li>数据库中包含单词 <em>j</em> 的文档越多，该单词对于文档的区分性越低，重要性也就越低。<br>$$<br>  t_j&#x3D;\\frac{n_{ij}}{n_i} \\log(\\frac{N}{n_j})<br>$$<br>在整个图像搜索过程中，采用倒排索引方法，索引值是特征编号，而不是图像编号。相对于图像所以，单词的数量在一定阈值后不会随着图像的增加而增加。故而其索引数量从图像数量N变成了特征点数量 $n_j$ 。同时在检索之后一般进行空间验证，以保证获取的点具有几何一致性，最终获取重排结果。</li>\n</ul>\n<h4 id=\"优化问题\"><a href=\"#优化问题\" class=\"headerlink\" title=\"优化问题\"></a>优化问题</h4><p><strong>ORB_SLAM</strong>中的典型优化函数：</p>\n<ol>\n<li><strong>GlobalBundleAdjustment</strong> 除第一帧摄像机位置外，全部的地图点和关键帧相机优化(初始化)</li>\n<li><strong>LocalBundleAdjustment</strong> 优化部分地图点和关键帧的位姿</li>\n<li><strong>PoseOptimization</strong> 仅优化单帧摄像位姿(3D-2D重投影最小化、运动跟踪、参考帧跟踪、局部地图跟踪、重定位)</li>\n<li><strong>OptimizeEssentialGraph</strong> 本质图优化全部相机位姿(回环检测)</li>\n<li><strong>OptimizeSim3</strong> 优化两个关键帧和关键帧共有的地图点(回环检测)</li>\n</ol>\n<h4 id=\"生成树\"><a href=\"#生成树\" class=\"headerlink\" title=\"生成树\"></a>生成树</h4><p>对于连通图进行遍历，过程中所经过的边和顶点的组合可以看做是一个普通树，通常成为生成树。<br>连通图中的生成树必须满足一下两个条件：</p>\n<ol>\n<li>包含连通图中的所有顶点</li>\n<li>任意两条顶点之间有且只有一条通路</li>\n</ol>\n<h3 id=\"SLAM介绍\"><a href=\"#SLAM介绍\" class=\"headerlink\" title=\"SLAM介绍\"></a>SLAM介绍</h3><p><strong>Simultaneous Localization and Mapping (SLAM)</strong></p>\n<ul>\n<li>Localization：传感器的位置和姿态</li>\n<li>Mapping：地图构建</li>\n<li>SLAM：同时定位和建图</li>\n<li>应用场景：定位，导航，避障，重建，交互</li>\n</ul>\n<p>在整个地图构建的过程中，根据地图的特点可以分为：拓扑地图、2D栅格地图、3D网格地图、3D点云地图</p>\n<h3 id=\"ORB-SLAM详解\"><a href=\"#ORB-SLAM详解\" class=\"headerlink\" title=\"ORB-SLAM详解\"></a>ORB-SLAM详解</h3><p>在<strong>ORB-SLAM</strong>中</p>\n<ul>\n<li>一般会同时运行三个线程：<ul>\n<li>跟踪：确定当前帧位姿</li>\n<li>建图：完成局部地图构建</li>\n<li>回环修整：回环检测以及基于回环信息修正系统漂移</li>\n</ul>\n</li>\n<li>数据中心中，会存储<ol>\n<li>视觉词典</li>\n<li>关键帧词袋数据库。</li>\n</ol>\n</li>\n<li>数据中心存储的数据包含<ol>\n<li>地图点<ul>\n<li>世界坐标系下的3D坐标</li>\n<li>观测方向，即所有可以观测到该特征点的视图所产生的观测方向均值</li>\n<li>最具表达性的ORB特征描述子</li>\n<li>该点能被观测到的最大距离和最小距离</li>\n</ul>\n</li>\n<li>关键帧<ul>\n<li>摄像机位姿</li>\n<li>内参数</li>\n<li>全部ORB特征描述符，是否有地图点对应</li>\n</ul>\n</li>\n<li>共视图<ul>\n<li>一种无向有全图，节点为关键帧，如果两个阶段共享的地图数大于阈值(至少15个)则存在一条边，其权重设置为共享地图的个数</li>\n</ul>\n</li>\n<li>本质图<ul>\n<li>共视图的子图，保留所有节点，边数量相较于共视图更少，其作用是加速会还矫正的计算<br>   $本质图 &#x3D; 生成树 + 共视图边权重超过100的边 + 回环边$</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"跟踪\"><a href=\"#跟踪\" class=\"headerlink\" title=\"跟踪\"></a>跟踪</h4><p><strong>目标</strong>: 构建初始的地图点云，第一个摄像机作为世界坐标系。</p>\n<ol>\n<li>计算特征点匹配，匹配数要大于预定义门限</li>\n<li>同时计算基础矩阵F与单应矩阵H(注：匹配点可能来自同一平面)</li>\n<li>分别计算F和H误差，选择最合理的矩阵</li>\n<li>对F或者H进行分解，三角化重构出初始地图点</li>\n<li>使用<strong>GlobalBA</strong>进行优化，即关键帧位姿与重构的地图点都参与优化</li>\n</ol>\n<p><strong>基于前一帧的估计</strong>：</p>\n<ol>\n<li>如果前一帧跟踪成功，利用上一帧的运动模型估计当前帧的相机位姿</li>\n<li>依据估计的R和T，将前一帧观测到的地图点投影到当前帧</li>\n<li>如果成功找到足够多的点，则依照2D-3D对应点计算相机位姿(EPnP)；如果失败则转到全局重定位。  </li>\n<li>在全局重定位中，计算当前帧的词袋，在数据库中进行检索，找到匹配度大于某个门限的候选参考关键帧，并对于每个候选参考关键帧进行特征点匹配和PnP计算操作，实现迭代优化，求解计算机位姿</li>\n<li><strong>局部地图跟踪：</strong></li>\n<li>寻找候选“局部地图点”<ul>\n<li>建立共视图中与当前帧相练的关键帧集合$K_1$以及与$K_1$相连的关键帧集合$K_2$</li>\n<li>$K_1+K_2$看到的全部地图点构成”局部地图点”集合</li>\n<li>$K_1$与当前帧相似度最高的设为$K_{ref}$</li>\n</ul>\n</li>\n<li>筛选地图点<ul>\n<li>无法引申到当前帧的地图点舍弃</li>\n<li>当前点视图方向和该地图点的平均视图方向$n$满足$v*n &lt; \\cos(60^\\circ)$ </li>\n<li>计算地图点到该帧摄像机中心的距离$d$,如果$d \\notin [d_{min}, d_{max}],则该地图点舍弃$</li>\n<li>计算尺度$\\frac{d}{d_{min}}$，在该帧中，对于所有未匹配的ORB特征描述子，检测在该尺度下是否有3D点的投影与其匹配，若匹配则将该未匹配的特征描述子与3D点建立联系</li>\n</ul>\n</li>\n<li>使用所有未被筛选掉的2D-3D点对应当前帧进行位姿优化</li>\n</ol>\n<p><strong>关键帧需要满足的条件：</strong></p>\n<ol>\n<li>距离上次全局重定位已经经历了超过20帧(刚重定位的帧位姿可能不够准确)</li>\n<li>局部地图线程空闲</li>\n<li>或者距离上次关键帧插入超过了20帧(场景变化)</li>\n<li>当前至少有50个关键点(该帧特征充足，可信度高)</li>\n<li>当前帧和$K_{ref}$共视点相似比小于90%</li>\n</ol>\n<h4 id=\"建图\"><a href=\"#建图\" class=\"headerlink\" title=\"建图\"></a>建图</h4><p><strong>关键帧插入：</strong></p>\n<ul>\n<li>更新共视图，增加新的节点$K_i$，更新共视图链接关系</li>\n<li>更新生成树的节点关系</li>\n<li>计算该新增关键帧的词袋表示，为新建地图点做准备</li>\n</ul>\n<p><strong>地图点剔除</strong></p>\n<ul>\n<li>最近增加的地图点必须通过如下测试，才可以留在地图中<ul>\n<li>实际观测比例大于理论的25%</li>\n<li>地图点被创建后，再经过三个关键帧都可以观测到它</li>\n</ul>\n</li>\n<li>通过测试过的地图点，只在如下情况时会被删除<ul>\n<li>任何时间下观测它的关键帧个数小于3(通常发生在删除关键帧时)</li>\n</ul>\n</li>\n</ul>\n<p><strong>对于当前帧$K_I$中没有被特征匹配的特征点进行如下处理：</strong></p>\n<ul>\n<li>在共视图中选取共视程度最高且基线宽度大于某阈值的关键帧进行特征点匹配和三角化，对重构结果进行尺度、重投影误差、视差(不易过小)、正向深度检验。</li>\n<li>通过检验的点再投影到其他视图中，能匹配成功则建立“地图点-关键帧特征点”的对应关系。</li>\n</ul>\n<p><strong>优化局部地图</strong></p>\n<ul>\n<li>当前帧(位姿)与共视关键帧(位姿)，及其它们看到的所有地图点(空间坐标)，参与局部BA优化。</li>\n<li>所有能看到上述地图点单与当前关键帧没有共视关系的关键帧参与局部BA，但它们的位姿在优化过程中固定不变。</li>\n</ul>\n<p><strong>局部关键帧剔除</strong><br>当场景不发生变化时，控制关键帧的数量。如果当前90%的地图点都可以被至少其他三个关键帧在相同或者更精细的尺度观测到，则该关键帧被剔除。</p>\n<h4 id=\"回环修整\"><a href=\"#回环修整\" class=\"headerlink\" title=\"回环修整\"></a>回环修整</h4><p><strong>回环候选帧检测</strong></p>\n<ol>\n<li>回环候选关键帧产生<br>- 在共视图中计算$K_i$与所邻居的BOW向量相似性，保存最低分数，记作$s_{min}$<br>- 分数低于$s_{min}$的帧不做备选，与当前帧$K_i$直接相连的帧不做备选</li>\n<li>确认回环关键帧</li>\n</ol>\n<p><strong>对于每一个候选回环关键帧$K_j$</strong></p>\n<ol>\n<li>计算其与当前关键帧$K_i$的特征匹配，建立3D-3D点对应</li>\n<li>利用RANSAC方法估计其与当前帧的相似变换$S_{ij}$(7个自由度)</li>\n<li>利用$S_{ij}$搜索两帧之间更多点对应</li>\n<li>基于点对应优化$S_{ij}$直至有足够多内点，则接受当前候选回环关键帧，并记为$K_i$，其相似变换记为$S_{jl}$</li>\n</ol>\n<p><strong>回环融合</strong></p>\n<ol>\n<li>基于相似性矩阵$S_{il}$修正当前帧$K_i$(及其共视帧位姿)</li>\n<li>特征点匹配与地图匹配融合：将回环帧$K_i$及其共视帧可见的地图点投影到当前帧$K_i$及其共视关键帧，寻找匹配并融合</li>\n<li>连接关系更新:融合过程中涉及到的关键帧的边均需要更新，包括回环边</li>\n</ol>\n<ul>\n<li>每条边的误差为:<br>$$<br>e_{ij} &#x3D; \\log(S_{ij}S_{jw}S_{iw}^{-1})<br>$$</li>\n<li>本质图上的总误差为：<br>$$<br>C &#x3D; \\sum_{i,j}{e_{i,j}^T\\Lambda{e_{ij}}}    \\<br>其中，{\\Lambda}_{i,j}为单位矩阵<br>$$</li>\n</ul>\n","excerpt":"","more":"<p>本文主要介绍SLAM最基础的纯视觉版本 ORB-SLAM。该版本SLAM通过单目相机，提取坐标中的特征点，循环检测以实现较为精准的定位。</p>\n<h3 id=\"补充知识\"><a href=\"#补充知识\" class=\"headerlink\" title=\"补充知识\"></a>补充知识</h3><h4 id=\"词袋模型\"><a href=\"#词袋模型\" class=\"headerlink\" title=\"词袋模型\"></a>词袋模型</h4><p>对于一张图片进行词袋模型建立，需要一下三步:</p>\n<ol>\n<li>对于图像进行整体特征检测，投射入特征空间，然后进行聚类。</li>\n<li>对于聚类产生的类，取每个类的中心为一个单词。</li>\n<li>每次增加的图像增加的特征点加入特征空间，然后根据其对于各个类的距离进行分类.</li>\n</ol>\n<p>由此实现对每张图的词袋表示。</p>\n<h4 id=\"基于词袋模型的图像检索\"><a href=\"#基于词袋模型的图像检索\" class=\"headerlink\" title=\"基于词袋模型的图像检索\"></a>基于词袋模型的图像检索</h4><p>对于图片的词袋模型搜索，常常采用TF-IDF(Term frequency(词频因子)-inverse document frequency(逆文档频率因子))</p>\n<ul>\n<li>文档 <em>i</em> 中出现频率越高的词，其重要性越高。</li>\n<li>数据库中包含单词 <em>j</em> 的文档越多，该单词对于文档的区分性越低，重要性也就越低。<br>$$<br>  t_j&#x3D;\\frac{n_{ij}}{n_i} \\log(\\frac{N}{n_j})<br>$$<br>在整个图像搜索过程中，采用倒排索引方法，索引值是特征编号，而不是图像编号。相对于图像所以，单词的数量在一定阈值后不会随着图像的增加而增加。故而其索引数量从图像数量N变成了特征点数量 $n_j$ 。同时在检索之后一般进行空间验证，以保证获取的点具有几何一致性，最终获取重排结果。</li>\n</ul>\n<h4 id=\"优化问题\"><a href=\"#优化问题\" class=\"headerlink\" title=\"优化问题\"></a>优化问题</h4><p><strong>ORB_SLAM</strong>中的典型优化函数：</p>\n<ol>\n<li><strong>GlobalBundleAdjustment</strong> 除第一帧摄像机位置外，全部的地图点和关键帧相机优化(初始化)</li>\n<li><strong>LocalBundleAdjustment</strong> 优化部分地图点和关键帧的位姿</li>\n<li><strong>PoseOptimization</strong> 仅优化单帧摄像位姿(3D-2D重投影最小化、运动跟踪、参考帧跟踪、局部地图跟踪、重定位)</li>\n<li><strong>OptimizeEssentialGraph</strong> 本质图优化全部相机位姿(回环检测)</li>\n<li><strong>OptimizeSim3</strong> 优化两个关键帧和关键帧共有的地图点(回环检测)</li>\n</ol>\n<h4 id=\"生成树\"><a href=\"#生成树\" class=\"headerlink\" title=\"生成树\"></a>生成树</h4><p>对于连通图进行遍历，过程中所经过的边和顶点的组合可以看做是一个普通树，通常成为生成树。<br>连通图中的生成树必须满足一下两个条件：</p>\n<ol>\n<li>包含连通图中的所有顶点</li>\n<li>任意两条顶点之间有且只有一条通路</li>\n</ol>\n<h3 id=\"SLAM介绍\"><a href=\"#SLAM介绍\" class=\"headerlink\" title=\"SLAM介绍\"></a>SLAM介绍</h3><p><strong>Simultaneous Localization and Mapping (SLAM)</strong></p>\n<ul>\n<li>Localization：传感器的位置和姿态</li>\n<li>Mapping：地图构建</li>\n<li>SLAM：同时定位和建图</li>\n<li>应用场景：定位，导航，避障，重建，交互</li>\n</ul>\n<p>在整个地图构建的过程中，根据地图的特点可以分为：拓扑地图、2D栅格地图、3D网格地图、3D点云地图</p>\n<h3 id=\"ORB-SLAM详解\"><a href=\"#ORB-SLAM详解\" class=\"headerlink\" title=\"ORB-SLAM详解\"></a>ORB-SLAM详解</h3><p>在<strong>ORB-SLAM</strong>中</p>\n<ul>\n<li>一般会同时运行三个线程：<ul>\n<li>跟踪：确定当前帧位姿</li>\n<li>建图：完成局部地图构建</li>\n<li>回环修整：回环检测以及基于回环信息修正系统漂移</li>\n</ul>\n</li>\n<li>数据中心中，会存储<ol>\n<li>视觉词典</li>\n<li>关键帧词袋数据库。</li>\n</ol>\n</li>\n<li>数据中心存储的数据包含<ol>\n<li>地图点<ul>\n<li>世界坐标系下的3D坐标</li>\n<li>观测方向，即所有可以观测到该特征点的视图所产生的观测方向均值</li>\n<li>最具表达性的ORB特征描述子</li>\n<li>该点能被观测到的最大距离和最小距离</li>\n</ul>\n</li>\n<li>关键帧<ul>\n<li>摄像机位姿</li>\n<li>内参数</li>\n<li>全部ORB特征描述符，是否有地图点对应</li>\n</ul>\n</li>\n<li>共视图<ul>\n<li>一种无向有全图，节点为关键帧，如果两个阶段共享的地图数大于阈值(至少15个)则存在一条边，其权重设置为共享地图的个数</li>\n</ul>\n</li>\n<li>本质图<ul>\n<li>共视图的子图，保留所有节点，边数量相较于共视图更少，其作用是加速会还矫正的计算<br>   $本质图 &#x3D; 生成树 + 共视图边权重超过100的边 + 回环边$</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"跟踪\"><a href=\"#跟踪\" class=\"headerlink\" title=\"跟踪\"></a>跟踪</h4><p><strong>目标</strong>: 构建初始的地图点云，第一个摄像机作为世界坐标系。</p>\n<ol>\n<li>计算特征点匹配，匹配数要大于预定义门限</li>\n<li>同时计算基础矩阵F与单应矩阵H(注：匹配点可能来自同一平面)</li>\n<li>分别计算F和H误差，选择最合理的矩阵</li>\n<li>对F或者H进行分解，三角化重构出初始地图点</li>\n<li>使用<strong>GlobalBA</strong>进行优化，即关键帧位姿与重构的地图点都参与优化</li>\n</ol>\n<p><strong>基于前一帧的估计</strong>：</p>\n<ol>\n<li>如果前一帧跟踪成功，利用上一帧的运动模型估计当前帧的相机位姿</li>\n<li>依据估计的R和T，将前一帧观测到的地图点投影到当前帧</li>\n<li>如果成功找到足够多的点，则依照2D-3D对应点计算相机位姿(EPnP)；如果失败则转到全局重定位。  </li>\n<li>在全局重定位中，计算当前帧的词袋，在数据库中进行检索，找到匹配度大于某个门限的候选参考关键帧，并对于每个候选参考关键帧进行特征点匹配和PnP计算操作，实现迭代优化，求解计算机位姿</li>\n<li><strong>局部地图跟踪：</strong></li>\n<li>寻找候选“局部地图点”<ul>\n<li>建立共视图中与当前帧相练的关键帧集合$K_1$以及与$K_1$相连的关键帧集合$K_2$</li>\n<li>$K_1+K_2$看到的全部地图点构成”局部地图点”集合</li>\n<li>$K_1$与当前帧相似度最高的设为$K_{ref}$</li>\n</ul>\n</li>\n<li>筛选地图点<ul>\n<li>无法引申到当前帧的地图点舍弃</li>\n<li>当前点视图方向和该地图点的平均视图方向$n$满足$v*n &lt; \\cos(60^\\circ)$ </li>\n<li>计算地图点到该帧摄像机中心的距离$d$,如果$d \\notin [d_{min}, d_{max}],则该地图点舍弃$</li>\n<li>计算尺度$\\frac{d}{d_{min}}$，在该帧中，对于所有未匹配的ORB特征描述子，检测在该尺度下是否有3D点的投影与其匹配，若匹配则将该未匹配的特征描述子与3D点建立联系</li>\n</ul>\n</li>\n<li>使用所有未被筛选掉的2D-3D点对应当前帧进行位姿优化</li>\n</ol>\n<p><strong>关键帧需要满足的条件：</strong></p>\n<ol>\n<li>距离上次全局重定位已经经历了超过20帧(刚重定位的帧位姿可能不够准确)</li>\n<li>局部地图线程空闲</li>\n<li>或者距离上次关键帧插入超过了20帧(场景变化)</li>\n<li>当前至少有50个关键点(该帧特征充足，可信度高)</li>\n<li>当前帧和$K_{ref}$共视点相似比小于90%</li>\n</ol>\n<h4 id=\"建图\"><a href=\"#建图\" class=\"headerlink\" title=\"建图\"></a>建图</h4><p><strong>关键帧插入：</strong></p>\n<ul>\n<li>更新共视图，增加新的节点$K_i$，更新共视图链接关系</li>\n<li>更新生成树的节点关系</li>\n<li>计算该新增关键帧的词袋表示，为新建地图点做准备</li>\n</ul>\n<p><strong>地图点剔除</strong></p>\n<ul>\n<li>最近增加的地图点必须通过如下测试，才可以留在地图中<ul>\n<li>实际观测比例大于理论的25%</li>\n<li>地图点被创建后，再经过三个关键帧都可以观测到它</li>\n</ul>\n</li>\n<li>通过测试过的地图点，只在如下情况时会被删除<ul>\n<li>任何时间下观测它的关键帧个数小于3(通常发生在删除关键帧时)</li>\n</ul>\n</li>\n</ul>\n<p><strong>对于当前帧$K_I$中没有被特征匹配的特征点进行如下处理：</strong></p>\n<ul>\n<li>在共视图中选取共视程度最高且基线宽度大于某阈值的关键帧进行特征点匹配和三角化，对重构结果进行尺度、重投影误差、视差(不易过小)、正向深度检验。</li>\n<li>通过检验的点再投影到其他视图中，能匹配成功则建立“地图点-关键帧特征点”的对应关系。</li>\n</ul>\n<p><strong>优化局部地图</strong></p>\n<ul>\n<li>当前帧(位姿)与共视关键帧(位姿)，及其它们看到的所有地图点(空间坐标)，参与局部BA优化。</li>\n<li>所有能看到上述地图点单与当前关键帧没有共视关系的关键帧参与局部BA，但它们的位姿在优化过程中固定不变。</li>\n</ul>\n<p><strong>局部关键帧剔除</strong><br>当场景不发生变化时，控制关键帧的数量。如果当前90%的地图点都可以被至少其他三个关键帧在相同或者更精细的尺度观测到，则该关键帧被剔除。</p>\n<h4 id=\"回环修整\"><a href=\"#回环修整\" class=\"headerlink\" title=\"回环修整\"></a>回环修整</h4><p><strong>回环候选帧检测</strong></p>\n<ol>\n<li>回环候选关键帧产生<br>- 在共视图中计算$K_i$与所邻居的BOW向量相似性，保存最低分数，记作$s_{min}$<br>- 分数低于$s_{min}$的帧不做备选，与当前帧$K_i$直接相连的帧不做备选</li>\n<li>确认回环关键帧</li>\n</ol>\n<p><strong>对于每一个候选回环关键帧$K_j$</strong></p>\n<ol>\n<li>计算其与当前关键帧$K_i$的特征匹配，建立3D-3D点对应</li>\n<li>利用RANSAC方法估计其与当前帧的相似变换$S_{ij}$(7个自由度)</li>\n<li>利用$S_{ij}$搜索两帧之间更多点对应</li>\n<li>基于点对应优化$S_{ij}$直至有足够多内点，则接受当前候选回环关键帧，并记为$K_i$，其相似变换记为$S_{jl}$</li>\n</ol>\n<p><strong>回环融合</strong></p>\n<ol>\n<li>基于相似性矩阵$S_{il}$修正当前帧$K_i$(及其共视帧位姿)</li>\n<li>特征点匹配与地图匹配融合：将回环帧$K_i$及其共视帧可见的地图点投影到当前帧$K_i$及其共视关键帧，寻找匹配并融合</li>\n<li>连接关系更新:融合过程中涉及到的关键帧的边均需要更新，包括回环边</li>\n</ol>\n<ul>\n<li>每条边的误差为:<br>$$<br>e_{ij} &#x3D; \\log(S_{ij}S_{jw}S_{iw}^{-1})<br>$$</li>\n<li>本质图上的总误差为：<br>$$<br>C &#x3D; \\sum_{i,j}{e_{i,j}^T\\Lambda{e_{ij}}}    \\<br>其中，{\\Lambda}_{i,j}为单位矩阵<br>$$</li>\n</ul>\n"},{"title":"基于视图差的深度估计","date":"2024-10-23T10:02:31.000Z","_content":"# 本文方法源于论文《Accurate Multiple View 3D Reconstruction Using Patch-Based Stereo for Large-Scale Scenes》\n\n","source":"_posts/基于视图差的深度估计.md","raw":"---\ntitle: 基于视图差的深度估计\ndate: 2024-10-23 18:02:31\ntags:\n    - 学习笔记\n    - 三维视觉\n    - 深度估计\n    - 论文阅读总结\n---\n# 本文方法源于论文《Accurate Multiple View 3D Reconstruction Using Patch-Based Stereo for Large-Scale Scenes》\n\n","slug":"基于视图差的深度估计","published":1,"updated":"2025-10-16T07:39:39.208Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot300026d6e85549f6q","content":"<h1 id=\"本文方法源于论文《Accurate-Multiple-View-3D-Reconstruction-Using-Patch-Based-Stereo-for-Large-Scale-Scenes》\"><a href=\"#本文方法源于论文《Accurate-Multiple-View-3D-Reconstruction-Using-Patch-Based-Stereo-for-Large-Scale-Scenes》\" class=\"headerlink\" title=\"本文方法源于论文《Accurate Multiple View 3D Reconstruction Using Patch-Based Stereo for Large-Scale Scenes》\"></a>本文方法源于论文《Accurate Multiple View 3D Reconstruction Using Patch-Based Stereo for Large-Scale Scenes》</h1>","excerpt":"","more":"<h1 id=\"本文方法源于论文《Accurate-Multiple-View-3D-Reconstruction-Using-Patch-Based-Stereo-for-Large-Scale-Scenes》\"><a href=\"#本文方法源于论文《Accurate-Multiple-View-3D-Reconstruction-Using-Patch-Based-Stereo-for-Large-Scale-Scenes》\" class=\"headerlink\" title=\"本文方法源于论文《Accurate Multiple View 3D Reconstruction Using Patch-Based Stereo for Large-Scale Scenes》\"></a>本文方法源于论文《Accurate Multiple View 3D Reconstruction Using Patch-Based Stereo for Large-Scale Scenes》</h1>"},{"title":"操作系统(1)","date":"2024-10-18T01:19:47.000Z","_content":"## 概念和功能\n### 操作系统的概念(定义)\n**操作系统**(Operating System, OS)是指控制和管理整个计算机系统的**硬件和软件**资源，并合理的组织调度计算机的工作和资源分配；以**提供给用户和其他软件方便的接口和环境**；它是计算机系统中最基本的系统软件。\n1. 操作系统是系统资源的管理者。\n   执行一个程序前，需要将程序放入内存中，才能被CPU处理，而操作系统会对整个系统中的软硬件调用进行相应的管理。\n2. 向上层提供方便易用的服务。\n   对于硬件，一般只能识别二进制指令，这是一些用户不友好的接口\n   而在硬件之上的操作系统则提供了一系列用户友好的交互接口\n   > 封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便的使用计算机。用户无需关心底层硬件的原理，只需对操作系统发出命令即可。\n3. 是最接近硬件的一层软件。\n   操作系统本身需要实现对硬件机器的扩展。对于一个裸机，一般需要安装操作系统扩展其功能。通常把覆盖率软件的机器成为**扩充机器**，又称之为虚拟机。\n   操作系统对硬件机器进行扩展，将CPU、内存、磁盘、显示器、键盘等合理的组织起来，让彼此能够相互配合，实现更多复杂的功能。\n\n### 操作系统的四个基本特征\n操作系统的基本特征为：并发、共享、虚拟、异步。其中**并发**和**共享**是两个最基本的特征，两者互为存在条件。\n1. 并发：指两个时间在同一时间间隔内发生，这些时间宏观是同时发生额，但是微观上是交替发生的。\n   并行：指两个或多个事件在同一时刻同时发生\n   **操作系统的并发性**指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行的，而微观上看是交替运行的。\n   操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的。\n   - **注意**：\n     - 单核CPU同一时刻只能执行一个程序，各个程序只能并发的执行\n     - 多核CPU同一时刻可以同时执行多个程序，多个程序可以并发地执行\n2. 共享：即资源共享，是指系统中的资源可供多个并发执行的进程共同使用。\n   - 其中存在两种资源共享模式：\n     - 互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源\n     - 系统中的某些资源，允许一个时间段内由多个进程“同时”对他们进行访问。其中的“同时”是宏观意义上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）\n3. 虚拟：指吧一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而在逻辑上对应物（后者）是用户实际感受到的\n    - 空分复用技术（如虚拟存储技术）。\n    - 时分复用技术（如虚拟处理器）。\n    - 显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。\n4. 异步：指在多道程序环境下，允许多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前进，这就是进程的异步性。\n   - 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。**只有系统拥有了并发性，才有可能导致异步性**\n\n### 操作系统的发展与分类\n1. 手工操作阶段。纸带输入输出慢，计算速度相对较快。\n   - 主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低。 \n2. 批处理阶段——单道批处理系统\n   引入**脱机输入/输出技术**（用外危机+磁带完成），并由**监督程序**负责控制作业的输入、输出。\n   - 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。\n   - 主要缺点：**内存中仅能有一道程序运行**，只有该程序运行阶数之后才能调入下一道程序。**CPU有大量时间是在空闲等待I/O完成。**资源利用率依然很低\n3. 批处理阶段——多道批处理系统。每次往内存中读入多道程序。操作系统正式诞生，用于支持多道程序并发运行。\n   - 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。\n   - 主要缺点：用户相应时间长，**没有人机交互功能**（用户提交自己的作业后只能等待计算机处理完成，中间不能控制自己的作业。eg：无法调试程序/无法在程序运行过程中输入一些参数）\n4. 分时操作系统计算机以**时间片**为单位**轮流为各个用户/作业服务**，各个用户可以通过终端与计算机进行交互。\n\n### 操作系统的运行机制\n> “指令”就是处理器（CPU）能识别、执行的最基本的命令\n内核是操作系统最核心的部分，也是最接近硬件的部分。\n\n#### 特权指令和非特权指令\n对于一些操作系统指令，会对操作系统造成很大的影响，其本身应该只能由管理者进行。这种指令被称为“特权指令”。而对于一些普通的应用程序，一般只能进行“非特权指令”。对于CPU，其设计之初就划分了特权指令和非特权指令，因此CPU执行一条语句前就能识别出其类型。\n\n#### 内核态和用户态\nCPU本身有两种状态，内核态和用户态。\n处于**用户态**时，说明此时操作系统执行的是应用程序，只能使用**非特权指令**\n处于**内核态**时，说明此时操作系统执行的是内核程序，可以使用**特权指令**\n> CPU中会存在一个寄存器——**程序状态字寄存器（PSW）**，用于标记当前CPU状态\n> 内核态=核心态=管态；用户态=目态\n**内核态$->$用户态**：执行一条特权指令————修改PSW为“用户态”\n**用户态$->$内核态**：由中断引发，硬件自动完成变化的过程，触发中断信号意味着操作系统将会强制夺回CPU的使用权\n\n### 中断和异常\n#### 中断的类型\n- 内中断（也称“异常”、“例外”）\n  与当前执行的指令**有关**，中断信号来源于CPU**内部**。\n  - 如果当前执行的指令是非法的，则会引发一个中断信号\n  - 当应用程序需要请求操作系统内核服务时，就会执行**陷入指令**，该指令会引发一个内部中断信号\n      > 陷入指令**不是**一条特权指令\n- 外中断（也称“中断”）\n  与当前执行的指令**无关**，中断信号来源于CPU**外部**\n  常见有时钟中断、I/O中断。\n\n#### 中断机制的基本原理\n**不同的中断信号，需要使用不同的中断处理程序来处理。**当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的程序在内存中存放的位置。\n\n### 系统调用\n“系统调用”是提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，**应用程序可以通过系统调用来请求获得操作系统内核的服务**\n凡是与**共享资源**有关的操作，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的**稳定性**和**安全性**，防止用户非法操作。\n注意：\n  1. 陷入指令是在用户态执行的，执行陷入指令之后立刻引发一个内中断，使CPU进入核心态\n  2. 发出系统调用请求是在用户态，而对系统调用的相应处理是在核心态下进行的\n\n### 操作系统体系结构\n#### 大内核和微内核\n- 大内核中，将操作系统的主要功能磨课作为系统内核，运行在核心态。\n  - 优点：高性能\n  - 缺点：内核代码庞大，结构混乱，难以维护\n- 微内核中，只把嘴基本的功能保留在内核\n  - 优点：内核功能少，结构清晰，方便维护\n  - 缺点：需要频繁的在核心态和用户态之间切换，性能低\n\n#### 分层结构 模块化 外核\n##### 分层结构\n- 特性思想：内核分多层，每层可单向调用更低一层提供的接口\n- 优点：\n      1. 便于调试和验证，便于自底向上逐层调试和验证\n      2. 易扩充和易维护，各层之间调用接口清晰固定\n- 缺点：\n      1. 仅可调用相邻低层，难以合理定义各层的边界\n      2. 效率低，不可跨层调用，系统调用执行时间长\n\n##### 模块化\n- 特性思想：\n      1. 将内核划分为多个模块，各个模块之间相互协作。\n      2. 内核 = 主模块 +可加载内核模块\n      3. 主模块：只负责核心功能，如进程调度、内存管理\n      4. 可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核\n- 优点：\n      1. 模块之间逻辑清晰，便于维护，确定模块间的接口后即可多模块同时开发\n      2. 支持动态加载新的内核模块（如安装驱动设备程序、安装新文件系统到内核），增强OS适应性\n      3.  任何模块都可以直接调用其他模块，无需采用消息进行通信，效率高\n- 缺点：\n      1. 模块之间的接口定位未必合理实用\n      2. 模块之间相互依赖，更难调试和验证\n\n##### 外核\n- 特征思想：内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核保证资源使安全\n- 优点：\n      1. 外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以灵活的使用硬件资源。\n      2. 减少了虚拟硬件资源的映射层，提升效率\n- 缺点：\n      1. 降低了系统的一致性\n      2. 使系统变得复杂\n\n### 操作系统的引导\n直接上图\n![操作系统初始化](/img/操作系统(1)/操作系统引导.png) \n\n### 虚拟机\n虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器，每个虚拟机都可以独立运行一个操作系统\n同意术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor\n![虚拟机](/img/操作系统(1)/虚拟机.png)\n\n\n| 区别               | 第一类VMM                                                                                    | 第二类VMM                                                                                                                              |\n| ------------------ | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |\n| 对物理资源的控制权 | 直接运行在硬件之上，能够直接控制和分配物理资源                                               | 运行在Host OS之上，依赖于Host OS 为其分配物理资源                    |\n| 资源分配方式       | 在安装GuestOS时，VMM要在存储上自行分配存储空间，类似于外核的分配方式，分配未经抽象的物理硬件 | Guest OS拥有自己的虚拟硬盘，该盘实际上是 Host OS系统中的一个大文件，Guest OS分配到的内存是虚拟内存                                      |\n| 性能               | 性能更好                                                                                     | 性能更差，需要Host OS作为中介                                                                                                          |\n| 可支持虚拟机数量   | 更多，不需要Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机                              | 更少，Host OS本身需要                                                                                                                  | 使用物理资源，Host OS上运行其他进程也需要物理资源 |\n| 虚拟机的可迁移性   | 更差                                                                                         | 更好，只需导出虚拟机镜像文件即可迁移到另一台Host OS上，商业用途广泛                                                                    |\n| 运行模式           | 第一类VMM运行在最高特权(ring 0)可以自行最高特权指令                                          | 第二类VMM部分运行在用户态，部分运行在用户态，部分运行在内核态。Guest OS 发出的系统调用部分会被VMM截获，并转化为VMM对Host OS 的系统调用 |","source":"_posts/操作系统-1.md","raw":"---\ntitle: 操作系统(1)\ndate: 2024-10-18 09:19:47\ntags:\n    - 学习笔记\n---\n## 概念和功能\n### 操作系统的概念(定义)\n**操作系统**(Operating System, OS)是指控制和管理整个计算机系统的**硬件和软件**资源，并合理的组织调度计算机的工作和资源分配；以**提供给用户和其他软件方便的接口和环境**；它是计算机系统中最基本的系统软件。\n1. 操作系统是系统资源的管理者。\n   执行一个程序前，需要将程序放入内存中，才能被CPU处理，而操作系统会对整个系统中的软硬件调用进行相应的管理。\n2. 向上层提供方便易用的服务。\n   对于硬件，一般只能识别二进制指令，这是一些用户不友好的接口\n   而在硬件之上的操作系统则提供了一系列用户友好的交互接口\n   > 封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便的使用计算机。用户无需关心底层硬件的原理，只需对操作系统发出命令即可。\n3. 是最接近硬件的一层软件。\n   操作系统本身需要实现对硬件机器的扩展。对于一个裸机，一般需要安装操作系统扩展其功能。通常把覆盖率软件的机器成为**扩充机器**，又称之为虚拟机。\n   操作系统对硬件机器进行扩展，将CPU、内存、磁盘、显示器、键盘等合理的组织起来，让彼此能够相互配合，实现更多复杂的功能。\n\n### 操作系统的四个基本特征\n操作系统的基本特征为：并发、共享、虚拟、异步。其中**并发**和**共享**是两个最基本的特征，两者互为存在条件。\n1. 并发：指两个时间在同一时间间隔内发生，这些时间宏观是同时发生额，但是微观上是交替发生的。\n   并行：指两个或多个事件在同一时刻同时发生\n   **操作系统的并发性**指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行的，而微观上看是交替运行的。\n   操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的。\n   - **注意**：\n     - 单核CPU同一时刻只能执行一个程序，各个程序只能并发的执行\n     - 多核CPU同一时刻可以同时执行多个程序，多个程序可以并发地执行\n2. 共享：即资源共享，是指系统中的资源可供多个并发执行的进程共同使用。\n   - 其中存在两种资源共享模式：\n     - 互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源\n     - 系统中的某些资源，允许一个时间段内由多个进程“同时”对他们进行访问。其中的“同时”是宏观意义上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）\n3. 虚拟：指吧一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而在逻辑上对应物（后者）是用户实际感受到的\n    - 空分复用技术（如虚拟存储技术）。\n    - 时分复用技术（如虚拟处理器）。\n    - 显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。\n4. 异步：指在多道程序环境下，允许多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前进，这就是进程的异步性。\n   - 如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。**只有系统拥有了并发性，才有可能导致异步性**\n\n### 操作系统的发展与分类\n1. 手工操作阶段。纸带输入输出慢，计算速度相对较快。\n   - 主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低。 \n2. 批处理阶段——单道批处理系统\n   引入**脱机输入/输出技术**（用外危机+磁带完成），并由**监督程序**负责控制作业的输入、输出。\n   - 主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。\n   - 主要缺点：**内存中仅能有一道程序运行**，只有该程序运行阶数之后才能调入下一道程序。**CPU有大量时间是在空闲等待I/O完成。**资源利用率依然很低\n3. 批处理阶段——多道批处理系统。每次往内存中读入多道程序。操作系统正式诞生，用于支持多道程序并发运行。\n   - 主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。\n   - 主要缺点：用户相应时间长，**没有人机交互功能**（用户提交自己的作业后只能等待计算机处理完成，中间不能控制自己的作业。eg：无法调试程序/无法在程序运行过程中输入一些参数）\n4. 分时操作系统计算机以**时间片**为单位**轮流为各个用户/作业服务**，各个用户可以通过终端与计算机进行交互。\n\n### 操作系统的运行机制\n> “指令”就是处理器（CPU）能识别、执行的最基本的命令\n内核是操作系统最核心的部分，也是最接近硬件的部分。\n\n#### 特权指令和非特权指令\n对于一些操作系统指令，会对操作系统造成很大的影响，其本身应该只能由管理者进行。这种指令被称为“特权指令”。而对于一些普通的应用程序，一般只能进行“非特权指令”。对于CPU，其设计之初就划分了特权指令和非特权指令，因此CPU执行一条语句前就能识别出其类型。\n\n#### 内核态和用户态\nCPU本身有两种状态，内核态和用户态。\n处于**用户态**时，说明此时操作系统执行的是应用程序，只能使用**非特权指令**\n处于**内核态**时，说明此时操作系统执行的是内核程序，可以使用**特权指令**\n> CPU中会存在一个寄存器——**程序状态字寄存器（PSW）**，用于标记当前CPU状态\n> 内核态=核心态=管态；用户态=目态\n**内核态$->$用户态**：执行一条特权指令————修改PSW为“用户态”\n**用户态$->$内核态**：由中断引发，硬件自动完成变化的过程，触发中断信号意味着操作系统将会强制夺回CPU的使用权\n\n### 中断和异常\n#### 中断的类型\n- 内中断（也称“异常”、“例外”）\n  与当前执行的指令**有关**，中断信号来源于CPU**内部**。\n  - 如果当前执行的指令是非法的，则会引发一个中断信号\n  - 当应用程序需要请求操作系统内核服务时，就会执行**陷入指令**，该指令会引发一个内部中断信号\n      > 陷入指令**不是**一条特权指令\n- 外中断（也称“中断”）\n  与当前执行的指令**无关**，中断信号来源于CPU**外部**\n  常见有时钟中断、I/O中断。\n\n#### 中断机制的基本原理\n**不同的中断信号，需要使用不同的中断处理程序来处理。**当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的程序在内存中存放的位置。\n\n### 系统调用\n“系统调用”是提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，**应用程序可以通过系统调用来请求获得操作系统内核的服务**\n凡是与**共享资源**有关的操作，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的**稳定性**和**安全性**，防止用户非法操作。\n注意：\n  1. 陷入指令是在用户态执行的，执行陷入指令之后立刻引发一个内中断，使CPU进入核心态\n  2. 发出系统调用请求是在用户态，而对系统调用的相应处理是在核心态下进行的\n\n### 操作系统体系结构\n#### 大内核和微内核\n- 大内核中，将操作系统的主要功能磨课作为系统内核，运行在核心态。\n  - 优点：高性能\n  - 缺点：内核代码庞大，结构混乱，难以维护\n- 微内核中，只把嘴基本的功能保留在内核\n  - 优点：内核功能少，结构清晰，方便维护\n  - 缺点：需要频繁的在核心态和用户态之间切换，性能低\n\n#### 分层结构 模块化 外核\n##### 分层结构\n- 特性思想：内核分多层，每层可单向调用更低一层提供的接口\n- 优点：\n      1. 便于调试和验证，便于自底向上逐层调试和验证\n      2. 易扩充和易维护，各层之间调用接口清晰固定\n- 缺点：\n      1. 仅可调用相邻低层，难以合理定义各层的边界\n      2. 效率低，不可跨层调用，系统调用执行时间长\n\n##### 模块化\n- 特性思想：\n      1. 将内核划分为多个模块，各个模块之间相互协作。\n      2. 内核 = 主模块 +可加载内核模块\n      3. 主模块：只负责核心功能，如进程调度、内存管理\n      4. 可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核\n- 优点：\n      1. 模块之间逻辑清晰，便于维护，确定模块间的接口后即可多模块同时开发\n      2. 支持动态加载新的内核模块（如安装驱动设备程序、安装新文件系统到内核），增强OS适应性\n      3.  任何模块都可以直接调用其他模块，无需采用消息进行通信，效率高\n- 缺点：\n      1. 模块之间的接口定位未必合理实用\n      2. 模块之间相互依赖，更难调试和验证\n\n##### 外核\n- 特征思想：内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核保证资源使安全\n- 优点：\n      1. 外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以灵活的使用硬件资源。\n      2. 减少了虚拟硬件资源的映射层，提升效率\n- 缺点：\n      1. 降低了系统的一致性\n      2. 使系统变得复杂\n\n### 操作系统的引导\n直接上图\n![操作系统初始化](/img/操作系统(1)/操作系统引导.png) \n\n### 虚拟机\n虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器，每个虚拟机都可以独立运行一个操作系统\n同意术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor\n![虚拟机](/img/操作系统(1)/虚拟机.png)\n\n\n| 区别               | 第一类VMM                                                                                    | 第二类VMM                                                                                                                              |\n| ------------------ | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |\n| 对物理资源的控制权 | 直接运行在硬件之上，能够直接控制和分配物理资源                                               | 运行在Host OS之上，依赖于Host OS 为其分配物理资源                    |\n| 资源分配方式       | 在安装GuestOS时，VMM要在存储上自行分配存储空间，类似于外核的分配方式，分配未经抽象的物理硬件 | Guest OS拥有自己的虚拟硬盘，该盘实际上是 Host OS系统中的一个大文件，Guest OS分配到的内存是虚拟内存                                      |\n| 性能               | 性能更好                                                                                     | 性能更差，需要Host OS作为中介                                                                                                          |\n| 可支持虚拟机数量   | 更多，不需要Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机                              | 更少，Host OS本身需要                                                                                                                  | 使用物理资源，Host OS上运行其他进程也需要物理资源 |\n| 虚拟机的可迁移性   | 更差                                                                                         | 更好，只需导出虚拟机镜像文件即可迁移到另一台Host OS上，商业用途广泛                                                                    |\n| 运行模式           | 第一类VMM运行在最高特权(ring 0)可以自行最高特权指令                                          | 第二类VMM部分运行在用户态，部分运行在用户态，部分运行在内核态。Guest OS 发出的系统调用部分会被VMM截获，并转化为VMM对Host OS 的系统调用 |","slug":"操作系统-1","published":1,"updated":"2024-12-20T04:27:29.409Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot400046d6ec4240eei","content":"<h2 id=\"概念和功能\"><a href=\"#概念和功能\" class=\"headerlink\" title=\"概念和功能\"></a>概念和功能</h2><h3 id=\"操作系统的概念-定义\"><a href=\"#操作系统的概念-定义\" class=\"headerlink\" title=\"操作系统的概念(定义)\"></a>操作系统的概念(定义)</h3><p><strong>操作系统</strong>(Operating System, OS)是指控制和管理整个计算机系统的<strong>硬件和软件</strong>资源，并合理的组织调度计算机的工作和资源分配；以<strong>提供给用户和其他软件方便的接口和环境</strong>；它是计算机系统中最基本的系统软件。</p>\n<ol>\n<li>操作系统是系统资源的管理者。<br>执行一个程序前，需要将程序放入内存中，才能被CPU处理，而操作系统会对整个系统中的软硬件调用进行相应的管理。</li>\n<li>向上层提供方便易用的服务。<br>对于硬件，一般只能识别二进制指令，这是一些用户不友好的接口<br>而在硬件之上的操作系统则提供了一系列用户友好的交互接口<blockquote>\n<p>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便的使用计算机。用户无需关心底层硬件的原理，只需对操作系统发出命令即可。</p>\n</blockquote>\n</li>\n<li>是最接近硬件的一层软件。<br>操作系统本身需要实现对硬件机器的扩展。对于一个裸机，一般需要安装操作系统扩展其功能。通常把覆盖率软件的机器成为<strong>扩充机器</strong>，又称之为虚拟机。<br>操作系统对硬件机器进行扩展，将CPU、内存、磁盘、显示器、键盘等合理的组织起来，让彼此能够相互配合，实现更多复杂的功能。</li>\n</ol>\n<h3 id=\"操作系统的四个基本特征\"><a href=\"#操作系统的四个基本特征\" class=\"headerlink\" title=\"操作系统的四个基本特征\"></a>操作系统的四个基本特征</h3><p>操作系统的基本特征为：并发、共享、虚拟、异步。其中<strong>并发</strong>和<strong>共享</strong>是两个最基本的特征，两者互为存在条件。</p>\n<ol>\n<li>并发：指两个时间在同一时间间隔内发生，这些时间宏观是同时发生额，但是微观上是交替发生的。<br>并行：指两个或多个事件在同一时刻同时发生<br><strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行的，而微观上看是交替运行的。<br>操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的。<ul>\n<li><strong>注意</strong>：<ul>\n<li>单核CPU同一时刻只能执行一个程序，各个程序只能并发的执行</li>\n<li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并发地执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>共享：即资源共享，是指系统中的资源可供多个并发执行的进程共同使用。<ul>\n<li>其中存在两种资源共享模式：<ul>\n<li>互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源</li>\n<li>系统中的某些资源，允许一个时间段内由多个进程“同时”对他们进行访问。其中的“同时”是宏观意义上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>虚拟：指吧一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而在逻辑上对应物（后者）是用户实际感受到的<ul>\n<li>空分复用技术（如虚拟存储技术）。</li>\n<li>时分复用技术（如虚拟处理器）。</li>\n<li>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。</li>\n</ul>\n</li>\n<li>异步：指在多道程序环境下，允许多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前进，这就是进程的异步性。<ul>\n<li>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有了并发性，才有可能导致异步性</strong></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"操作系统的发展与分类\"><a href=\"#操作系统的发展与分类\" class=\"headerlink\" title=\"操作系统的发展与分类\"></a>操作系统的发展与分类</h3><ol>\n<li>手工操作阶段。纸带输入输出慢，计算速度相对较快。<ul>\n<li>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低。</li>\n</ul>\n</li>\n<li>批处理阶段——单道批处理系统<br>引入<strong>脱机输入&#x2F;输出技术</strong>（用外危机+磁带完成），并由<strong>监督程序</strong>负责控制作业的输入、输出。<ul>\n<li>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</li>\n<li>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行阶数之后才能调入下一道程序。<strong>CPU有大量时间是在空闲等待I&#x2F;O完成。</strong>资源利用率依然很低</li>\n</ul>\n</li>\n<li>批处理阶段——多道批处理系统。每次往内存中读入多道程序。操作系统正式诞生，用于支持多道程序并发运行。<ul>\n<li>主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。</li>\n<li>主要缺点：用户相应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业后只能等待计算机处理完成，中间不能控制自己的作业。eg：无法调试程序&#x2F;无法在程序运行过程中输入一些参数）</li>\n</ul>\n</li>\n<li>分时操作系统计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户&#x2F;作业服务</strong>，各个用户可以通过终端与计算机进行交互。</li>\n</ol>\n<h3 id=\"操作系统的运行机制\"><a href=\"#操作系统的运行机制\" class=\"headerlink\" title=\"操作系统的运行机制\"></a>操作系统的运行机制</h3><blockquote>\n<p>“指令”就是处理器（CPU）能识别、执行的最基本的命令<br>内核是操作系统最核心的部分，也是最接近硬件的部分。</p>\n</blockquote>\n<h4 id=\"特权指令和非特权指令\"><a href=\"#特权指令和非特权指令\" class=\"headerlink\" title=\"特权指令和非特权指令\"></a>特权指令和非特权指令</h4><p>对于一些操作系统指令，会对操作系统造成很大的影响，其本身应该只能由管理者进行。这种指令被称为“特权指令”。而对于一些普通的应用程序，一般只能进行“非特权指令”。对于CPU，其设计之初就划分了特权指令和非特权指令，因此CPU执行一条语句前就能识别出其类型。</p>\n<h4 id=\"内核态和用户态\"><a href=\"#内核态和用户态\" class=\"headerlink\" title=\"内核态和用户态\"></a>内核态和用户态</h4><p>CPU本身有两种状态，内核态和用户态。<br>处于<strong>用户态</strong>时，说明此时操作系统执行的是应用程序，只能使用<strong>非特权指令</strong><br>处于<strong>内核态</strong>时，说明此时操作系统执行的是内核程序，可以使用<strong>特权指令</strong></p>\n<blockquote>\n<p>CPU中会存在一个寄存器——<strong>程序状态字寄存器（PSW）</strong>，用于标记当前CPU状态<br>内核态&#x3D;核心态&#x3D;管态；用户态&#x3D;目态<br><strong>内核态$-&gt;$用户态</strong>：执行一条特权指令————修改PSW为“用户态”<br><strong>用户态$-&gt;$内核态</strong>：由中断引发，硬件自动完成变化的过程，触发中断信号意味着操作系统将会强制夺回CPU的使用权</p>\n</blockquote>\n<h3 id=\"中断和异常\"><a href=\"#中断和异常\" class=\"headerlink\" title=\"中断和异常\"></a>中断和异常</h3><h4 id=\"中断的类型\"><a href=\"#中断的类型\" class=\"headerlink\" title=\"中断的类型\"></a>中断的类型</h4><ul>\n<li>内中断（也称“异常”、“例外”）<br>与当前执行的指令<strong>有关</strong>，中断信号来源于CPU<strong>内部</strong>。<ul>\n<li>如果当前执行的指令是非法的，则会引发一个中断信号</li>\n<li>当应用程序需要请求操作系统内核服务时，就会执行<strong>陷入指令</strong>，该指令会引发一个内部中断信号<blockquote>\n<p>陷入指令<strong>不是</strong>一条特权指令</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>外中断（也称“中断”）<br>与当前执行的指令<strong>无关</strong>，中断信号来源于CPU<strong>外部</strong><br>常见有时钟中断、I&#x2F;O中断。</li>\n</ul>\n<h4 id=\"中断机制的基本原理\"><a href=\"#中断机制的基本原理\" class=\"headerlink\" title=\"中断机制的基本原理\"></a>中断机制的基本原理</h4><p><strong>不同的中断信号，需要使用不同的中断处理程序来处理。</strong>当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的程序在内存中存放的位置。</p>\n<h3 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h3><p>“系统调用”是提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong><br>凡是与<strong>共享资源</strong>有关的操作，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的<strong>稳定性</strong>和<strong>安全性</strong>，防止用户非法操作。<br>注意：</p>\n<ol>\n<li>陷入指令是在用户态执行的，执行陷入指令之后立刻引发一个内中断，使CPU进入核心态</li>\n<li>发出系统调用请求是在用户态，而对系统调用的相应处理是在核心态下进行的</li>\n</ol>\n<h3 id=\"操作系统体系结构\"><a href=\"#操作系统体系结构\" class=\"headerlink\" title=\"操作系统体系结构\"></a>操作系统体系结构</h3><h4 id=\"大内核和微内核\"><a href=\"#大内核和微内核\" class=\"headerlink\" title=\"大内核和微内核\"></a>大内核和微内核</h4><ul>\n<li>大内核中，将操作系统的主要功能磨课作为系统内核，运行在核心态。<ul>\n<li>优点：高性能</li>\n<li>缺点：内核代码庞大，结构混乱，难以维护</li>\n</ul>\n</li>\n<li>微内核中，只把嘴基本的功能保留在内核<ul>\n<li>优点：内核功能少，结构清晰，方便维护</li>\n<li>缺点：需要频繁的在核心态和用户态之间切换，性能低</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分层结构-模块化-外核\"><a href=\"#分层结构-模块化-外核\" class=\"headerlink\" title=\"分层结构 模块化 外核\"></a>分层结构 模块化 外核</h4><h5 id=\"分层结构\"><a href=\"#分层结构\" class=\"headerlink\" title=\"分层结构\"></a>分层结构</h5><ul>\n<li>特性思想：内核分多层，每层可单向调用更低一层提供的接口</li>\n<li>优点：<br>1. 便于调试和验证，便于自底向上逐层调试和验证<br>2. 易扩充和易维护，各层之间调用接口清晰固定</li>\n<li>缺点：<br>1. 仅可调用相邻低层，难以合理定义各层的边界<br>2. 效率低，不可跨层调用，系统调用执行时间长</li>\n</ul>\n<h5 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h5><ul>\n<li>特性思想：<br>1. 将内核划分为多个模块，各个模块之间相互协作。<br>2. 内核 &#x3D; 主模块 +可加载内核模块<br>3. 主模块：只负责核心功能，如进程调度、内存管理<br>4. 可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核</li>\n<li>优点：<br>1. 模块之间逻辑清晰，便于维护，确定模块间的接口后即可多模块同时开发<br>2. 支持动态加载新的内核模块（如安装驱动设备程序、安装新文件系统到内核），增强OS适应性<br>3.  任何模块都可以直接调用其他模块，无需采用消息进行通信，效率高</li>\n<li>缺点：<br>1. 模块之间的接口定位未必合理实用<br>2. 模块之间相互依赖，更难调试和验证</li>\n</ul>\n<h5 id=\"外核\"><a href=\"#外核\" class=\"headerlink\" title=\"外核\"></a>外核</h5><ul>\n<li>特征思想：内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核保证资源使安全</li>\n<li>优点：<br>1. 外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以灵活的使用硬件资源。<br>2. 减少了虚拟硬件资源的映射层，提升效率</li>\n<li>缺点：<br>1. 降低了系统的一致性<br>2. 使系统变得复杂</li>\n</ul>\n<h3 id=\"操作系统的引导\"><a href=\"#操作系统的引导\" class=\"headerlink\" title=\"操作系统的引导\"></a>操作系统的引导</h3><p>直接上图<br><img src=\"/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC.png\" alt=\"操作系统初始化\"> </p>\n<h3 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h3><p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器，每个虚拟机都可以独立运行一个操作系统<br>同意术语：虚拟机管理程序&#x2F;虚拟机监控程序&#x2F;Virtual Machine Monitor&#x2F;Hypervisor<br><img src=\"/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)/%E8%99%9A%E6%8B%9F%E6%9C%BA.png\" alt=\"虚拟机\"></p>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>第一类VMM</th>\n<th>第二类VMM</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>对物理资源的控制权</td>\n<td>直接运行在硬件之上，能够直接控制和分配物理资源</td>\n<td>运行在Host OS之上，依赖于Host OS 为其分配物理资源</td>\n</tr>\n<tr>\n<td>资源分配方式</td>\n<td>在安装GuestOS时，VMM要在存储上自行分配存储空间，类似于外核的分配方式，分配未经抽象的物理硬件</td>\n<td>Guest OS拥有自己的虚拟硬盘，该盘实际上是 Host OS系统中的一个大文件，Guest OS分配到的内存是虚拟内存</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>性能更好</td>\n<td>性能更差，需要Host OS作为中介</td>\n</tr>\n<tr>\n<td>可支持虚拟机数量</td>\n<td>更多，不需要Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机</td>\n<td>更少，Host OS本身需要</td>\n</tr>\n<tr>\n<td>虚拟机的可迁移性</td>\n<td>更差</td>\n<td>更好，只需导出虚拟机镜像文件即可迁移到另一台Host OS上，商业用途广泛</td>\n</tr>\n<tr>\n<td>运行模式</td>\n<td>第一类VMM运行在最高特权(ring 0)可以自行最高特权指令</td>\n<td>第二类VMM部分运行在用户态，部分运行在用户态，部分运行在内核态。Guest OS 发出的系统调用部分会被VMM截获，并转化为VMM对Host OS 的系统调用</td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<h2 id=\"概念和功能\"><a href=\"#概念和功能\" class=\"headerlink\" title=\"概念和功能\"></a>概念和功能</h2><h3 id=\"操作系统的概念-定义\"><a href=\"#操作系统的概念-定义\" class=\"headerlink\" title=\"操作系统的概念(定义)\"></a>操作系统的概念(定义)</h3><p><strong>操作系统</strong>(Operating System, OS)是指控制和管理整个计算机系统的<strong>硬件和软件</strong>资源，并合理的组织调度计算机的工作和资源分配；以<strong>提供给用户和其他软件方便的接口和环境</strong>；它是计算机系统中最基本的系统软件。</p>\n<ol>\n<li>操作系统是系统资源的管理者。<br>执行一个程序前，需要将程序放入内存中，才能被CPU处理，而操作系统会对整个系统中的软硬件调用进行相应的管理。</li>\n<li>向上层提供方便易用的服务。<br>对于硬件，一般只能识别二进制指令，这是一些用户不友好的接口<br>而在硬件之上的操作系统则提供了一系列用户友好的交互接口<blockquote>\n<p>封装思想：操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便的使用计算机。用户无需关心底层硬件的原理，只需对操作系统发出命令即可。</p>\n</blockquote>\n</li>\n<li>是最接近硬件的一层软件。<br>操作系统本身需要实现对硬件机器的扩展。对于一个裸机，一般需要安装操作系统扩展其功能。通常把覆盖率软件的机器成为<strong>扩充机器</strong>，又称之为虚拟机。<br>操作系统对硬件机器进行扩展，将CPU、内存、磁盘、显示器、键盘等合理的组织起来，让彼此能够相互配合，实现更多复杂的功能。</li>\n</ol>\n<h3 id=\"操作系统的四个基本特征\"><a href=\"#操作系统的四个基本特征\" class=\"headerlink\" title=\"操作系统的四个基本特征\"></a>操作系统的四个基本特征</h3><p>操作系统的基本特征为：并发、共享、虚拟、异步。其中<strong>并发</strong>和<strong>共享</strong>是两个最基本的特征，两者互为存在条件。</p>\n<ol>\n<li>并发：指两个时间在同一时间间隔内发生，这些时间宏观是同时发生额，但是微观上是交替发生的。<br>并行：指两个或多个事件在同一时刻同时发生<br><strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行的，而微观上看是交替运行的。<br>操作系统就是伴随着“多道程序技术”而出现的，因此，操作系统和程序并发是一起诞生的。<ul>\n<li><strong>注意</strong>：<ul>\n<li>单核CPU同一时刻只能执行一个程序，各个程序只能并发的执行</li>\n<li>多核CPU同一时刻可以同时执行多个程序，多个程序可以并发地执行</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>共享：即资源共享，是指系统中的资源可供多个并发执行的进程共同使用。<ul>\n<li>其中存在两种资源共享模式：<ul>\n<li>互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但是一个时间段内只允许一个进程访问该资源</li>\n<li>系统中的某些资源，允许一个时间段内由多个进程“同时”对他们进行访问。其中的“同时”是宏观意义上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>虚拟：指吧一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而在逻辑上对应物（后者）是用户实际感受到的<ul>\n<li>空分复用技术（如虚拟存储技术）。</li>\n<li>时分复用技术（如虚拟处理器）。</li>\n<li>显然，如果失去了并发性，则一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了。因此，没有并发性，就谈不上虚拟性。</li>\n</ul>\n</li>\n<li>异步：指在多道程序环境下，允许多个程序并发执行，但是由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前进，这就是进程的异步性。<ul>\n<li>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有了并发性，才有可能导致异步性</strong></li>\n</ul>\n</li>\n</ol>\n<h3 id=\"操作系统的发展与分类\"><a href=\"#操作系统的发展与分类\" class=\"headerlink\" title=\"操作系统的发展与分类\"></a>操作系统的发展与分类</h3><ol>\n<li>手工操作阶段。纸带输入输出慢，计算速度相对较快。<ul>\n<li>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低。</li>\n</ul>\n</li>\n<li>批处理阶段——单道批处理系统<br>引入<strong>脱机输入&#x2F;输出技术</strong>（用外危机+磁带完成），并由<strong>监督程序</strong>负责控制作业的输入、输出。<ul>\n<li>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</li>\n<li>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行阶数之后才能调入下一道程序。<strong>CPU有大量时间是在空闲等待I&#x2F;O完成。</strong>资源利用率依然很低</li>\n</ul>\n</li>\n<li>批处理阶段——多道批处理系统。每次往内存中读入多道程序。操作系统正式诞生，用于支持多道程序并发运行。<ul>\n<li>主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。</li>\n<li>主要缺点：用户相应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业后只能等待计算机处理完成，中间不能控制自己的作业。eg：无法调试程序&#x2F;无法在程序运行过程中输入一些参数）</li>\n</ul>\n</li>\n<li>分时操作系统计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户&#x2F;作业服务</strong>，各个用户可以通过终端与计算机进行交互。</li>\n</ol>\n<h3 id=\"操作系统的运行机制\"><a href=\"#操作系统的运行机制\" class=\"headerlink\" title=\"操作系统的运行机制\"></a>操作系统的运行机制</h3><blockquote>\n<p>“指令”就是处理器（CPU）能识别、执行的最基本的命令<br>内核是操作系统最核心的部分，也是最接近硬件的部分。</p>\n</blockquote>\n<h4 id=\"特权指令和非特权指令\"><a href=\"#特权指令和非特权指令\" class=\"headerlink\" title=\"特权指令和非特权指令\"></a>特权指令和非特权指令</h4><p>对于一些操作系统指令，会对操作系统造成很大的影响，其本身应该只能由管理者进行。这种指令被称为“特权指令”。而对于一些普通的应用程序，一般只能进行“非特权指令”。对于CPU，其设计之初就划分了特权指令和非特权指令，因此CPU执行一条语句前就能识别出其类型。</p>\n<h4 id=\"内核态和用户态\"><a href=\"#内核态和用户态\" class=\"headerlink\" title=\"内核态和用户态\"></a>内核态和用户态</h4><p>CPU本身有两种状态，内核态和用户态。<br>处于<strong>用户态</strong>时，说明此时操作系统执行的是应用程序，只能使用<strong>非特权指令</strong><br>处于<strong>内核态</strong>时，说明此时操作系统执行的是内核程序，可以使用<strong>特权指令</strong></p>\n<blockquote>\n<p>CPU中会存在一个寄存器——<strong>程序状态字寄存器（PSW）</strong>，用于标记当前CPU状态<br>内核态&#x3D;核心态&#x3D;管态；用户态&#x3D;目态<br><strong>内核态$-&gt;$用户态</strong>：执行一条特权指令————修改PSW为“用户态”<br><strong>用户态$-&gt;$内核态</strong>：由中断引发，硬件自动完成变化的过程，触发中断信号意味着操作系统将会强制夺回CPU的使用权</p>\n</blockquote>\n<h3 id=\"中断和异常\"><a href=\"#中断和异常\" class=\"headerlink\" title=\"中断和异常\"></a>中断和异常</h3><h4 id=\"中断的类型\"><a href=\"#中断的类型\" class=\"headerlink\" title=\"中断的类型\"></a>中断的类型</h4><ul>\n<li>内中断（也称“异常”、“例外”）<br>与当前执行的指令<strong>有关</strong>，中断信号来源于CPU<strong>内部</strong>。<ul>\n<li>如果当前执行的指令是非法的，则会引发一个中断信号</li>\n<li>当应用程序需要请求操作系统内核服务时，就会执行<strong>陷入指令</strong>，该指令会引发一个内部中断信号<blockquote>\n<p>陷入指令<strong>不是</strong>一条特权指令</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>外中断（也称“中断”）<br>与当前执行的指令<strong>无关</strong>，中断信号来源于CPU<strong>外部</strong><br>常见有时钟中断、I&#x2F;O中断。</li>\n</ul>\n<h4 id=\"中断机制的基本原理\"><a href=\"#中断机制的基本原理\" class=\"headerlink\" title=\"中断机制的基本原理\"></a>中断机制的基本原理</h4><p><strong>不同的中断信号，需要使用不同的中断处理程序来处理。</strong>当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的程序在内存中存放的位置。</p>\n<h3 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h3><p>“系统调用”是提供给应用程序使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong><br>凡是与<strong>共享资源</strong>有关的操作，都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的<strong>稳定性</strong>和<strong>安全性</strong>，防止用户非法操作。<br>注意：</p>\n<ol>\n<li>陷入指令是在用户态执行的，执行陷入指令之后立刻引发一个内中断，使CPU进入核心态</li>\n<li>发出系统调用请求是在用户态，而对系统调用的相应处理是在核心态下进行的</li>\n</ol>\n<h3 id=\"操作系统体系结构\"><a href=\"#操作系统体系结构\" class=\"headerlink\" title=\"操作系统体系结构\"></a>操作系统体系结构</h3><h4 id=\"大内核和微内核\"><a href=\"#大内核和微内核\" class=\"headerlink\" title=\"大内核和微内核\"></a>大内核和微内核</h4><ul>\n<li>大内核中，将操作系统的主要功能磨课作为系统内核，运行在核心态。<ul>\n<li>优点：高性能</li>\n<li>缺点：内核代码庞大，结构混乱，难以维护</li>\n</ul>\n</li>\n<li>微内核中，只把嘴基本的功能保留在内核<ul>\n<li>优点：内核功能少，结构清晰，方便维护</li>\n<li>缺点：需要频繁的在核心态和用户态之间切换，性能低</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分层结构-模块化-外核\"><a href=\"#分层结构-模块化-外核\" class=\"headerlink\" title=\"分层结构 模块化 外核\"></a>分层结构 模块化 外核</h4><h5 id=\"分层结构\"><a href=\"#分层结构\" class=\"headerlink\" title=\"分层结构\"></a>分层结构</h5><ul>\n<li>特性思想：内核分多层，每层可单向调用更低一层提供的接口</li>\n<li>优点：<br>1. 便于调试和验证，便于自底向上逐层调试和验证<br>2. 易扩充和易维护，各层之间调用接口清晰固定</li>\n<li>缺点：<br>1. 仅可调用相邻低层，难以合理定义各层的边界<br>2. 效率低，不可跨层调用，系统调用执行时间长</li>\n</ul>\n<h5 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h5><ul>\n<li>特性思想：<br>1. 将内核划分为多个模块，各个模块之间相互协作。<br>2. 内核 &#x3D; 主模块 +可加载内核模块<br>3. 主模块：只负责核心功能，如进程调度、内存管理<br>4. 可加载内核模块：可以动态加载新模块到内核，而无需重新编译整个内核</li>\n<li>优点：<br>1. 模块之间逻辑清晰，便于维护，确定模块间的接口后即可多模块同时开发<br>2. 支持动态加载新的内核模块（如安装驱动设备程序、安装新文件系统到内核），增强OS适应性<br>3.  任何模块都可以直接调用其他模块，无需采用消息进行通信，效率高</li>\n<li>缺点：<br>1. 模块之间的接口定位未必合理实用<br>2. 模块之间相互依赖，更难调试和验证</li>\n</ul>\n<h5 id=\"外核\"><a href=\"#外核\" class=\"headerlink\" title=\"外核\"></a>外核</h5><ul>\n<li>特征思想：内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核保证资源使安全</li>\n<li>优点：<br>1. 外核可直接给用户进程分配“不虚拟、不抽象”的硬件资源，使用户进程可以灵活的使用硬件资源。<br>2. 减少了虚拟硬件资源的映射层，提升效率</li>\n<li>缺点：<br>1. 降低了系统的一致性<br>2. 使系统变得复杂</li>\n</ul>\n<h3 id=\"操作系统的引导\"><a href=\"#操作系统的引导\" class=\"headerlink\" title=\"操作系统的引导\"></a>操作系统的引导</h3><p>直接上图<br><img src=\"/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC.png\" alt=\"操作系统初始化\"> </p>\n<h3 id=\"虚拟机\"><a href=\"#虚拟机\" class=\"headerlink\" title=\"虚拟机\"></a>虚拟机</h3><p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器，每个虚拟机都可以独立运行一个操作系统<br>同意术语：虚拟机管理程序&#x2F;虚拟机监控程序&#x2F;Virtual Machine Monitor&#x2F;Hypervisor<br><img src=\"/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(1)/%E8%99%9A%E6%8B%9F%E6%9C%BA.png\" alt=\"虚拟机\"></p>\n<table>\n<thead>\n<tr>\n<th>区别</th>\n<th>第一类VMM</th>\n<th>第二类VMM</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>对物理资源的控制权</td>\n<td>直接运行在硬件之上，能够直接控制和分配物理资源</td>\n<td>运行在Host OS之上，依赖于Host OS 为其分配物理资源</td>\n</tr>\n<tr>\n<td>资源分配方式</td>\n<td>在安装GuestOS时，VMM要在存储上自行分配存储空间，类似于外核的分配方式，分配未经抽象的物理硬件</td>\n<td>Guest OS拥有自己的虚拟硬盘，该盘实际上是 Host OS系统中的一个大文件，Guest OS分配到的内存是虚拟内存</td>\n</tr>\n<tr>\n<td>性能</td>\n<td>性能更好</td>\n<td>性能更差，需要Host OS作为中介</td>\n</tr>\n<tr>\n<td>可支持虚拟机数量</td>\n<td>更多，不需要Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机</td>\n<td>更少，Host OS本身需要</td>\n</tr>\n<tr>\n<td>虚拟机的可迁移性</td>\n<td>更差</td>\n<td>更好，只需导出虚拟机镜像文件即可迁移到另一台Host OS上，商业用途广泛</td>\n</tr>\n<tr>\n<td>运行模式</td>\n<td>第一类VMM运行在最高特权(ring 0)可以自行最高特权指令</td>\n<td>第二类VMM部分运行在用户态，部分运行在用户态，部分运行在内核态。Guest OS 发出的系统调用部分会被VMM截获，并转化为VMM对Host OS 的系统调用</td>\n</tr>\n</tbody></table>\n"},{"title":"操作系统(2)","date":"2024-10-24T14:38:00.000Z","_content":"## 进程\n### 进程的概念、组成和特征\n- 概念\n  - 程序：静态的，就是个存放 在磁盘中的可执行文件，就是一些列的指令集合\n  - 进程：动态的，是程序的一次执行过程\n\n- 组成——（PCB）\n  - 当进程被创造时，操作系统会为该进程分配一个唯一的、不重复的**PID**，用以标识进程名称\n  - 相对应也会创造用户标识符**UID**\n  - 同时还会记录分配资源的占用情况（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）。这些信息的记录**可以帮助实现操作系统对于整个资源的管理工作**\n  - 记录进程的运行情况。**可用于操作系统实现对于进程的控制和调度**\n这些信息统一被放在一个数据结构PCB（Process Control Block）中，即**进程控制块**\n操作系统需要对各个并发运行的进程进行管理，**但凡管理时所需要的信息，都会被放在PCB中**。\n![PCB](/img/操作系统(2)/PCB.png)    \n\n一个**进程实体（进程映像）**由**PCB、程序段、数据段**组成。**进程**是**动态**的，**进程实体（进程映像）**是**静态**的。\n![进程的组成](/img/操作系统(2)/进程的组成.png)\n\n#### 进程的特征\n相对于程序，进程具有以下特征\n![进程的特征](/img/操作系统(2)/进程的特征.png)\n\n### 进程的状态与转换、进程的组织\n","source":"_posts/操作系统-2.md","raw":"---\ntitle: 操作系统(2)\ndate: 2024-10-24 22:38:00\ntags:\n    - 学习笔记\n---\n## 进程\n### 进程的概念、组成和特征\n- 概念\n  - 程序：静态的，就是个存放 在磁盘中的可执行文件，就是一些列的指令集合\n  - 进程：动态的，是程序的一次执行过程\n\n- 组成——（PCB）\n  - 当进程被创造时，操作系统会为该进程分配一个唯一的、不重复的**PID**，用以标识进程名称\n  - 相对应也会创造用户标识符**UID**\n  - 同时还会记录分配资源的占用情况（如：分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件）。这些信息的记录**可以帮助实现操作系统对于整个资源的管理工作**\n  - 记录进程的运行情况。**可用于操作系统实现对于进程的控制和调度**\n这些信息统一被放在一个数据结构PCB（Process Control Block）中，即**进程控制块**\n操作系统需要对各个并发运行的进程进行管理，**但凡管理时所需要的信息，都会被放在PCB中**。\n![PCB](/img/操作系统(2)/PCB.png)    \n\n一个**进程实体（进程映像）**由**PCB、程序段、数据段**组成。**进程**是**动态**的，**进程实体（进程映像）**是**静态**的。\n![进程的组成](/img/操作系统(2)/进程的组成.png)\n\n#### 进程的特征\n相对于程序，进程具有以下特征\n![进程的特征](/img/操作系统(2)/进程的特征.png)\n\n### 进程的状态与转换、进程的组织\n","slug":"操作系统-2","published":1,"updated":"2024-12-20T04:27:29.409Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot500056d6ehmk29vfk","content":"<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><h3 id=\"进程的概念、组成和特征\"><a href=\"#进程的概念、组成和特征\" class=\"headerlink\" title=\"进程的概念、组成和特征\"></a>进程的概念、组成和特征</h3><ul>\n<li><p>概念</p>\n<ul>\n<li>程序：静态的，就是个存放 在磁盘中的可执行文件，就是一些列的指令集合</li>\n<li>进程：动态的，是程序的一次执行过程</li>\n</ul>\n</li>\n<li><p>组成——（PCB）</p>\n<ul>\n<li>当进程被创造时，操作系统会为该进程分配一个唯一的、不重复的<strong>PID</strong>，用以标识进程名称</li>\n<li>相对应也会创造用户标识符<strong>UID</strong></li>\n<li>同时还会记录分配资源的占用情况（如：分配了多少内存、正在使用哪些I&#x2F;O设备、正在使用哪些文件）。这些信息的记录<strong>可以帮助实现操作系统对于整个资源的管理工作</strong></li>\n<li>记录进程的运行情况。<strong>可用于操作系统实现对于进程的控制和调度</strong><br>这些信息统一被放在一个数据结构PCB（Process Control Block）中，即<strong>进程控制块</strong><br>操作系统需要对各个并发运行的进程进行管理，<strong>但凡管理时所需要的信息，都会被放在PCB中</strong>。<br><img src=\"/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)/PCB.png\" alt=\"PCB\"></li>\n</ul>\n</li>\n</ul>\n<p>一个<strong>进程实体（进程映像）</strong>由<strong>PCB、程序段、数据段</strong>组成。<strong>进程</strong>是<strong>动态</strong>的，<strong>进程实体（进程映像）</strong>是<strong>静态</strong>的。<br><img src=\"/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90.png\" alt=\"进程的组成\"></p>\n<h4 id=\"进程的特征\"><a href=\"#进程的特征\" class=\"headerlink\" title=\"进程的特征\"></a>进程的特征</h4><p>相对于程序，进程具有以下特征<br><img src=\"/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81.png\" alt=\"进程的特征\"></p>\n<h3 id=\"进程的状态与转换、进程的组织\"><a href=\"#进程的状态与转换、进程的组织\" class=\"headerlink\" title=\"进程的状态与转换、进程的组织\"></a>进程的状态与转换、进程的组织</h3>","excerpt":"","more":"<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><h3 id=\"进程的概念、组成和特征\"><a href=\"#进程的概念、组成和特征\" class=\"headerlink\" title=\"进程的概念、组成和特征\"></a>进程的概念、组成和特征</h3><ul>\n<li><p>概念</p>\n<ul>\n<li>程序：静态的，就是个存放 在磁盘中的可执行文件，就是一些列的指令集合</li>\n<li>进程：动态的，是程序的一次执行过程</li>\n</ul>\n</li>\n<li><p>组成——（PCB）</p>\n<ul>\n<li>当进程被创造时，操作系统会为该进程分配一个唯一的、不重复的<strong>PID</strong>，用以标识进程名称</li>\n<li>相对应也会创造用户标识符<strong>UID</strong></li>\n<li>同时还会记录分配资源的占用情况（如：分配了多少内存、正在使用哪些I&#x2F;O设备、正在使用哪些文件）。这些信息的记录<strong>可以帮助实现操作系统对于整个资源的管理工作</strong></li>\n<li>记录进程的运行情况。<strong>可用于操作系统实现对于进程的控制和调度</strong><br>这些信息统一被放在一个数据结构PCB（Process Control Block）中，即<strong>进程控制块</strong><br>操作系统需要对各个并发运行的进程进行管理，<strong>但凡管理时所需要的信息，都会被放在PCB中</strong>。<br><img src=\"/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)/PCB.png\" alt=\"PCB\"></li>\n</ul>\n</li>\n</ul>\n<p>一个<strong>进程实体（进程映像）</strong>由<strong>PCB、程序段、数据段</strong>组成。<strong>进程</strong>是<strong>动态</strong>的，<strong>进程实体（进程映像）</strong>是<strong>静态</strong>的。<br><img src=\"/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90.png\" alt=\"进程的组成\"></p>\n<h4 id=\"进程的特征\"><a href=\"#进程的特征\" class=\"headerlink\" title=\"进程的特征\"></a>进程的特征</h4><p>相对于程序，进程具有以下特征<br><img src=\"/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(2)/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%89%B9%E5%BE%81.png\" alt=\"进程的特征\"></p>\n<h3 id=\"进程的状态与转换、进程的组织\"><a href=\"#进程的状态与转换、进程的组织\" class=\"headerlink\" title=\"进程的状态与转换、进程的组织\"></a>进程的状态与转换、进程的组织</h3>"},{"title":"数据库(1)","date":"2024-10-01T03:39:56.000Z","_content":"### 数据库的相关概念\n | 名称           | 全称                                                           | 简介                             |\n | -------------- | -------------------------------------------------------------- | -------------------------------- |\n | 数据库         | 存储数据的仓库，数据是有组织的进行存储                         | DataBase(DB)                     |\n | 数据库管理系统 | 操纵和管理数据库的大型软件                                     | DataBase Management System(DBMS) |\n | SQL            | 操作关系数据库的变成语言，定义了一套操作关系数据库统一**标准** | Structured Query Language        |\n\n MySQL的启用与停止\n```bash\nnet start mysql80\nnet stop mysql80\n```\n\n### 数据模型\n- 关系型数据库(RDBMS) \n  - 概念：建立在关系模型的基础上，由多张相互连接的二维表组成的数据库。\n  - 特点：\n    1. 使用表格存储数据，格式统一，便于维护。\n    2. 使用SQL语言操作，标准统一，使用方便。\n- 数据模型\n  - MySQL客户端通过给服务器发送操作信息，来对数据库进行操作\n  - 在SQL服务器内部，DBMS对数据库进行创建、删除、操作等步骤。\n  - 一个数据库中可以包含多个表结构，表结构才是真正存储数据的部分\n\n### MySQL操作简介\n#### SQL通用语法\n1. SQL语句可以单行或多行书写，以分号结尾。\n2. SQL语句可以使用空格/缩进来增强语句的可读性\n3. MySQL数据库的SQL语句不区分大小写，但是一般将关键字大写。\n4. 注释：\n    - 单行注释：-- &nbsp; *注释内容*&nbsp; 或 # &nbsp; 注释内容\n    - 多行注释：/* &nbsp; 注释内容 &nbsp; */\n\n#### SQL语句分类\n| 分类 | 全称                       | 说明                                                   |\n| ---- | -------------------------- | ------------------------------------------------------ |\n| DDL  | Data Definition Language   | 数据定义语言，用来定义数据库对象(数据库，表，字段)     |\n| DML  | Data Manipulation Language | 数据操作语言，用来对数据库中表的数据进行增删改         |\n| DQL  | Data Query Language        | 数据查询语言，用来查询数据库中表的记录                 |\n| DCL  | Data  Control Language     | 数据控制语言，用来创建数据库用户、控制数据库的访问权限 |\n\n#### DDL语句\n##### 数据库操作\n- 查询\n  - 查询所有数据库\n    ``` SHOW DATABASES; ```   \n  - 查询当前数据库\n    ``` SELECT DATABASE(); ```\n- 创建\n  ``` CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则] ```\n- 删除\n  ``` DROP DATABASE [IF EXISTS] 数据库名; ```\n- 使用\n  ``` USE 数据库名; ```\n\n##### 表操作\n- 创建表\n\n  ```SQL\n  CREATE TABLE 表名(\n    属性   数据类型,\n    ......\n  )\n  ```\n\n- 查询当前数据库所有表\n  ``` SHOW TABLES ```\n- 查询表结构\n  ``` DESC 表名 ```\n- 查询指定表的建表语句\n  ``` SHOW CREATE TABLE 表名 ```\n##### 表结构的数据类型 \n| 分类     | 类型      | 大小    | 有符号(SIGNED)范围                          | 无符号(UNSIGNED)范围      | 描述         |\n| -------- | --------- | ------- | ------------------------------------------- | ------------------------- | ------------ |\n| 数值类型 | TINYINT   | 1 byte  | (-128, 127)                                 | (0, 255)                  | 小整数值     |\n| 数值类型 | SMALLINT  | 2 bytes | (-32768, 32767)                             | (0, 65535)                | 较小整数值   |\n| 数值类型 | MEDIUMINT | 3 bytes | (-8388608, 8388607)                         | (0, 16777215)             | 中等整数值   |\n| 数值类型 | INT       | 4 bytes | (-2147483648, 2147483647)                   | (0, 4294967295)           | 标准整数值   |\n| 数值类型 | BIGINT    | 8 bytes | (-9223372036854775808, 9223372036854775807) | (0, 18446744073709551615) | 大整数值     |\n| 数值类型 | FLOAT     | 4 bytes | 单精度浮点数范围                            | 单精度浮点数范围          | 单精度浮点数 |\n| 数值类型 | DOUBLE    | 8 bytes | 双精度浮点数范围                            | 双精度浮点数范围          | 双精度浮点数 |\n| 数值类型 | DECIMAL   | 可变    | 依定义的精度和标度确定                      | 依定义的精度和标度确定    | 定点数       |\n\n除此之外，MySQL还有相应的时间数据类型\n| 分类         | 类型      | 大小    | 范围                                                   | 格式                | 描述                       |\n| ------------ | --------- | ------- | ------------------------------------------------------ | ------------------- | -------------------------- |\n| 日期时间类型 | DATE      | 3 bytes | '1000-01-01' 至 '9999-12-31'                           | YYYY-MM-DD          | 只包含日期                 |\n| 日期时间类型 | TIME      | 3 bytes | '-838:59:59' 至 '838:59:59'                            | HH:MM:SS            | 只包含时间                 |\n| 日期时间类型 | DATETIME  | 8 bytes | '1000-01-01 00:00:00' 至 '9999-12-31 23:59:59'         | YYYY-MM-DD HH:MM:SS | 包含日期和时间             |\n| 日期时间类型 | TIMESTAMP | 4 bytes | '1970-01-01 00:00:01' UTC 至 '2038-01-19 03:14:07' UTC | YYYY-MM-DD HH:MM:SS | 包含日期和时间，用于时间戳 |\n| 日期时间类型 | YEAR      | 1 byte  | '1901' 至 '2155'                                       | YYYY                | 只包含年份                 |\n| 日期时间类型 | INTERVAL  | 可变大小  | 取决于时间段（如天、小时、分等）                     | INTERVAL '1' DAY     | 时间间隔类型，可表示时间段。可以通过减法操作得到时间间隔，且可加到日期/时间/时间戳上。|\n\n##### 表操作\n- 添加字段\n  ``` ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];```\n  例如，为tb_user表中增加一个新的字段“昵称”为nickname,类型为varchar(20)\n    ``` alter table tb_user add nickname varchar(20) commenr \"昵称\"; ```\n\n- 修改字段数据\n  - 修改数据类型\n    ``` ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度) ```\n\n  - 修改字段名和字段类型\n    ``` ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; ```\n\n- 修改表名\n  ``` ALTER TABLE 表名 RENAME TO 新表名 ```\n\n- 删除表\n  ``` DROP TABLE [IF EXISTS]  表名 ```\n\n- 删除指定表，并重新创建该表\n  ``` TRUNCATE TABLE 表名 ```","source":"_posts/数据库-1.md","raw":"---\ntitle: 数据库(1)\ndate: 2024-10-01 11:39:56\ntags: \n    - 学习笔记\n    - 数据库\n---\n### 数据库的相关概念\n | 名称           | 全称                                                           | 简介                             |\n | -------------- | -------------------------------------------------------------- | -------------------------------- |\n | 数据库         | 存储数据的仓库，数据是有组织的进行存储                         | DataBase(DB)                     |\n | 数据库管理系统 | 操纵和管理数据库的大型软件                                     | DataBase Management System(DBMS) |\n | SQL            | 操作关系数据库的变成语言，定义了一套操作关系数据库统一**标准** | Structured Query Language        |\n\n MySQL的启用与停止\n```bash\nnet start mysql80\nnet stop mysql80\n```\n\n### 数据模型\n- 关系型数据库(RDBMS) \n  - 概念：建立在关系模型的基础上，由多张相互连接的二维表组成的数据库。\n  - 特点：\n    1. 使用表格存储数据，格式统一，便于维护。\n    2. 使用SQL语言操作，标准统一，使用方便。\n- 数据模型\n  - MySQL客户端通过给服务器发送操作信息，来对数据库进行操作\n  - 在SQL服务器内部，DBMS对数据库进行创建、删除、操作等步骤。\n  - 一个数据库中可以包含多个表结构，表结构才是真正存储数据的部分\n\n### MySQL操作简介\n#### SQL通用语法\n1. SQL语句可以单行或多行书写，以分号结尾。\n2. SQL语句可以使用空格/缩进来增强语句的可读性\n3. MySQL数据库的SQL语句不区分大小写，但是一般将关键字大写。\n4. 注释：\n    - 单行注释：-- &nbsp; *注释内容*&nbsp; 或 # &nbsp; 注释内容\n    - 多行注释：/* &nbsp; 注释内容 &nbsp; */\n\n#### SQL语句分类\n| 分类 | 全称                       | 说明                                                   |\n| ---- | -------------------------- | ------------------------------------------------------ |\n| DDL  | Data Definition Language   | 数据定义语言，用来定义数据库对象(数据库，表，字段)     |\n| DML  | Data Manipulation Language | 数据操作语言，用来对数据库中表的数据进行增删改         |\n| DQL  | Data Query Language        | 数据查询语言，用来查询数据库中表的记录                 |\n| DCL  | Data  Control Language     | 数据控制语言，用来创建数据库用户、控制数据库的访问权限 |\n\n#### DDL语句\n##### 数据库操作\n- 查询\n  - 查询所有数据库\n    ``` SHOW DATABASES; ```   \n  - 查询当前数据库\n    ``` SELECT DATABASE(); ```\n- 创建\n  ``` CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则] ```\n- 删除\n  ``` DROP DATABASE [IF EXISTS] 数据库名; ```\n- 使用\n  ``` USE 数据库名; ```\n\n##### 表操作\n- 创建表\n\n  ```SQL\n  CREATE TABLE 表名(\n    属性   数据类型,\n    ......\n  )\n  ```\n\n- 查询当前数据库所有表\n  ``` SHOW TABLES ```\n- 查询表结构\n  ``` DESC 表名 ```\n- 查询指定表的建表语句\n  ``` SHOW CREATE TABLE 表名 ```\n##### 表结构的数据类型 \n| 分类     | 类型      | 大小    | 有符号(SIGNED)范围                          | 无符号(UNSIGNED)范围      | 描述         |\n| -------- | --------- | ------- | ------------------------------------------- | ------------------------- | ------------ |\n| 数值类型 | TINYINT   | 1 byte  | (-128, 127)                                 | (0, 255)                  | 小整数值     |\n| 数值类型 | SMALLINT  | 2 bytes | (-32768, 32767)                             | (0, 65535)                | 较小整数值   |\n| 数值类型 | MEDIUMINT | 3 bytes | (-8388608, 8388607)                         | (0, 16777215)             | 中等整数值   |\n| 数值类型 | INT       | 4 bytes | (-2147483648, 2147483647)                   | (0, 4294967295)           | 标准整数值   |\n| 数值类型 | BIGINT    | 8 bytes | (-9223372036854775808, 9223372036854775807) | (0, 18446744073709551615) | 大整数值     |\n| 数值类型 | FLOAT     | 4 bytes | 单精度浮点数范围                            | 单精度浮点数范围          | 单精度浮点数 |\n| 数值类型 | DOUBLE    | 8 bytes | 双精度浮点数范围                            | 双精度浮点数范围          | 双精度浮点数 |\n| 数值类型 | DECIMAL   | 可变    | 依定义的精度和标度确定                      | 依定义的精度和标度确定    | 定点数       |\n\n除此之外，MySQL还有相应的时间数据类型\n| 分类         | 类型      | 大小    | 范围                                                   | 格式                | 描述                       |\n| ------------ | --------- | ------- | ------------------------------------------------------ | ------------------- | -------------------------- |\n| 日期时间类型 | DATE      | 3 bytes | '1000-01-01' 至 '9999-12-31'                           | YYYY-MM-DD          | 只包含日期                 |\n| 日期时间类型 | TIME      | 3 bytes | '-838:59:59' 至 '838:59:59'                            | HH:MM:SS            | 只包含时间                 |\n| 日期时间类型 | DATETIME  | 8 bytes | '1000-01-01 00:00:00' 至 '9999-12-31 23:59:59'         | YYYY-MM-DD HH:MM:SS | 包含日期和时间             |\n| 日期时间类型 | TIMESTAMP | 4 bytes | '1970-01-01 00:00:01' UTC 至 '2038-01-19 03:14:07' UTC | YYYY-MM-DD HH:MM:SS | 包含日期和时间，用于时间戳 |\n| 日期时间类型 | YEAR      | 1 byte  | '1901' 至 '2155'                                       | YYYY                | 只包含年份                 |\n| 日期时间类型 | INTERVAL  | 可变大小  | 取决于时间段（如天、小时、分等）                     | INTERVAL '1' DAY     | 时间间隔类型，可表示时间段。可以通过减法操作得到时间间隔，且可加到日期/时间/时间戳上。|\n\n##### 表操作\n- 添加字段\n  ``` ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];```\n  例如，为tb_user表中增加一个新的字段“昵称”为nickname,类型为varchar(20)\n    ``` alter table tb_user add nickname varchar(20) commenr \"昵称\"; ```\n\n- 修改字段数据\n  - 修改数据类型\n    ``` ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度) ```\n\n  - 修改字段名和字段类型\n    ``` ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束]; ```\n\n- 修改表名\n  ``` ALTER TABLE 表名 RENAME TO 新表名 ```\n\n- 删除表\n  ``` DROP TABLE [IF EXISTS]  表名 ```\n\n- 删除指定表，并重新创建该表\n  ``` TRUNCATE TABLE 表名 ```","slug":"数据库-1","published":1,"updated":"2024-12-23T01:08:42.460Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot500066d6e85v50d6y","content":"<h3 id=\"数据库的相关概念\"><a href=\"#数据库的相关概念\" class=\"headerlink\" title=\"数据库的相关概念\"></a>数据库的相关概念</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>全称</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据库</td>\n<td>存储数据的仓库，数据是有组织的进行存储</td>\n<td>DataBase(DB)</td>\n</tr>\n<tr>\n<td>数据库管理系统</td>\n<td>操纵和管理数据库的大型软件</td>\n<td>DataBase Management System(DBMS)</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>操作关系数据库的变成语言，定义了一套操作关系数据库统一<strong>标准</strong></td>\n<td>Structured Query Language</td>\n</tr>\n</tbody></table>\n<p> MySQL的启用与停止</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">net start mysql80<br>net stop mysql80<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h3><ul>\n<li>关系型数据库(RDBMS) <ul>\n<li>概念：建立在关系模型的基础上，由多张相互连接的二维表组成的数据库。</li>\n<li>特点：<ol>\n<li>使用表格存储数据，格式统一，便于维护。</li>\n<li>使用SQL语言操作，标准统一，使用方便。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>数据模型<ul>\n<li>MySQL客户端通过给服务器发送操作信息，来对数据库进行操作</li>\n<li>在SQL服务器内部，DBMS对数据库进行创建、删除、操作等步骤。</li>\n<li>一个数据库中可以包含多个表结构，表结构才是真正存储数据的部分</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MySQL操作简介\"><a href=\"#MySQL操作简介\" class=\"headerlink\" title=\"MySQL操作简介\"></a>MySQL操作简介</h3><h4 id=\"SQL通用语法\"><a href=\"#SQL通用语法\" class=\"headerlink\" title=\"SQL通用语法\"></a>SQL通用语法</h4><ol>\n<li>SQL语句可以单行或多行书写，以分号结尾。</li>\n<li>SQL语句可以使用空格&#x2F;缩进来增强语句的可读性</li>\n<li>MySQL数据库的SQL语句不区分大小写，但是一般将关键字大写。</li>\n<li>注释：<ul>\n<li>单行注释：– &nbsp; <em>注释内容</em>&nbsp; 或 # &nbsp; 注释内容</li>\n<li>多行注释：&#x2F;* &nbsp; 注释内容 &nbsp; *&#x2F;</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"SQL语句分类\"><a href=\"#SQL语句分类\" class=\"headerlink\" title=\"SQL语句分类\"></a>SQL语句分类</h4><table>\n<thead>\n<tr>\n<th>分类</th>\n<th>全称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DDL</td>\n<td>Data Definition Language</td>\n<td>数据定义语言，用来定义数据库对象(数据库，表，字段)</td>\n</tr>\n<tr>\n<td>DML</td>\n<td>Data Manipulation Language</td>\n<td>数据操作语言，用来对数据库中表的数据进行增删改</td>\n</tr>\n<tr>\n<td>DQL</td>\n<td>Data Query Language</td>\n<td>数据查询语言，用来查询数据库中表的记录</td>\n</tr>\n<tr>\n<td>DCL</td>\n<td>Data  Control Language</td>\n<td>数据控制语言，用来创建数据库用户、控制数据库的访问权限</td>\n</tr>\n</tbody></table>\n<h4 id=\"DDL语句\"><a href=\"#DDL语句\" class=\"headerlink\" title=\"DDL语句\"></a>DDL语句</h4><h5 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h5><ul>\n<li>查询<ul>\n<li>查询所有数据库<br><code>SHOW DATABASES;</code>   </li>\n<li>查询当前数据库<br><code>SELECT DATABASE();</code></li>\n</ul>\n</li>\n<li>创建<br><code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]</code></li>\n<li>删除<br><code>DROP DATABASE [IF EXISTS] 数据库名;</code></li>\n<li>使用<br><code>USE 数据库名;</code></li>\n</ul>\n<h5 id=\"表操作\"><a href=\"#表操作\" class=\"headerlink\" title=\"表操作\"></a>表操作</h5><ul>\n<li><p>创建表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> 表名(<br>  属性   数据类型,<br>  ......<br>)<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>查询当前数据库所有表<br><code>SHOW TABLES</code></p>\n</li>\n<li><p>查询表结构<br><code>DESC 表名</code></p>\n</li>\n<li><p>查询指定表的建表语句<br><code>SHOW CREATE TABLE 表名</code></p>\n</li>\n</ul>\n<h5 id=\"表结构的数据类型\"><a href=\"#表结构的数据类型\" class=\"headerlink\" title=\"表结构的数据类型\"></a>表结构的数据类型</h5><table>\n<thead>\n<tr>\n<th>分类</th>\n<th>类型</th>\n<th>大小</th>\n<th>有符号(SIGNED)范围</th>\n<th>无符号(UNSIGNED)范围</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数值类型</td>\n<td>TINYINT</td>\n<td>1 byte</td>\n<td>(-128, 127)</td>\n<td>(0, 255)</td>\n<td>小整数值</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>SMALLINT</td>\n<td>2 bytes</td>\n<td>(-32768, 32767)</td>\n<td>(0, 65535)</td>\n<td>较小整数值</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>MEDIUMINT</td>\n<td>3 bytes</td>\n<td>(-8388608, 8388607)</td>\n<td>(0, 16777215)</td>\n<td>中等整数值</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>INT</td>\n<td>4 bytes</td>\n<td>(-2147483648, 2147483647)</td>\n<td>(0, 4294967295)</td>\n<td>标准整数值</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>BIGINT</td>\n<td>8 bytes</td>\n<td>(-9223372036854775808, 9223372036854775807)</td>\n<td>(0, 18446744073709551615)</td>\n<td>大整数值</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>FLOAT</td>\n<td>4 bytes</td>\n<td>单精度浮点数范围</td>\n<td>单精度浮点数范围</td>\n<td>单精度浮点数</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>DOUBLE</td>\n<td>8 bytes</td>\n<td>双精度浮点数范围</td>\n<td>双精度浮点数范围</td>\n<td>双精度浮点数</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>DECIMAL</td>\n<td>可变</td>\n<td>依定义的精度和标度确定</td>\n<td>依定义的精度和标度确定</td>\n<td>定点数</td>\n</tr>\n</tbody></table>\n<p>除此之外，MySQL还有相应的时间数据类型</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>类型</th>\n<th>大小</th>\n<th>范围</th>\n<th>格式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>日期时间类型</td>\n<td>DATE</td>\n<td>3 bytes</td>\n<td>‘1000-01-01’ 至 ‘9999-12-31’</td>\n<td>YYYY-MM-DD</td>\n<td>只包含日期</td>\n</tr>\n<tr>\n<td>日期时间类型</td>\n<td>TIME</td>\n<td>3 bytes</td>\n<td>‘-838:59:59’ 至 ‘838:59:59’</td>\n<td>HH:MM:SS</td>\n<td>只包含时间</td>\n</tr>\n<tr>\n<td>日期时间类型</td>\n<td>DATETIME</td>\n<td>8 bytes</td>\n<td>‘1000-01-01 00:00:00’ 至 ‘9999-12-31 23:59:59’</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>包含日期和时间</td>\n</tr>\n<tr>\n<td>日期时间类型</td>\n<td>TIMESTAMP</td>\n<td>4 bytes</td>\n<td>‘1970-01-01 00:00:01’ UTC 至 ‘2038-01-19 03:14:07’ UTC</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>包含日期和时间，用于时间戳</td>\n</tr>\n<tr>\n<td>日期时间类型</td>\n<td>YEAR</td>\n<td>1 byte</td>\n<td>‘1901’ 至 ‘2155’</td>\n<td>YYYY</td>\n<td>只包含年份</td>\n</tr>\n<tr>\n<td>日期时间类型</td>\n<td>INTERVAL</td>\n<td>可变大小</td>\n<td>取决于时间段（如天、小时、分等）</td>\n<td>INTERVAL ‘1’ DAY</td>\n<td>时间间隔类型，可表示时间段。可以通过减法操作得到时间间隔，且可加到日期&#x2F;时间&#x2F;时间戳上。</td>\n</tr>\n</tbody></table>\n<h5 id=\"表操作-1\"><a href=\"#表操作-1\" class=\"headerlink\" title=\"表操作\"></a>表操作</h5><ul>\n<li><p>添加字段<br><code> ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例如，为tb_user表中增加一个新的字段“昵称”为nickname,类型为varchar(20)<br>  <code>alter table tb_user add nickname varchar(20) commenr &quot;昵称&quot;;</code></p>\n</li>\n<li><p>修改字段数据</p>\n<ul>\n<li><p>修改数据类型<br><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)</code></p>\n</li>\n<li><p>修改字段名和字段类型<br><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code></p>\n</li>\n</ul>\n</li>\n<li><p>修改表名<br><code>ALTER TABLE 表名 RENAME TO 新表名</code></p>\n</li>\n<li><p>删除表<br><code>DROP TABLE [IF EXISTS]  表名</code></p>\n</li>\n<li><p>删除指定表，并重新创建该表<br><code>TRUNCATE TABLE 表名</code></p>\n</li>\n</ul>\n","excerpt":"","more":"<h3 id=\"数据库的相关概念\"><a href=\"#数据库的相关概念\" class=\"headerlink\" title=\"数据库的相关概念\"></a>数据库的相关概念</h3><table>\n<thead>\n<tr>\n<th>名称</th>\n<th>全称</th>\n<th>简介</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据库</td>\n<td>存储数据的仓库，数据是有组织的进行存储</td>\n<td>DataBase(DB)</td>\n</tr>\n<tr>\n<td>数据库管理系统</td>\n<td>操纵和管理数据库的大型软件</td>\n<td>DataBase Management System(DBMS)</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>操作关系数据库的变成语言，定义了一套操作关系数据库统一<strong>标准</strong></td>\n<td>Structured Query Language</td>\n</tr>\n</tbody></table>\n<p> MySQL的启用与停止</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">net start mysql80<br>net stop mysql80<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h3><ul>\n<li>关系型数据库(RDBMS) <ul>\n<li>概念：建立在关系模型的基础上，由多张相互连接的二维表组成的数据库。</li>\n<li>特点：<ol>\n<li>使用表格存储数据，格式统一，便于维护。</li>\n<li>使用SQL语言操作，标准统一，使用方便。</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>数据模型<ul>\n<li>MySQL客户端通过给服务器发送操作信息，来对数据库进行操作</li>\n<li>在SQL服务器内部，DBMS对数据库进行创建、删除、操作等步骤。</li>\n<li>一个数据库中可以包含多个表结构，表结构才是真正存储数据的部分</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MySQL操作简介\"><a href=\"#MySQL操作简介\" class=\"headerlink\" title=\"MySQL操作简介\"></a>MySQL操作简介</h3><h4 id=\"SQL通用语法\"><a href=\"#SQL通用语法\" class=\"headerlink\" title=\"SQL通用语法\"></a>SQL通用语法</h4><ol>\n<li>SQL语句可以单行或多行书写，以分号结尾。</li>\n<li>SQL语句可以使用空格&#x2F;缩进来增强语句的可读性</li>\n<li>MySQL数据库的SQL语句不区分大小写，但是一般将关键字大写。</li>\n<li>注释：<ul>\n<li>单行注释：– &nbsp; <em>注释内容</em>&nbsp; 或 # &nbsp; 注释内容</li>\n<li>多行注释：&#x2F;* &nbsp; 注释内容 &nbsp; *&#x2F;</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"SQL语句分类\"><a href=\"#SQL语句分类\" class=\"headerlink\" title=\"SQL语句分类\"></a>SQL语句分类</h4><table>\n<thead>\n<tr>\n<th>分类</th>\n<th>全称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DDL</td>\n<td>Data Definition Language</td>\n<td>数据定义语言，用来定义数据库对象(数据库，表，字段)</td>\n</tr>\n<tr>\n<td>DML</td>\n<td>Data Manipulation Language</td>\n<td>数据操作语言，用来对数据库中表的数据进行增删改</td>\n</tr>\n<tr>\n<td>DQL</td>\n<td>Data Query Language</td>\n<td>数据查询语言，用来查询数据库中表的记录</td>\n</tr>\n<tr>\n<td>DCL</td>\n<td>Data  Control Language</td>\n<td>数据控制语言，用来创建数据库用户、控制数据库的访问权限</td>\n</tr>\n</tbody></table>\n<h4 id=\"DDL语句\"><a href=\"#DDL语句\" class=\"headerlink\" title=\"DDL语句\"></a>DDL语句</h4><h5 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h5><ul>\n<li>查询<ul>\n<li>查询所有数据库<br><code>SHOW DATABASES;</code>   </li>\n<li>查询当前数据库<br><code>SELECT DATABASE();</code></li>\n</ul>\n</li>\n<li>创建<br><code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则]</code></li>\n<li>删除<br><code>DROP DATABASE [IF EXISTS] 数据库名;</code></li>\n<li>使用<br><code>USE 数据库名;</code></li>\n</ul>\n<h5 id=\"表操作\"><a href=\"#表操作\" class=\"headerlink\" title=\"表操作\"></a>表操作</h5><ul>\n<li><p>创建表</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> 表名(<br>  属性   数据类型,<br>  ......<br>)<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>查询当前数据库所有表<br><code>SHOW TABLES</code></p>\n</li>\n<li><p>查询表结构<br><code>DESC 表名</code></p>\n</li>\n<li><p>查询指定表的建表语句<br><code>SHOW CREATE TABLE 表名</code></p>\n</li>\n</ul>\n<h5 id=\"表结构的数据类型\"><a href=\"#表结构的数据类型\" class=\"headerlink\" title=\"表结构的数据类型\"></a>表结构的数据类型</h5><table>\n<thead>\n<tr>\n<th>分类</th>\n<th>类型</th>\n<th>大小</th>\n<th>有符号(SIGNED)范围</th>\n<th>无符号(UNSIGNED)范围</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数值类型</td>\n<td>TINYINT</td>\n<td>1 byte</td>\n<td>(-128, 127)</td>\n<td>(0, 255)</td>\n<td>小整数值</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>SMALLINT</td>\n<td>2 bytes</td>\n<td>(-32768, 32767)</td>\n<td>(0, 65535)</td>\n<td>较小整数值</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>MEDIUMINT</td>\n<td>3 bytes</td>\n<td>(-8388608, 8388607)</td>\n<td>(0, 16777215)</td>\n<td>中等整数值</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>INT</td>\n<td>4 bytes</td>\n<td>(-2147483648, 2147483647)</td>\n<td>(0, 4294967295)</td>\n<td>标准整数值</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>BIGINT</td>\n<td>8 bytes</td>\n<td>(-9223372036854775808, 9223372036854775807)</td>\n<td>(0, 18446744073709551615)</td>\n<td>大整数值</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>FLOAT</td>\n<td>4 bytes</td>\n<td>单精度浮点数范围</td>\n<td>单精度浮点数范围</td>\n<td>单精度浮点数</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>DOUBLE</td>\n<td>8 bytes</td>\n<td>双精度浮点数范围</td>\n<td>双精度浮点数范围</td>\n<td>双精度浮点数</td>\n</tr>\n<tr>\n<td>数值类型</td>\n<td>DECIMAL</td>\n<td>可变</td>\n<td>依定义的精度和标度确定</td>\n<td>依定义的精度和标度确定</td>\n<td>定点数</td>\n</tr>\n</tbody></table>\n<p>除此之外，MySQL还有相应的时间数据类型</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>类型</th>\n<th>大小</th>\n<th>范围</th>\n<th>格式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>日期时间类型</td>\n<td>DATE</td>\n<td>3 bytes</td>\n<td>‘1000-01-01’ 至 ‘9999-12-31’</td>\n<td>YYYY-MM-DD</td>\n<td>只包含日期</td>\n</tr>\n<tr>\n<td>日期时间类型</td>\n<td>TIME</td>\n<td>3 bytes</td>\n<td>‘-838:59:59’ 至 ‘838:59:59’</td>\n<td>HH:MM:SS</td>\n<td>只包含时间</td>\n</tr>\n<tr>\n<td>日期时间类型</td>\n<td>DATETIME</td>\n<td>8 bytes</td>\n<td>‘1000-01-01 00:00:00’ 至 ‘9999-12-31 23:59:59’</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>包含日期和时间</td>\n</tr>\n<tr>\n<td>日期时间类型</td>\n<td>TIMESTAMP</td>\n<td>4 bytes</td>\n<td>‘1970-01-01 00:00:01’ UTC 至 ‘2038-01-19 03:14:07’ UTC</td>\n<td>YYYY-MM-DD HH:MM:SS</td>\n<td>包含日期和时间，用于时间戳</td>\n</tr>\n<tr>\n<td>日期时间类型</td>\n<td>YEAR</td>\n<td>1 byte</td>\n<td>‘1901’ 至 ‘2155’</td>\n<td>YYYY</td>\n<td>只包含年份</td>\n</tr>\n<tr>\n<td>日期时间类型</td>\n<td>INTERVAL</td>\n<td>可变大小</td>\n<td>取决于时间段（如天、小时、分等）</td>\n<td>INTERVAL ‘1’ DAY</td>\n<td>时间间隔类型，可表示时间段。可以通过减法操作得到时间间隔，且可加到日期&#x2F;时间&#x2F;时间戳上。</td>\n</tr>\n</tbody></table>\n<h5 id=\"表操作-1\"><a href=\"#表操作-1\" class=\"headerlink\" title=\"表操作\"></a>表操作</h5><ul>\n<li><p>添加字段<br><code> ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例如，为tb_user表中增加一个新的字段“昵称”为nickname,类型为varchar(20)<br>  <code>alter table tb_user add nickname varchar(20) commenr &quot;昵称&quot;;</code></p>\n</li>\n<li><p>修改字段数据</p>\n<ul>\n<li><p>修改数据类型<br><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度)</code></p>\n</li>\n<li><p>修改字段名和字段类型<br><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code></p>\n</li>\n</ul>\n</li>\n<li><p>修改表名<br><code>ALTER TABLE 表名 RENAME TO 新表名</code></p>\n</li>\n<li><p>删除表<br><code>DROP TABLE [IF EXISTS]  表名</code></p>\n</li>\n<li><p>删除指定表，并重新创建该表<br><code>TRUNCATE TABLE 表名</code></p>\n</li>\n</ul>\n"},{"title":"数据库(2)","date":"2024-10-05T13:33:44.000Z","_content":"#### DML语句\nDML(Data Manipulation Language)(数据库操作语言)，用于对数据库中的数据记录进行增删改操作\n- 添加数据(INSERT)  在table中添加一条数据\n- 修改数据(UPDATE)  对table中的数据进行修改\n- 删除数据(DELETE)  对table中选定的数据进行删除\n##### DML-添加数据\n1. 给指定字段添加数据\n   ``` INSERT INTO 表名(字段名1，字段名2，...) VALUES(值1, 值2, ...);```\n\n2. 给全部字段添加数据\n   ``` INSERT INTO 表名 VALUES(值1, 值2, ...); ```\n\n3. 批量添加数据\n   ``` INSERT INTO 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...), (值1, 值2, ...),...,(值1, 值2, ...); ```\n   ``` INSERT INTO 表名 VALUES(值1, 值2, ...), (值1, 值2, ...),...,(值1, 值2, ...); ```\n\n##### DML-修改数据\n``` UPDATE 修改数据 SET 字段名1 = 值1 字段名2 = 值2, ... [WHERE 条件]; ```\n> **注意**：\n> 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表。\n\n##### DML-删除数据\n``` DELETE FROM 表名 [WHERE 条件] ```\n\n> **注意：**\n>   - DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张数据表\n>   - DELETE语句不能删除某一个字段的值(可以使用UPDATE)\n\n#### DQL语句\nDQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。  \n查询关键字: SELECT\n```sql\n   SELECT\n      字段列表\n   FROM\n      表名列表\n   WHERE\n      条件列表\n   GROUP BY \n      分组字段列表\n   HAVING\n      分组后条件列表\n   ORDER BY\n      排序字段列表\n   LIMIT\n      分页参数 \n```\n##### DQL-基本查询\n1. 查询多个字段\n   ```SELECT 字段1, 字段2, 字段3, ... FROM 表名```\n   ```SELECT * FROM 表名 ```\n2. 设置别名\n   ``` SELECT 字段1 [AS 别名1], 字段2 [AS 别名2] ... FROM 表名```\n3. 去除重复记录\n   ```SELECT DISTINCT 字段列表 FROM 表名```\n##### DQL-条件查询\n1. 语法\n   ``` SELECT 字段列表 FROM 表名 WHERE 条件列表;```\n2. 条件\n   | 比较运算符       | 功能                                      |\n   | ---------------- | ----------------------------------------- |\n   | $>$              | 大于                                      |\n   | $>=$             | 大于等于                                  |\n   | $<$              | 小于                                      |\n   | $<=$             | 小于等于                                  |\n   | $=$              | 等于                                      |\n   | $<>$或 $!=$      | 不等于                                    |\n   | BETWEEN...AND... | 在某个范围之内(含最大最小值)              |\n   | IN(...)          | 在in之后列表中的值，多选一                |\n   | LIKE 占位符      | 模糊匹配 (_匹配单个字符，%匹配任意个字符) |\n   | IS NULL          | 是NULL                                    |\n   \n   | 逻辑运算符 | 功能                        |\n   | ---------- | --------------------------- |\n   | AND 或 &&  | 并且(多个条件同时成立)      |\n   | OR 或 \\|\\| | 或者 (多个条件任意一个成立) |\n   | NOT 或 $!$ | 非，不是                    |\n\n##### DQL-聚合函数\n1. 将一列数据作为一个整体，进行纵向计算。\n2. 常见的聚合函数\n   | 函数  | 功能     |\n   | ----- | -------- |\n   | count | 统计数量 |\n   | max   | 最大值   |\n   | min   | 最小值   |\n   | avg   | 平均值   |\n   | sum   | 求和     |\n3. 语法\n   ```sql\n      SELECT 聚合函数(字段列表) FROM 表名;\n   ```\n> **注意**：\n> null值不参与所有聚合函数的运算\n##### DQL-分组查询\n1. 语法\n   `SELECT 字段列表 FROM [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组之后的条件]`\n2. where和having的区别\n   - 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是对分组之后的结果进行过滤。\n   - 判断条件不同：where不能对聚合函数进行判断，而having可以。\n   - \n> **注意**：\n> - 执行顺序：where > 聚合函数 > having\n> - 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段都无任何意义。 \n\n##### DQL-排序查询\n1. 语法\n   `SELECT 字段列表 FROM 表名  ORDER BY 字段1 排序方式, 字段2 排序方式2; `\n2. 排序方式\n   - ASC：升序(默认值)\n   - DESC：降序\n\n> **注意**：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序\n\n##### DQL-分页查询\n1. 语法\n   `SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;`\n> 注意：\n> - 起始索引从0开始，起始索引=(查询页码-1)*每页显示记录数。\n> - 分页查询是数据库方言，不同数据库有不同的实现，MySQL中是`LIMIT`。\n> - 如果查询的是第一页数据，起始索引可以忽略，直接简写为`LIMIT 10`。\n\n#### DCL语句\nDCL英文全称是Data Control Language，用来管理数据库用户、控制数据库访问权限\n\n ##### DCL-管理用户\n1.  查询用户\n   ```sql\n   USE mysql;\n   SELECT * FROM user;\n   ```\n2.  创建用户\n   ```sql\n   CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'\n   ```\n3.  修改用户密码\n   ```sql\n   Alter USER  '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'\n   ```\n4.  删除用户\n   ```sql\n   DROP USER '用户名'@'主机名'\n   ```\n> 注意：\n> - 主机名可以使用%通配\n> 这类SQL开发人员操作的比较少，主要是DBA（DataBase Administer）使用\n\n##### DCL-权限控制\n| 权限                | 说明               |\n| ------------------- | ------------------ |\n| ALL，ALL PRIVILEGES | 所有权限           |\n| SELECT              | 查询数据           |\n| INSERT              | 插入数据           |\n| UPDATE              | 修改数据           |\n| DELETE              | 删除数据           |\n| ALTER               | 修改表             |\n| DROP                | 删除数据库/表/视图 |\n| GREATE              | 创建数据库/表      |\n 1. 查询权限\n   ```sql\n   SHOW GRANTS FOR '用户名'@'主机名';\n   ```\n 2. 授予权限\n   ```sql\n   GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\n   ```\n 3. 撤销权限\n   ```sql\n   REMOVE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\n   ```\n","source":"_posts/数据库-2.md","raw":"---\ntitle: 数据库(2)\ndate: 2024-10-05 21:33:44\ntags:\n    - 学习笔记 \n    - 数据库 \n---\n#### DML语句\nDML(Data Manipulation Language)(数据库操作语言)，用于对数据库中的数据记录进行增删改操作\n- 添加数据(INSERT)  在table中添加一条数据\n- 修改数据(UPDATE)  对table中的数据进行修改\n- 删除数据(DELETE)  对table中选定的数据进行删除\n##### DML-添加数据\n1. 给指定字段添加数据\n   ``` INSERT INTO 表名(字段名1，字段名2，...) VALUES(值1, 值2, ...);```\n\n2. 给全部字段添加数据\n   ``` INSERT INTO 表名 VALUES(值1, 值2, ...); ```\n\n3. 批量添加数据\n   ``` INSERT INTO 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...), (值1, 值2, ...),...,(值1, 值2, ...); ```\n   ``` INSERT INTO 表名 VALUES(值1, 值2, ...), (值1, 值2, ...),...,(值1, 值2, ...); ```\n\n##### DML-修改数据\n``` UPDATE 修改数据 SET 字段名1 = 值1 字段名2 = 值2, ... [WHERE 条件]; ```\n> **注意**：\n> 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表。\n\n##### DML-删除数据\n``` DELETE FROM 表名 [WHERE 条件] ```\n\n> **注意：**\n>   - DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张数据表\n>   - DELETE语句不能删除某一个字段的值(可以使用UPDATE)\n\n#### DQL语句\nDQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。  \n查询关键字: SELECT\n```sql\n   SELECT\n      字段列表\n   FROM\n      表名列表\n   WHERE\n      条件列表\n   GROUP BY \n      分组字段列表\n   HAVING\n      分组后条件列表\n   ORDER BY\n      排序字段列表\n   LIMIT\n      分页参数 \n```\n##### DQL-基本查询\n1. 查询多个字段\n   ```SELECT 字段1, 字段2, 字段3, ... FROM 表名```\n   ```SELECT * FROM 表名 ```\n2. 设置别名\n   ``` SELECT 字段1 [AS 别名1], 字段2 [AS 别名2] ... FROM 表名```\n3. 去除重复记录\n   ```SELECT DISTINCT 字段列表 FROM 表名```\n##### DQL-条件查询\n1. 语法\n   ``` SELECT 字段列表 FROM 表名 WHERE 条件列表;```\n2. 条件\n   | 比较运算符       | 功能                                      |\n   | ---------------- | ----------------------------------------- |\n   | $>$              | 大于                                      |\n   | $>=$             | 大于等于                                  |\n   | $<$              | 小于                                      |\n   | $<=$             | 小于等于                                  |\n   | $=$              | 等于                                      |\n   | $<>$或 $!=$      | 不等于                                    |\n   | BETWEEN...AND... | 在某个范围之内(含最大最小值)              |\n   | IN(...)          | 在in之后列表中的值，多选一                |\n   | LIKE 占位符      | 模糊匹配 (_匹配单个字符，%匹配任意个字符) |\n   | IS NULL          | 是NULL                                    |\n   \n   | 逻辑运算符 | 功能                        |\n   | ---------- | --------------------------- |\n   | AND 或 &&  | 并且(多个条件同时成立)      |\n   | OR 或 \\|\\| | 或者 (多个条件任意一个成立) |\n   | NOT 或 $!$ | 非，不是                    |\n\n##### DQL-聚合函数\n1. 将一列数据作为一个整体，进行纵向计算。\n2. 常见的聚合函数\n   | 函数  | 功能     |\n   | ----- | -------- |\n   | count | 统计数量 |\n   | max   | 最大值   |\n   | min   | 最小值   |\n   | avg   | 平均值   |\n   | sum   | 求和     |\n3. 语法\n   ```sql\n      SELECT 聚合函数(字段列表) FROM 表名;\n   ```\n> **注意**：\n> null值不参与所有聚合函数的运算\n##### DQL-分组查询\n1. 语法\n   `SELECT 字段列表 FROM [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组之后的条件]`\n2. where和having的区别\n   - 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是对分组之后的结果进行过滤。\n   - 判断条件不同：where不能对聚合函数进行判断，而having可以。\n   - \n> **注意**：\n> - 执行顺序：where > 聚合函数 > having\n> - 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段都无任何意义。 \n\n##### DQL-排序查询\n1. 语法\n   `SELECT 字段列表 FROM 表名  ORDER BY 字段1 排序方式, 字段2 排序方式2; `\n2. 排序方式\n   - ASC：升序(默认值)\n   - DESC：降序\n\n> **注意**：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序\n\n##### DQL-分页查询\n1. 语法\n   `SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;`\n> 注意：\n> - 起始索引从0开始，起始索引=(查询页码-1)*每页显示记录数。\n> - 分页查询是数据库方言，不同数据库有不同的实现，MySQL中是`LIMIT`。\n> - 如果查询的是第一页数据，起始索引可以忽略，直接简写为`LIMIT 10`。\n\n#### DCL语句\nDCL英文全称是Data Control Language，用来管理数据库用户、控制数据库访问权限\n\n ##### DCL-管理用户\n1.  查询用户\n   ```sql\n   USE mysql;\n   SELECT * FROM user;\n   ```\n2.  创建用户\n   ```sql\n   CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'\n   ```\n3.  修改用户密码\n   ```sql\n   Alter USER  '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'\n   ```\n4.  删除用户\n   ```sql\n   DROP USER '用户名'@'主机名'\n   ```\n> 注意：\n> - 主机名可以使用%通配\n> 这类SQL开发人员操作的比较少，主要是DBA（DataBase Administer）使用\n\n##### DCL-权限控制\n| 权限                | 说明               |\n| ------------------- | ------------------ |\n| ALL，ALL PRIVILEGES | 所有权限           |\n| SELECT              | 查询数据           |\n| INSERT              | 插入数据           |\n| UPDATE              | 修改数据           |\n| DELETE              | 删除数据           |\n| ALTER               | 修改表             |\n| DROP                | 删除数据库/表/视图 |\n| GREATE              | 创建数据库/表      |\n 1. 查询权限\n   ```sql\n   SHOW GRANTS FOR '用户名'@'主机名';\n   ```\n 2. 授予权限\n   ```sql\n   GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';\n   ```\n 3. 撤销权限\n   ```sql\n   REMOVE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名';\n   ```\n","slug":"数据库-2","published":1,"updated":"2024-12-23T01:08:42.460Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot500086d6e2g8aedpk","content":"<h4 id=\"DML语句\"><a href=\"#DML语句\" class=\"headerlink\" title=\"DML语句\"></a>DML语句</h4><p>DML(Data Manipulation Language)(数据库操作语言)，用于对数据库中的数据记录进行增删改操作</p>\n<ul>\n<li>添加数据(INSERT)  在table中添加一条数据</li>\n<li>修改数据(UPDATE)  对table中的数据进行修改</li>\n<li>删除数据(DELETE)  对table中选定的数据进行删除</li>\n</ul>\n<h5 id=\"DML-添加数据\"><a href=\"#DML-添加数据\" class=\"headerlink\" title=\"DML-添加数据\"></a>DML-添加数据</h5><ol>\n<li><p>给指定字段添加数据<br><code> INSERT INTO 表名(字段名1，字段名2，...) VALUES(值1, 值2, ...);</code></p>\n</li>\n<li><p>给全部字段添加数据<br><code>INSERT INTO 表名 VALUES(值1, 值2, ...);</code></p>\n</li>\n<li><p>批量添加数据<br><code>INSERT INTO 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...), (值1, 值2, ...),...,(值1, 值2, ...);</code><br><code>INSERT INTO 表名 VALUES(值1, 值2, ...), (值1, 值2, ...),...,(值1, 值2, ...);</code></p>\n</li>\n</ol>\n<h5 id=\"DML-修改数据\"><a href=\"#DML-修改数据\" class=\"headerlink\" title=\"DML-修改数据\"></a>DML-修改数据</h5><p><code>UPDATE 修改数据 SET 字段名1 = 值1 字段名2 = 值2, ... [WHERE 条件];</code></p>\n<blockquote>\n<p><strong>注意</strong>：<br>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表。</p>\n</blockquote>\n<h5 id=\"DML-删除数据\"><a href=\"#DML-删除数据\" class=\"headerlink\" title=\"DML-删除数据\"></a>DML-删除数据</h5><p><code>DELETE FROM 表名 [WHERE 条件]</code></p>\n<blockquote>\n<p><strong>注意：</strong></p>\n<ul>\n<li>DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张数据表</li>\n<li>DELETE语句不能删除某一个字段的值(可以使用UPDATE)</li>\n</ul>\n</blockquote>\n<h4 id=\"DQL语句\"><a href=\"#DQL语句\" class=\"headerlink\" title=\"DQL语句\"></a>DQL语句</h4><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。<br>查询关键字: SELECT</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span><br>   字段列表<br><span class=\"hljs-keyword\">FROM</span><br>   表名列表<br><span class=\"hljs-keyword\">WHERE</span><br>   条件列表<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> <br>   分组字段列表<br><span class=\"hljs-keyword\">HAVING</span><br>   分组后条件列表<br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span><br>   排序字段列表<br>LIMIT<br>   分页参数 <br></code></pre></td></tr></table></figure>\n<h5 id=\"DQL-基本查询\"><a href=\"#DQL-基本查询\" class=\"headerlink\" title=\"DQL-基本查询\"></a>DQL-基本查询</h5><ol>\n<li>查询多个字段<br><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名</code><br><code>SELECT * FROM 表名 </code></li>\n<li>设置别名<br><code> SELECT 字段1 [AS 别名1], 字段2 [AS 别名2] ... FROM 表名</code></li>\n<li>去除重复记录<br><code>SELECT DISTINCT 字段列表 FROM 表名</code></li>\n</ol>\n<h5 id=\"DQL-条件查询\"><a href=\"#DQL-条件查询\" class=\"headerlink\" title=\"DQL-条件查询\"></a>DQL-条件查询</h5><ol>\n<li>语法<br><code> SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></li>\n<li>条件<table>\n<thead>\n<tr>\n<th>比较运算符</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$&gt;$</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>$&gt;&#x3D;$</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>$&lt;$</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>$&lt;&#x3D;$</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>$&#x3D;$</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>$&lt;&gt;$或 $!&#x3D;$</td>\n<td>不等于</td>\n</tr>\n<tr>\n<td>BETWEEN…AND…</td>\n<td>在某个范围之内(含最大最小值)</td>\n</tr>\n<tr>\n<td>IN(…)</td>\n<td>在in之后列表中的值，多选一</td>\n</tr>\n<tr>\n<td>LIKE 占位符</td>\n<td>模糊匹配 (_匹配单个字符，%匹配任意个字符)</td>\n</tr>\n<tr>\n<td>IS NULL</td>\n<td>是NULL</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>逻辑运算符</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AND 或 &amp;&amp;</td>\n<td>并且(多个条件同时成立)</td>\n</tr>\n<tr>\n<td>OR 或 ||</td>\n<td>或者 (多个条件任意一个成立)</td>\n</tr>\n<tr>\n<td>NOT 或 $!$</td>\n<td>非，不是</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h5 id=\"DQL-聚合函数\"><a href=\"#DQL-聚合函数\" class=\"headerlink\" title=\"DQL-聚合函数\"></a>DQL-聚合函数</h5><ol>\n<li>将一列数据作为一个整体，进行纵向计算。</li>\n<li>常见的聚合函数<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>count</td>\n<td>统计数量</td>\n</tr>\n<tr>\n<td>max</td>\n<td>最大值</td>\n</tr>\n<tr>\n<td>min</td>\n<td>最小值</td>\n</tr>\n<tr>\n<td>avg</td>\n<td>平均值</td>\n</tr>\n<tr>\n<td>sum</td>\n<td>求和</td>\n</tr>\n</tbody></table>\n</li>\n<li>语法<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> 聚合函数(字段列表) <span class=\"hljs-keyword\">FROM</span> 表名;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意</strong>：<br>null值不参与所有聚合函数的运算</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"DQL-分组查询\"><a href=\"#DQL-分组查询\" class=\"headerlink\" title=\"DQL-分组查询\"></a>DQL-分组查询</h5><ol>\n<li>语法<br><code>SELECT 字段列表 FROM [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组之后的条件]</code></li>\n<li><h2 id=\"where和having的区别-执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是对分组之后的结果进行过滤。-判断条件不同：where不能对聚合函数进行判断，而having可以。\"><a href=\"#where和having的区别-执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是对分组之后的结果进行过滤。-判断条件不同：where不能对聚合函数进行判断，而having可以。\" class=\"headerlink\" title=\"where和having的区别- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是对分组之后的结果进行过滤。- 判断条件不同：where不能对聚合函数进行判断，而having可以。\"></a>where和having的区别<br>- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是对分组之后的结果进行过滤。<br>- 判断条件不同：where不能对聚合函数进行判断，而having可以。</h2><blockquote>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>执行顺序：where &gt; 聚合函数 &gt; having</li>\n<li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段都无任何意义。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"DQL-排序查询\"><a href=\"#DQL-排序查询\" class=\"headerlink\" title=\"DQL-排序查询\"></a>DQL-排序查询</h5><ol>\n<li>语法<br><code>SELECT 字段列表 FROM 表名  ORDER BY 字段1 排序方式, 字段2 排序方式2; </code></li>\n<li>排序方式<ul>\n<li>ASC：升序(默认值)</li>\n<li>DESC：降序</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>注意</strong>：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p>\n</blockquote>\n<h5 id=\"DQL-分页查询\"><a href=\"#DQL-分页查询\" class=\"headerlink\" title=\"DQL-分页查询\"></a>DQL-分页查询</h5><ol>\n<li>语法<br><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code><blockquote>\n<p>注意：</p>\n<ul>\n<li>起始索引从0开始，起始索引&#x3D;(查询页码-1)*每页显示记录数。</li>\n<li>分页查询是数据库方言，不同数据库有不同的实现，MySQL中是<code>LIMIT</code>。</li>\n<li>如果查询的是第一页数据，起始索引可以忽略，直接简写为<code>LIMIT 10</code>。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"DCL语句\"><a href=\"#DCL语句\" class=\"headerlink\" title=\"DCL语句\"></a>DCL语句</h4><p>DCL英文全称是Data Control Language，用来管理数据库用户、控制数据库访问权限</p>\n<h5 id=\"DCL-管理用户\"><a href=\"#DCL-管理用户\" class=\"headerlink\" title=\"DCL-管理用户\"></a>DCL-管理用户</h5><ol>\n<li>查询用户   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">USE mysql;<br><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-keyword\">user</span>;<br></code></pre></td></tr></table></figure></li>\n<li>创建用户   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span> <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span> IDENTIFIED <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">&#x27;密码&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li>修改用户密码   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">Alter</span> <span class=\"hljs-keyword\">USER</span>  <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span> IDENTIFIED <span class=\"hljs-keyword\">WITH</span> mysql_native_password <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">&#x27;新密码&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li>删除用户   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">USER</span> <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>主机名可以使用%通配<br>这类SQL开发人员操作的比较少，主要是DBA（DataBase Administer）使用</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"DCL-权限控制\"><a href=\"#DCL-权限控制\" class=\"headerlink\" title=\"DCL-权限控制\"></a>DCL-权限控制</h5><table>\n<thead>\n<tr>\n<th>权限</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ALL，ALL PRIVILEGES</td>\n<td>所有权限</td>\n</tr>\n<tr>\n<td>SELECT</td>\n<td>查询数据</td>\n</tr>\n<tr>\n<td>INSERT</td>\n<td>插入数据</td>\n</tr>\n<tr>\n<td>UPDATE</td>\n<td>修改数据</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>删除数据</td>\n</tr>\n<tr>\n<td>ALTER</td>\n<td>修改表</td>\n</tr>\n<tr>\n<td>DROP</td>\n<td>删除数据库&#x2F;表&#x2F;视图</td>\n</tr>\n<tr>\n<td>GREATE</td>\n<td>创建数据库&#x2F;表</td>\n</tr>\n</tbody></table>\n<ol>\n<li>查询权限   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SHOW</span> GRANTS <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure></li>\n<li>授予权限   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">GRANT</span> 权限列表 <span class=\"hljs-keyword\">ON</span> 数据库名.表名 <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure></li>\n<li>撤销权限   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">REMOVE 权限列表 <span class=\"hljs-keyword\">ON</span> 数据库名.表名 <span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure></li>\n</ol>\n","excerpt":"","more":"<h4 id=\"DML语句\"><a href=\"#DML语句\" class=\"headerlink\" title=\"DML语句\"></a>DML语句</h4><p>DML(Data Manipulation Language)(数据库操作语言)，用于对数据库中的数据记录进行增删改操作</p>\n<ul>\n<li>添加数据(INSERT)  在table中添加一条数据</li>\n<li>修改数据(UPDATE)  对table中的数据进行修改</li>\n<li>删除数据(DELETE)  对table中选定的数据进行删除</li>\n</ul>\n<h5 id=\"DML-添加数据\"><a href=\"#DML-添加数据\" class=\"headerlink\" title=\"DML-添加数据\"></a>DML-添加数据</h5><ol>\n<li><p>给指定字段添加数据<br><code> INSERT INTO 表名(字段名1，字段名2，...) VALUES(值1, 值2, ...);</code></p>\n</li>\n<li><p>给全部字段添加数据<br><code>INSERT INTO 表名 VALUES(值1, 值2, ...);</code></p>\n</li>\n<li><p>批量添加数据<br><code>INSERT INTO 表名(字段1, 字段2, ...) VALUES(值1, 值2, ...), (值1, 值2, ...),...,(值1, 值2, ...);</code><br><code>INSERT INTO 表名 VALUES(值1, 值2, ...), (值1, 值2, ...),...,(值1, 值2, ...);</code></p>\n</li>\n</ol>\n<h5 id=\"DML-修改数据\"><a href=\"#DML-修改数据\" class=\"headerlink\" title=\"DML-修改数据\"></a>DML-修改数据</h5><p><code>UPDATE 修改数据 SET 字段名1 = 值1 字段名2 = 值2, ... [WHERE 条件];</code></p>\n<blockquote>\n<p><strong>注意</strong>：<br>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表。</p>\n</blockquote>\n<h5 id=\"DML-删除数据\"><a href=\"#DML-删除数据\" class=\"headerlink\" title=\"DML-删除数据\"></a>DML-删除数据</h5><p><code>DELETE FROM 表名 [WHERE 条件]</code></p>\n<blockquote>\n<p><strong>注意：</strong></p>\n<ul>\n<li>DELETE语句的条件可以有，也可以没有，如果没有条件，则会删除整张数据表</li>\n<li>DELETE语句不能删除某一个字段的值(可以使用UPDATE)</li>\n</ul>\n</blockquote>\n<h4 id=\"DQL语句\"><a href=\"#DQL语句\" class=\"headerlink\" title=\"DQL语句\"></a>DQL语句</h4><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。<br>查询关键字: SELECT</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span><br>   字段列表<br><span class=\"hljs-keyword\">FROM</span><br>   表名列表<br><span class=\"hljs-keyword\">WHERE</span><br>   条件列表<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> <br>   分组字段列表<br><span class=\"hljs-keyword\">HAVING</span><br>   分组后条件列表<br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span><br>   排序字段列表<br>LIMIT<br>   分页参数 <br></code></pre></td></tr></table></figure>\n<h5 id=\"DQL-基本查询\"><a href=\"#DQL-基本查询\" class=\"headerlink\" title=\"DQL-基本查询\"></a>DQL-基本查询</h5><ol>\n<li>查询多个字段<br><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名</code><br><code>SELECT * FROM 表名 </code></li>\n<li>设置别名<br><code> SELECT 字段1 [AS 别名1], 字段2 [AS 别名2] ... FROM 表名</code></li>\n<li>去除重复记录<br><code>SELECT DISTINCT 字段列表 FROM 表名</code></li>\n</ol>\n<h5 id=\"DQL-条件查询\"><a href=\"#DQL-条件查询\" class=\"headerlink\" title=\"DQL-条件查询\"></a>DQL-条件查询</h5><ol>\n<li>语法<br><code> SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></li>\n<li>条件<table>\n<thead>\n<tr>\n<th>比较运算符</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$&gt;$</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>$&gt;&#x3D;$</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>$&lt;$</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>$&lt;&#x3D;$</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>$&#x3D;$</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>$&lt;&gt;$或 $!&#x3D;$</td>\n<td>不等于</td>\n</tr>\n<tr>\n<td>BETWEEN…AND…</td>\n<td>在某个范围之内(含最大最小值)</td>\n</tr>\n<tr>\n<td>IN(…)</td>\n<td>在in之后列表中的值，多选一</td>\n</tr>\n<tr>\n<td>LIKE 占位符</td>\n<td>模糊匹配 (_匹配单个字符，%匹配任意个字符)</td>\n</tr>\n<tr>\n<td>IS NULL</td>\n<td>是NULL</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>逻辑运算符</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>AND 或 &amp;&amp;</td>\n<td>并且(多个条件同时成立)</td>\n</tr>\n<tr>\n<td>OR 或 ||</td>\n<td>或者 (多个条件任意一个成立)</td>\n</tr>\n<tr>\n<td>NOT 或 $!$</td>\n<td>非，不是</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h5 id=\"DQL-聚合函数\"><a href=\"#DQL-聚合函数\" class=\"headerlink\" title=\"DQL-聚合函数\"></a>DQL-聚合函数</h5><ol>\n<li>将一列数据作为一个整体，进行纵向计算。</li>\n<li>常见的聚合函数<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>count</td>\n<td>统计数量</td>\n</tr>\n<tr>\n<td>max</td>\n<td>最大值</td>\n</tr>\n<tr>\n<td>min</td>\n<td>最小值</td>\n</tr>\n<tr>\n<td>avg</td>\n<td>平均值</td>\n</tr>\n<tr>\n<td>sum</td>\n<td>求和</td>\n</tr>\n</tbody></table>\n</li>\n<li>语法<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> 聚合函数(字段列表) <span class=\"hljs-keyword\">FROM</span> 表名;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>注意</strong>：<br>null值不参与所有聚合函数的运算</p>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"DQL-分组查询\"><a href=\"#DQL-分组查询\" class=\"headerlink\" title=\"DQL-分组查询\"></a>DQL-分组查询</h5><ol>\n<li>语法<br><code>SELECT 字段列表 FROM [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组之后的条件]</code></li>\n<li><h2 id=\"where和having的区别-执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是对分组之后的结果进行过滤。-判断条件不同：where不能对聚合函数进行判断，而having可以。\"><a href=\"#where和having的区别-执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是对分组之后的结果进行过滤。-判断条件不同：where不能对聚合函数进行判断，而having可以。\" class=\"headerlink\" title=\"where和having的区别- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是对分组之后的结果进行过滤。- 判断条件不同：where不能对聚合函数进行判断，而having可以。\"></a>where和having的区别<br>- 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是对分组之后的结果进行过滤。<br>- 判断条件不同：where不能对聚合函数进行判断，而having可以。</h2><blockquote>\n<p><strong>注意</strong>：</p>\n<ul>\n<li>执行顺序：where &gt; 聚合函数 &gt; having</li>\n<li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段都无任何意义。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"DQL-排序查询\"><a href=\"#DQL-排序查询\" class=\"headerlink\" title=\"DQL-排序查询\"></a>DQL-排序查询</h5><ol>\n<li>语法<br><code>SELECT 字段列表 FROM 表名  ORDER BY 字段1 排序方式, 字段2 排序方式2; </code></li>\n<li>排序方式<ul>\n<li>ASC：升序(默认值)</li>\n<li>DESC：降序</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p><strong>注意</strong>：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p>\n</blockquote>\n<h5 id=\"DQL-分页查询\"><a href=\"#DQL-分页查询\" class=\"headerlink\" title=\"DQL-分页查询\"></a>DQL-分页查询</h5><ol>\n<li>语法<br><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code><blockquote>\n<p>注意：</p>\n<ul>\n<li>起始索引从0开始，起始索引&#x3D;(查询页码-1)*每页显示记录数。</li>\n<li>分页查询是数据库方言，不同数据库有不同的实现，MySQL中是<code>LIMIT</code>。</li>\n<li>如果查询的是第一页数据，起始索引可以忽略，直接简写为<code>LIMIT 10</code>。</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"DCL语句\"><a href=\"#DCL语句\" class=\"headerlink\" title=\"DCL语句\"></a>DCL语句</h4><p>DCL英文全称是Data Control Language，用来管理数据库用户、控制数据库访问权限</p>\n<h5 id=\"DCL-管理用户\"><a href=\"#DCL-管理用户\" class=\"headerlink\" title=\"DCL-管理用户\"></a>DCL-管理用户</h5><ol>\n<li>查询用户   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">USE mysql;<br><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-keyword\">user</span>;<br></code></pre></td></tr></table></figure></li>\n<li>创建用户   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">USER</span> <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span> IDENTIFIED <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">&#x27;密码&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li>修改用户密码   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">Alter</span> <span class=\"hljs-keyword\">USER</span>  <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span> IDENTIFIED <span class=\"hljs-keyword\">WITH</span> mysql_native_password <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">&#x27;新密码&#x27;</span><br></code></pre></td></tr></table></figure></li>\n<li>删除用户   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">DROP</span> <span class=\"hljs-keyword\">USER</span> <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span><br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>注意：</p>\n<ul>\n<li>主机名可以使用%通配<br>这类SQL开发人员操作的比较少，主要是DBA（DataBase Administer）使用</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<h5 id=\"DCL-权限控制\"><a href=\"#DCL-权限控制\" class=\"headerlink\" title=\"DCL-权限控制\"></a>DCL-权限控制</h5><table>\n<thead>\n<tr>\n<th>权限</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ALL，ALL PRIVILEGES</td>\n<td>所有权限</td>\n</tr>\n<tr>\n<td>SELECT</td>\n<td>查询数据</td>\n</tr>\n<tr>\n<td>INSERT</td>\n<td>插入数据</td>\n</tr>\n<tr>\n<td>UPDATE</td>\n<td>修改数据</td>\n</tr>\n<tr>\n<td>DELETE</td>\n<td>删除数据</td>\n</tr>\n<tr>\n<td>ALTER</td>\n<td>修改表</td>\n</tr>\n<tr>\n<td>DROP</td>\n<td>删除数据库&#x2F;表&#x2F;视图</td>\n</tr>\n<tr>\n<td>GREATE</td>\n<td>创建数据库&#x2F;表</td>\n</tr>\n</tbody></table>\n<ol>\n<li>查询权限   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SHOW</span> GRANTS <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure></li>\n<li>授予权限   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">GRANT</span> 权限列表 <span class=\"hljs-keyword\">ON</span> 数据库名.表名 <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure></li>\n<li>撤销权限   <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">REMOVE 权限列表 <span class=\"hljs-keyword\">ON</span> 数据库名.表名 <span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-string\">&#x27;用户名&#x27;</span>@<span class=\"hljs-string\">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure></li>\n</ol>\n"},{"title":"数据库(3)","date":"2024-11-01T02:32:34.000Z","_content":"# 数据库函数\n定义，懂的都懂，没啥好说的\n## 字符串函数\nMySQL中内置了很多字符串函数，常用以下几个\n| 函数                            | 功能                                                      |\n| ------------------------------- | --------------------------------------------------------- |\n| CONTACT( $S_1$ , $S_2$ , $S_3$) | 字符串拼接（跟python一样的）                              |\n| LOWER(str)                      | 将字符串str全部转为小写                                   |\n| UPPER(str)                      | 将字符串str全部转为大写                                   |\n| LPAD(str, n, pad)               | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |\n| RPAD(str, n, pad)               | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 | TRIM(str) | 去掉字符串头部和尾部的空格 |\n| SUBSTRING(str, start, len)      | 返回字符串str从第start字符开始的所有字符                  |\n\n## 数值函数\n| 函数       | 功能                            |\n| ---------- | ------------------------------- |\n| CEIL(x)    | 向上取整                        |\n| FLOOR(x)   | 向下取整                        |\n| MOD(x,y)   | 返回x/y的模                     |\n| RAND()     | 返回0~1的随机数                 |\n| ROUND(x,y) | 求参数的四舍五入值，保留y位小数 |\n\n## 日期函数\n| 函数                               | 功能                                              |\n| ---------------------------------- | ------------------------------------------------- |\n| CURDATE()                          | 返回当前日期                                      |\n| CURTIME()                          | 返回当前时间                                      |\n| NOW()                              | 返回当前日期和时间                                |\n| YEAR(data)                         | 获得指定data的年份                                |\n| MONTH(data)                        | 获得指定data的月份                                |\n| DAY(data)                          | 获得指定data的日期                                |\n| DATE_ADD(date, INTERVEL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |\n| DATADIFF(data1,data2)              | 返回起始时间data1到结束时间data2之间的天数        |\n\n## 流程函数\n在SQL中实现条件筛选，从而提高语句效率\n| 函数                                                     | 功能                                                      |\n| -------------------------------------------------------- | --------------------------------------------------------- |\n| IF(value, t, f)                                          | 如果value为true，则返回t，否则返回f                       |\n| IFNULL(value1,value2)                                    | 如果value1不为空，则返回value1，否则返回value2            |\n| CASE WHEN [val1] THEN [rel1] ... ELSE [default]  END     | 如果val1为true，则返回val1，否则返回默认值default         |\n| CASE [expr] WHEN val1 THEN [res1] ... ELSE [default] END | 如果expr等于val1，则返回res1，……，否则则返回默认值default |\n\n\n","source":"_posts/数据库-3.md","raw":"---\ntitle: 数据库(3)\ndate: 2024-11-01 10:32:34\ntags:\n    - 学习笔记\n    - 数据库\n---\n# 数据库函数\n定义，懂的都懂，没啥好说的\n## 字符串函数\nMySQL中内置了很多字符串函数，常用以下几个\n| 函数                            | 功能                                                      |\n| ------------------------------- | --------------------------------------------------------- |\n| CONTACT( $S_1$ , $S_2$ , $S_3$) | 字符串拼接（跟python一样的）                              |\n| LOWER(str)                      | 将字符串str全部转为小写                                   |\n| UPPER(str)                      | 将字符串str全部转为大写                                   |\n| LPAD(str, n, pad)               | 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 |\n| RPAD(str, n, pad)               | 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 | TRIM(str) | 去掉字符串头部和尾部的空格 |\n| SUBSTRING(str, start, len)      | 返回字符串str从第start字符开始的所有字符                  |\n\n## 数值函数\n| 函数       | 功能                            |\n| ---------- | ------------------------------- |\n| CEIL(x)    | 向上取整                        |\n| FLOOR(x)   | 向下取整                        |\n| MOD(x,y)   | 返回x/y的模                     |\n| RAND()     | 返回0~1的随机数                 |\n| ROUND(x,y) | 求参数的四舍五入值，保留y位小数 |\n\n## 日期函数\n| 函数                               | 功能                                              |\n| ---------------------------------- | ------------------------------------------------- |\n| CURDATE()                          | 返回当前日期                                      |\n| CURTIME()                          | 返回当前时间                                      |\n| NOW()                              | 返回当前日期和时间                                |\n| YEAR(data)                         | 获得指定data的年份                                |\n| MONTH(data)                        | 获得指定data的月份                                |\n| DAY(data)                          | 获得指定data的日期                                |\n| DATE_ADD(date, INTERVEL expr type) | 返回一个日期/时间值加上一个时间间隔expr后的时间值 |\n| DATADIFF(data1,data2)              | 返回起始时间data1到结束时间data2之间的天数        |\n\n## 流程函数\n在SQL中实现条件筛选，从而提高语句效率\n| 函数                                                     | 功能                                                      |\n| -------------------------------------------------------- | --------------------------------------------------------- |\n| IF(value, t, f)                                          | 如果value为true，则返回t，否则返回f                       |\n| IFNULL(value1,value2)                                    | 如果value1不为空，则返回value1，否则返回value2            |\n| CASE WHEN [val1] THEN [rel1] ... ELSE [default]  END     | 如果val1为true，则返回val1，否则返回默认值default         |\n| CASE [expr] WHEN val1 THEN [res1] ... ELSE [default] END | 如果expr等于val1，则返回res1，……，否则则返回默认值default |\n\n\n","slug":"数据库-3","published":1,"updated":"2024-12-23T01:08:42.460Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot600096d6e92adbbit","content":"<h1 id=\"数据库函数\"><a href=\"#数据库函数\" class=\"headerlink\" title=\"数据库函数\"></a>数据库函数</h1><p>定义，懂的都懂，没啥好说的</p>\n<h2 id=\"字符串函数\"><a href=\"#字符串函数\" class=\"headerlink\" title=\"字符串函数\"></a>字符串函数</h2><p>MySQL中内置了很多字符串函数，常用以下几个</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONTACT( $S_1$ , $S_2$ , $S_3$)</td>\n<td>字符串拼接（跟python一样的）</td>\n</tr>\n<tr>\n<td>LOWER(str)</td>\n<td>将字符串str全部转为小写</td>\n</tr>\n<tr>\n<td>UPPER(str)</td>\n<td>将字符串str全部转为大写</td>\n</tr>\n<tr>\n<td>LPAD(str, n, pad)</td>\n<td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>\n</tr>\n<tr>\n<td>RPAD(str, n, pad)</td>\n<td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>\n</tr>\n<tr>\n<td>SUBSTRING(str, start, len)</td>\n<td>返回字符串str从第start字符开始的所有字符</td>\n</tr>\n</tbody></table>\n<h2 id=\"数值函数\"><a href=\"#数值函数\" class=\"headerlink\" title=\"数值函数\"></a>数值函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CEIL(x)</td>\n<td>向上取整</td>\n</tr>\n<tr>\n<td>FLOOR(x)</td>\n<td>向下取整</td>\n</tr>\n<tr>\n<td>MOD(x,y)</td>\n<td>返回x&#x2F;y的模</td>\n</tr>\n<tr>\n<td>RAND()</td>\n<td>返回0~1的随机数</td>\n</tr>\n<tr>\n<td>ROUND(x,y)</td>\n<td>求参数的四舍五入值，保留y位小数</td>\n</tr>\n</tbody></table>\n<h2 id=\"日期函数\"><a href=\"#日期函数\" class=\"headerlink\" title=\"日期函数\"></a>日期函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CURDATE()</td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td>CURTIME()</td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td>NOW()</td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td>YEAR(data)</td>\n<td>获得指定data的年份</td>\n</tr>\n<tr>\n<td>MONTH(data)</td>\n<td>获得指定data的月份</td>\n</tr>\n<tr>\n<td>DAY(data)</td>\n<td>获得指定data的日期</td>\n</tr>\n<tr>\n<td>DATE_ADD(date, INTERVEL expr type)</td>\n<td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td>\n</tr>\n<tr>\n<td>DATADIFF(data1,data2)</td>\n<td>返回起始时间data1到结束时间data2之间的天数</td>\n</tr>\n</tbody></table>\n<h2 id=\"流程函数\"><a href=\"#流程函数\" class=\"headerlink\" title=\"流程函数\"></a>流程函数</h2><p>在SQL中实现条件筛选，从而提高语句效率</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IF(value, t, f)</td>\n<td>如果value为true，则返回t，否则返回f</td>\n</tr>\n<tr>\n<td>IFNULL(value1,value2)</td>\n<td>如果value1不为空，则返回value1，否则返回value2</td>\n</tr>\n<tr>\n<td>CASE WHEN [val1] THEN [rel1] … ELSE [default]  END</td>\n<td>如果val1为true，则返回val1，否则返回默认值default</td>\n</tr>\n<tr>\n<td>CASE [expr] WHEN val1 THEN [res1] … ELSE [default] END</td>\n<td>如果expr等于val1，则返回res1，……，否则则返回默认值default</td>\n</tr>\n</tbody></table>\n","excerpt":"","more":"<h1 id=\"数据库函数\"><a href=\"#数据库函数\" class=\"headerlink\" title=\"数据库函数\"></a>数据库函数</h1><p>定义，懂的都懂，没啥好说的</p>\n<h2 id=\"字符串函数\"><a href=\"#字符串函数\" class=\"headerlink\" title=\"字符串函数\"></a>字符串函数</h2><p>MySQL中内置了很多字符串函数，常用以下几个</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CONTACT( $S_1$ , $S_2$ , $S_3$)</td>\n<td>字符串拼接（跟python一样的）</td>\n</tr>\n<tr>\n<td>LOWER(str)</td>\n<td>将字符串str全部转为小写</td>\n</tr>\n<tr>\n<td>UPPER(str)</td>\n<td>将字符串str全部转为大写</td>\n</tr>\n<tr>\n<td>LPAD(str, n, pad)</td>\n<td>左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td>\n</tr>\n<tr>\n<td>RPAD(str, n, pad)</td>\n<td>右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td>\n</tr>\n<tr>\n<td>SUBSTRING(str, start, len)</td>\n<td>返回字符串str从第start字符开始的所有字符</td>\n</tr>\n</tbody></table>\n<h2 id=\"数值函数\"><a href=\"#数值函数\" class=\"headerlink\" title=\"数值函数\"></a>数值函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CEIL(x)</td>\n<td>向上取整</td>\n</tr>\n<tr>\n<td>FLOOR(x)</td>\n<td>向下取整</td>\n</tr>\n<tr>\n<td>MOD(x,y)</td>\n<td>返回x&#x2F;y的模</td>\n</tr>\n<tr>\n<td>RAND()</td>\n<td>返回0~1的随机数</td>\n</tr>\n<tr>\n<td>ROUND(x,y)</td>\n<td>求参数的四舍五入值，保留y位小数</td>\n</tr>\n</tbody></table>\n<h2 id=\"日期函数\"><a href=\"#日期函数\" class=\"headerlink\" title=\"日期函数\"></a>日期函数</h2><table>\n<thead>\n<tr>\n<th>函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>CURDATE()</td>\n<td>返回当前日期</td>\n</tr>\n<tr>\n<td>CURTIME()</td>\n<td>返回当前时间</td>\n</tr>\n<tr>\n<td>NOW()</td>\n<td>返回当前日期和时间</td>\n</tr>\n<tr>\n<td>YEAR(data)</td>\n<td>获得指定data的年份</td>\n</tr>\n<tr>\n<td>MONTH(data)</td>\n<td>获得指定data的月份</td>\n</tr>\n<tr>\n<td>DAY(data)</td>\n<td>获得指定data的日期</td>\n</tr>\n<tr>\n<td>DATE_ADD(date, INTERVEL expr type)</td>\n<td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td>\n</tr>\n<tr>\n<td>DATADIFF(data1,data2)</td>\n<td>返回起始时间data1到结束时间data2之间的天数</td>\n</tr>\n</tbody></table>\n<h2 id=\"流程函数\"><a href=\"#流程函数\" class=\"headerlink\" title=\"流程函数\"></a>流程函数</h2><p>在SQL中实现条件筛选，从而提高语句效率</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>IF(value, t, f)</td>\n<td>如果value为true，则返回t，否则返回f</td>\n</tr>\n<tr>\n<td>IFNULL(value1,value2)</td>\n<td>如果value1不为空，则返回value1，否则返回value2</td>\n</tr>\n<tr>\n<td>CASE WHEN [val1] THEN [rel1] … ELSE [default]  END</td>\n<td>如果val1为true，则返回val1，否则返回默认值default</td>\n</tr>\n<tr>\n<td>CASE [expr] WHEN val1 THEN [res1] … ELSE [default] END</td>\n<td>如果expr等于val1，则返回res1，……，否则则返回默认值default</td>\n</tr>\n</tbody></table>\n"},{"title":"数据库(4)","date":"2024-12-20T01:55:54.000Z","_content":"\n## 关系型数据库的结构(语法)\n\n### 关系型数据库基础介绍\n\n关系型数据库由一系列表的集合组成。对于关系模型：\n\n- $A_1, A_2,..., A_n$为模型中的属性\n- $D_1, D_2,..., D_n$为模型中属性的域，即对于每个属性允许的取值。\n  - 属性的域是一系列允许的值的集合\n  - 属性值通常是原子的，即不可再分的，符合第一范式（1NF）\n  - 特殊值`NULL`是每个域的成员，表示该值未知。但是`NULL`的操作可能会导致一些未知错误，比如索引失败\n- $R=(A_1, A_2,..., A_n)$是关系模式(relation schema)\n- 关系实例`r`在模式`R`上的定义表示为$r(R)$\n- 其当前的值由表指定\n- 对于关系实例`r`的的一个元素`t`被称为元组(tuple)，用表中的一行表示\n  \n或许感觉对于`r`、`R`和`t`的关系有一定的不明确。简单的来说，`R`定义了一个表的结构，`r`是对于表结构`R`的具体实现，而`t`是`r`中的一个元素，也就是表中的一条数据。\n\n对于关系顺序一般是无关的，这个无关体现在两个方面：\n\n1. 对于表中存储的**属性**，其排列顺序无关。即$(A_1, A_2,..., A_n) = (A_2, A_1,..., A_n)$\n2. 对于表中存储的**数据**，其排列顺序无关。\n\n**数据库架构**(Database schema)是数据库的逻辑结构\n**数据库实例**(Database instance)是数据库中某一特定时刻的数据快照(snapshot)。\n\n举例如下:\n\n- 数据库架构：instructor (ID, name, dept_name, salary)\n- 数据库示例：![数据库实例](/img/数据库(4)/数据库实例.png)\n\n\n### 关系型数据库的键\n\n关系型数据库中存在一些特殊的键，包括有主键、侯选键和外键\n\n- **主键**是用于唯一标识表中每一条记录的一个或多个属性（列）的组合。主键的值必须是唯一的，并且不能为空（即 NOT NULL）\n  - **唯一性**：每个主键值在表中必须是唯一的，不能重复。\n  - **非空性**：主键列不能包含 NULL 值，确保每条记录都有一个有效的标识。\n  - **稳定性**：主键的值应尽量保持不变，以避免数据引用混乱。\n- **候选键**是能够唯一标识表中每一条记录的一组最小属性（列）。换句话说，候选键是没有冗余属性的候选集，每个候选键都是一个潜在的主键。\n  - **最小性**：候选键中的每个属性都是必需的，去掉任何一个属性后，该组合就不再具有唯一性。\n  - **多样性**：一个表中可能存在多个候选键，但最终只能选择其中一个作为主键。\n\n- **外键**是依附于其他表的键，其本身会根据其他表中相应键的变化产生变化\n  - **参照完整性**：外键的值必须存在于被引用表的主键或唯一键中，或者可以是 NULL（如果允许）。\n  - **约束行为**：当被引用表中的数据发生变化（如删除或更新）时，可以通过定义外键约束的行为（如级联删除、级联更新）来自动处理相关联的数据。\n  - 数据库表之间存在外键关系，导入数据时，先导入被参照关系 r2 (department) 中的数据，再导入参照关系 r1 (instructor) 中的数据。\n  - 任何在参照关系 r1（instructor）中的外键属性（dept_name）出现的值，必须至少在被参照关系 r2（department）的某个元组的属性中存在。\n\n参考数据库模式图\n![模式图](/img/数据库(4)/模式图.png)\n\n外键在模式图中的表示如下图所示\n![外键模式图](/img/数据库(4)/外键模式图.png)\n\n## 关系模型操作(关系代数)\n\n### Pure Languages\n\n在关系型数据库中，有几种语言其在表达能力上是等价的，其中包括：\n\n1. 关系代数（Relational Algebra）\n2. 元组关系演算（Tuple Relational Calculus）\n3. 域关系演算（Domain Relational Calculus）\n上述纯粹的语言具有相同的表达能力，能够完成相同类型的数据查询操作。其中关系代数是关系数据库查询和操作的基础。\n\n### 关系代数的基本操作\n\n系代数作为一种过程式语言，包含六个基本操作。这些操作是构建复杂查询的基础:\n\n- Selection         $\\sigma$\n- projection        $\\Pi$\n- Cartesian Product $\\times$\n- Union             $\\cup$\n- Set Difference    $-$\n- Rename            $\\rho$\n\n![代数关系式](/img/数据库(4)/代数关系式.png)\n\n### 代数关系和数据库语言的等价操作\n\n#### Select and Project Operation\n\n对于代数关系式\n$$\\sigma_p(r)$$\n等价于数据库语言\n$$ Select * From r Where p $$\n其中对于条件筛选部分可以包括大量的的不等式以及逻辑联系符。\n\n- 比较 $ A = B、A \\neq B、A > B、A < B、A \\geq B、A \\leq B$\n- 逻辑联系符 $A \\land B、A \\lor B、\\lnot A$\n\n> **Example**\n> $\\sigma_{dept_name = \"Physics\" \\land salary > 90000 } (instructor)$\n> $\\sigma_{dept_name=building}  (department)$\n\n对于代数关系式\n$$\\Pi_{A_1,A_2,...,A_N}(r)$$\n等价于\n$$Select A_1,A_2,...,A_N From r $$\n\n> **Example**\n> $$\\Pi_{dept\\_name} (\\sigma_{dept\\_name=\"Physics\"}(instructor))$$\n\n#### Cartesian-Product and Join Operation\n\n$$ A \\times B $$\n等价于\n$$ Select * From  A,B $$\n\n这个过程中的本质上是实现了笛卡尔积，A中的每一行都会于B中的每一行进行相应的合并，区别于`Join`的操作，这个操作不会合并同名相等的属性，而是分别在新产生的表中列出。形如下表格\n\n| A.id | A.name | B.id | B.course |\n|------|--------|------|----------|\n| 1    | Alice  | 101  | Math     |\n| 1    | Alice  | 102  | Physics  |\n| 2    | Bob    | 101  | Math     |\n| 2    | Bob    | 102  | Physics  |\n\n对于`Join`操作\n$$ A \\bowtie_{\\theta} B $$\n等价于\n$$ \\sigma_{\\theta}(A \\times B) $$\n\n> **Example**\n> $$\\sigma_{instructor.id=teacher.id}(instructor \\times teacher)$$\n> equal to\n> $$instructor \\bowtie_{instructor.id=teacher.id} teacher$$\n>\n#### Union、 Set-Intersection and Set-Difference Operation(交并集组合)\n\n对于`Union`操作执行的表`r`和`s`，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。\n> **Example**\n> Find all courses taught in the Fall 2017 semester, or in the Spring2018 semester, or in both\n> \n> $$\\Pi_{course\\_id}(\\sigma_{semester=\"Fall\" \\land year=2017}) \\cup \\Pi_{course\\_id}(\\sigma_{semester=\"Spring\" \\land year=2018})$$\n\n\n对于`Set-Intersection`操作执行的表`r`和`s`，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。\n\n> **Example**\n> Find all courses taught in both Fall 2017 and Spring 2018 semesters\n>\n> $$\\Pi_{course\\_id}(\\sigma_{semester=\"Fall\" \\land year=2017}) \\cap \\Pi_{course\\_id}(\\sigma_{semester=\"Spring\" \\land year=2018})$$\n\n\n对于`Set-Difference`操作执行的表`r`和`s`，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。\n\n> **Example**\n> find all courses taught in Fall 2017, but not in Spring 2018 \n> $$\\Pi_{course\\_id}(\\sigma_{semester=\"Fall\" \\land year=2017}) - \\Pi_{course\\_id}(\\sigma_{semester=\"Spring\" \\land year=2018})$$\n\n#### Assignment  Operation(赋予操作)\n\n在关系代数中，赋值操作用于将一个关系表达式的结果赋值给一个临时的关系名。这类似于编程语言中的变量赋值，允许你为复杂的查询步骤定义中间结果，以提高查询的可读性和可维护性。\n\n> **Example**\n> Find all instructor in Physics and Music department.\n> $$ Physics \\leftarrow \\sigma_{dept\\_name=\"Physics\"}(instructor)$$\n> $$ Music   \\leftarrow \\sigma_{dept\\_name=\"Music\"}(instructor)$$\n> $$ Physics \\cup Music $$\n\n#### Rename Operation\n\n对于重命名有两种使用方法。\n\n**基本形式**\n$$\\rho_x(E)$$\n将关系代数表达式𝐸的结果集赋予一个新的名称𝑥。\n\n**带属性重命名的操作**\n$$\\rho_{x(A_1,A_2,...,A_n)}(E)$$\n将关系代数表达式𝐸的结果集赋予一个新的名称𝑥并且将其中的各个属性重名为为$A_1,A_2,...,A_n$。\n\n#### 等价\n\n在代数关系表达式中存在等价关系。两个表达式或许内容不同，但是其表达的含义相同，具有等价关系。\n\n> **Example_1**\n> Find courses taught by instructors in Physics with salary greater than 90,000\n> $$\\sigma_{dept\\_name=\"Physics\" \\land salary>90000}(instructor)$$\n> $$\\sigma_{dept\\_name=\"Physics}(\\sigma_{salary>90000}(instructor))$$\n>\n> **Example_2**\n> Find courses taught by instructors in Physics\n> $$\\sigma_{dept\\_name=\"Physics\"}(instructor \\bowtie_{instructor.ID = teaches.ID}teacher)$$\n> $$(\\sigma_{dept\\_name=\"Physics\"}(instructor)) \\bowtie_{instructor.ID=teacher.ID}teacher$$\n","source":"_posts/数据库-4.md","raw":"---\ntitle: 数据库(4)\ndate: 2024-12-20 09:55:54\ntags:\n    - 学习笔记\n    - 数据库\n---\n\n## 关系型数据库的结构(语法)\n\n### 关系型数据库基础介绍\n\n关系型数据库由一系列表的集合组成。对于关系模型：\n\n- $A_1, A_2,..., A_n$为模型中的属性\n- $D_1, D_2,..., D_n$为模型中属性的域，即对于每个属性允许的取值。\n  - 属性的域是一系列允许的值的集合\n  - 属性值通常是原子的，即不可再分的，符合第一范式（1NF）\n  - 特殊值`NULL`是每个域的成员，表示该值未知。但是`NULL`的操作可能会导致一些未知错误，比如索引失败\n- $R=(A_1, A_2,..., A_n)$是关系模式(relation schema)\n- 关系实例`r`在模式`R`上的定义表示为$r(R)$\n- 其当前的值由表指定\n- 对于关系实例`r`的的一个元素`t`被称为元组(tuple)，用表中的一行表示\n  \n或许感觉对于`r`、`R`和`t`的关系有一定的不明确。简单的来说，`R`定义了一个表的结构，`r`是对于表结构`R`的具体实现，而`t`是`r`中的一个元素，也就是表中的一条数据。\n\n对于关系顺序一般是无关的，这个无关体现在两个方面：\n\n1. 对于表中存储的**属性**，其排列顺序无关。即$(A_1, A_2,..., A_n) = (A_2, A_1,..., A_n)$\n2. 对于表中存储的**数据**，其排列顺序无关。\n\n**数据库架构**(Database schema)是数据库的逻辑结构\n**数据库实例**(Database instance)是数据库中某一特定时刻的数据快照(snapshot)。\n\n举例如下:\n\n- 数据库架构：instructor (ID, name, dept_name, salary)\n- 数据库示例：![数据库实例](/img/数据库(4)/数据库实例.png)\n\n\n### 关系型数据库的键\n\n关系型数据库中存在一些特殊的键，包括有主键、侯选键和外键\n\n- **主键**是用于唯一标识表中每一条记录的一个或多个属性（列）的组合。主键的值必须是唯一的，并且不能为空（即 NOT NULL）\n  - **唯一性**：每个主键值在表中必须是唯一的，不能重复。\n  - **非空性**：主键列不能包含 NULL 值，确保每条记录都有一个有效的标识。\n  - **稳定性**：主键的值应尽量保持不变，以避免数据引用混乱。\n- **候选键**是能够唯一标识表中每一条记录的一组最小属性（列）。换句话说，候选键是没有冗余属性的候选集，每个候选键都是一个潜在的主键。\n  - **最小性**：候选键中的每个属性都是必需的，去掉任何一个属性后，该组合就不再具有唯一性。\n  - **多样性**：一个表中可能存在多个候选键，但最终只能选择其中一个作为主键。\n\n- **外键**是依附于其他表的键，其本身会根据其他表中相应键的变化产生变化\n  - **参照完整性**：外键的值必须存在于被引用表的主键或唯一键中，或者可以是 NULL（如果允许）。\n  - **约束行为**：当被引用表中的数据发生变化（如删除或更新）时，可以通过定义外键约束的行为（如级联删除、级联更新）来自动处理相关联的数据。\n  - 数据库表之间存在外键关系，导入数据时，先导入被参照关系 r2 (department) 中的数据，再导入参照关系 r1 (instructor) 中的数据。\n  - 任何在参照关系 r1（instructor）中的外键属性（dept_name）出现的值，必须至少在被参照关系 r2（department）的某个元组的属性中存在。\n\n参考数据库模式图\n![模式图](/img/数据库(4)/模式图.png)\n\n外键在模式图中的表示如下图所示\n![外键模式图](/img/数据库(4)/外键模式图.png)\n\n## 关系模型操作(关系代数)\n\n### Pure Languages\n\n在关系型数据库中，有几种语言其在表达能力上是等价的，其中包括：\n\n1. 关系代数（Relational Algebra）\n2. 元组关系演算（Tuple Relational Calculus）\n3. 域关系演算（Domain Relational Calculus）\n上述纯粹的语言具有相同的表达能力，能够完成相同类型的数据查询操作。其中关系代数是关系数据库查询和操作的基础。\n\n### 关系代数的基本操作\n\n系代数作为一种过程式语言，包含六个基本操作。这些操作是构建复杂查询的基础:\n\n- Selection         $\\sigma$\n- projection        $\\Pi$\n- Cartesian Product $\\times$\n- Union             $\\cup$\n- Set Difference    $-$\n- Rename            $\\rho$\n\n![代数关系式](/img/数据库(4)/代数关系式.png)\n\n### 代数关系和数据库语言的等价操作\n\n#### Select and Project Operation\n\n对于代数关系式\n$$\\sigma_p(r)$$\n等价于数据库语言\n$$ Select * From r Where p $$\n其中对于条件筛选部分可以包括大量的的不等式以及逻辑联系符。\n\n- 比较 $ A = B、A \\neq B、A > B、A < B、A \\geq B、A \\leq B$\n- 逻辑联系符 $A \\land B、A \\lor B、\\lnot A$\n\n> **Example**\n> $\\sigma_{dept_name = \"Physics\" \\land salary > 90000 } (instructor)$\n> $\\sigma_{dept_name=building}  (department)$\n\n对于代数关系式\n$$\\Pi_{A_1,A_2,...,A_N}(r)$$\n等价于\n$$Select A_1,A_2,...,A_N From r $$\n\n> **Example**\n> $$\\Pi_{dept\\_name} (\\sigma_{dept\\_name=\"Physics\"}(instructor))$$\n\n#### Cartesian-Product and Join Operation\n\n$$ A \\times B $$\n等价于\n$$ Select * From  A,B $$\n\n这个过程中的本质上是实现了笛卡尔积，A中的每一行都会于B中的每一行进行相应的合并，区别于`Join`的操作，这个操作不会合并同名相等的属性，而是分别在新产生的表中列出。形如下表格\n\n| A.id | A.name | B.id | B.course |\n|------|--------|------|----------|\n| 1    | Alice  | 101  | Math     |\n| 1    | Alice  | 102  | Physics  |\n| 2    | Bob    | 101  | Math     |\n| 2    | Bob    | 102  | Physics  |\n\n对于`Join`操作\n$$ A \\bowtie_{\\theta} B $$\n等价于\n$$ \\sigma_{\\theta}(A \\times B) $$\n\n> **Example**\n> $$\\sigma_{instructor.id=teacher.id}(instructor \\times teacher)$$\n> equal to\n> $$instructor \\bowtie_{instructor.id=teacher.id} teacher$$\n>\n#### Union、 Set-Intersection and Set-Difference Operation(交并集组合)\n\n对于`Union`操作执行的表`r`和`s`，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。\n> **Example**\n> Find all courses taught in the Fall 2017 semester, or in the Spring2018 semester, or in both\n> \n> $$\\Pi_{course\\_id}(\\sigma_{semester=\"Fall\" \\land year=2017}) \\cup \\Pi_{course\\_id}(\\sigma_{semester=\"Spring\" \\land year=2018})$$\n\n\n对于`Set-Intersection`操作执行的表`r`和`s`，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。\n\n> **Example**\n> Find all courses taught in both Fall 2017 and Spring 2018 semesters\n>\n> $$\\Pi_{course\\_id}(\\sigma_{semester=\"Fall\" \\land year=2017}) \\cap \\Pi_{course\\_id}(\\sigma_{semester=\"Spring\" \\land year=2018})$$\n\n\n对于`Set-Difference`操作执行的表`r`和`s`，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。\n\n> **Example**\n> find all courses taught in Fall 2017, but not in Spring 2018 \n> $$\\Pi_{course\\_id}(\\sigma_{semester=\"Fall\" \\land year=2017}) - \\Pi_{course\\_id}(\\sigma_{semester=\"Spring\" \\land year=2018})$$\n\n#### Assignment  Operation(赋予操作)\n\n在关系代数中，赋值操作用于将一个关系表达式的结果赋值给一个临时的关系名。这类似于编程语言中的变量赋值，允许你为复杂的查询步骤定义中间结果，以提高查询的可读性和可维护性。\n\n> **Example**\n> Find all instructor in Physics and Music department.\n> $$ Physics \\leftarrow \\sigma_{dept\\_name=\"Physics\"}(instructor)$$\n> $$ Music   \\leftarrow \\sigma_{dept\\_name=\"Music\"}(instructor)$$\n> $$ Physics \\cup Music $$\n\n#### Rename Operation\n\n对于重命名有两种使用方法。\n\n**基本形式**\n$$\\rho_x(E)$$\n将关系代数表达式𝐸的结果集赋予一个新的名称𝑥。\n\n**带属性重命名的操作**\n$$\\rho_{x(A_1,A_2,...,A_n)}(E)$$\n将关系代数表达式𝐸的结果集赋予一个新的名称𝑥并且将其中的各个属性重名为为$A_1,A_2,...,A_n$。\n\n#### 等价\n\n在代数关系表达式中存在等价关系。两个表达式或许内容不同，但是其表达的含义相同，具有等价关系。\n\n> **Example_1**\n> Find courses taught by instructors in Physics with salary greater than 90,000\n> $$\\sigma_{dept\\_name=\"Physics\" \\land salary>90000}(instructor)$$\n> $$\\sigma_{dept\\_name=\"Physics}(\\sigma_{salary>90000}(instructor))$$\n>\n> **Example_2**\n> Find courses taught by instructors in Physics\n> $$\\sigma_{dept\\_name=\"Physics\"}(instructor \\bowtie_{instructor.ID = teaches.ID}teacher)$$\n> $$(\\sigma_{dept\\_name=\"Physics\"}(instructor)) \\bowtie_{instructor.ID=teacher.ID}teacher$$\n","slug":"数据库-4","published":1,"updated":"2024-12-23T01:08:42.460Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot6000b6d6eg5a2fyu0","content":"<h2 id=\"关系型数据库的结构-语法\"><a href=\"#关系型数据库的结构-语法\" class=\"headerlink\" title=\"关系型数据库的结构(语法)\"></a>关系型数据库的结构(语法)</h2><h3 id=\"关系型数据库基础介绍\"><a href=\"#关系型数据库基础介绍\" class=\"headerlink\" title=\"关系型数据库基础介绍\"></a>关系型数据库基础介绍</h3><p>关系型数据库由一系列表的集合组成。对于关系模型：</p>\n<ul>\n<li>$A_1, A_2,…, A_n$为模型中的属性</li>\n<li>$D_1, D_2,…, D_n$为模型中属性的域，即对于每个属性允许的取值。<ul>\n<li>属性的域是一系列允许的值的集合</li>\n<li>属性值通常是原子的，即不可再分的，符合第一范式（1NF）</li>\n<li>特殊值<code>NULL</code>是每个域的成员，表示该值未知。但是<code>NULL</code>的操作可能会导致一些未知错误，比如索引失败</li>\n</ul>\n</li>\n<li>$R&#x3D;(A_1, A_2,…, A_n)$是关系模式(relation schema)</li>\n<li>关系实例<code>r</code>在模式<code>R</code>上的定义表示为$r(R)$</li>\n<li>其当前的值由表指定</li>\n<li>对于关系实例<code>r</code>的的一个元素<code>t</code>被称为元组(tuple)，用表中的一行表示</li>\n</ul>\n<p>或许感觉对于<code>r</code>、<code>R</code>和<code>t</code>的关系有一定的不明确。简单的来说，<code>R</code>定义了一个表的结构，<code>r</code>是对于表结构<code>R</code>的具体实现，而<code>t</code>是<code>r</code>中的一个元素，也就是表中的一条数据。</p>\n<p>对于关系顺序一般是无关的，这个无关体现在两个方面：</p>\n<ol>\n<li>对于表中存储的<strong>属性</strong>，其排列顺序无关。即$(A_1, A_2,…, A_n) &#x3D; (A_2, A_1,…, A_n)$</li>\n<li>对于表中存储的<strong>数据</strong>，其排列顺序无关。</li>\n</ol>\n<p><strong>数据库架构</strong>(Database schema)是数据库的逻辑结构<br><strong>数据库实例</strong>(Database instance)是数据库中某一特定时刻的数据快照(snapshot)。</p>\n<p>举例如下:</p>\n<ul>\n<li>数据库架构：instructor (ID, name, dept_name, salary)</li>\n<li>数据库示例：<img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(4)/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B.png\" alt=\"数据库实例\"></li>\n</ul>\n<h3 id=\"关系型数据库的键\"><a href=\"#关系型数据库的键\" class=\"headerlink\" title=\"关系型数据库的键\"></a>关系型数据库的键</h3><p>关系型数据库中存在一些特殊的键，包括有主键、侯选键和外键</p>\n<ul>\n<li><p><strong>主键</strong>是用于唯一标识表中每一条记录的一个或多个属性（列）的组合。主键的值必须是唯一的，并且不能为空（即 NOT NULL）</p>\n<ul>\n<li><strong>唯一性</strong>：每个主键值在表中必须是唯一的，不能重复。</li>\n<li><strong>非空性</strong>：主键列不能包含 NULL 值，确保每条记录都有一个有效的标识。</li>\n<li><strong>稳定性</strong>：主键的值应尽量保持不变，以避免数据引用混乱。</li>\n</ul>\n</li>\n<li><p><strong>候选键</strong>是能够唯一标识表中每一条记录的一组最小属性（列）。换句话说，候选键是没有冗余属性的候选集，每个候选键都是一个潜在的主键。</p>\n<ul>\n<li><strong>最小性</strong>：候选键中的每个属性都是必需的，去掉任何一个属性后，该组合就不再具有唯一性。</li>\n<li><strong>多样性</strong>：一个表中可能存在多个候选键，但最终只能选择其中一个作为主键。</li>\n</ul>\n</li>\n<li><p><strong>外键</strong>是依附于其他表的键，其本身会根据其他表中相应键的变化产生变化</p>\n<ul>\n<li><strong>参照完整性</strong>：外键的值必须存在于被引用表的主键或唯一键中，或者可以是 NULL（如果允许）。</li>\n<li><strong>约束行为</strong>：当被引用表中的数据发生变化（如删除或更新）时，可以通过定义外键约束的行为（如级联删除、级联更新）来自动处理相关联的数据。</li>\n<li>数据库表之间存在外键关系，导入数据时，先导入被参照关系 r2 (department) 中的数据，再导入参照关系 r1 (instructor) 中的数据。</li>\n<li>任何在参照关系 r1（instructor）中的外键属性（dept_name）出现的值，必须至少在被参照关系 r2（department）的某个元组的属性中存在。</li>\n</ul>\n</li>\n</ul>\n<p>参考数据库模式图<br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(4)/%E6%A8%A1%E5%BC%8F%E5%9B%BE.png\" alt=\"模式图\"></p>\n<p>外键在模式图中的表示如下图所示<br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(4)/%E5%A4%96%E9%94%AE%E6%A8%A1%E5%BC%8F%E5%9B%BE.png\" alt=\"外键模式图\"></p>\n<h2 id=\"关系模型操作-关系代数\"><a href=\"#关系模型操作-关系代数\" class=\"headerlink\" title=\"关系模型操作(关系代数)\"></a>关系模型操作(关系代数)</h2><h3 id=\"Pure-Languages\"><a href=\"#Pure-Languages\" class=\"headerlink\" title=\"Pure Languages\"></a>Pure Languages</h3><p>在关系型数据库中，有几种语言其在表达能力上是等价的，其中包括：</p>\n<ol>\n<li>关系代数（Relational Algebra）</li>\n<li>元组关系演算（Tuple Relational Calculus）</li>\n<li>域关系演算（Domain Relational Calculus）<br>上述纯粹的语言具有相同的表达能力，能够完成相同类型的数据查询操作。其中关系代数是关系数据库查询和操作的基础。</li>\n</ol>\n<h3 id=\"关系代数的基本操作\"><a href=\"#关系代数的基本操作\" class=\"headerlink\" title=\"关系代数的基本操作\"></a>关系代数的基本操作</h3><p>系代数作为一种过程式语言，包含六个基本操作。这些操作是构建复杂查询的基础:</p>\n<ul>\n<li>Selection         $\\sigma$</li>\n<li>projection        $\\Pi$</li>\n<li>Cartesian Product $\\times$</li>\n<li>Union             $\\cup$</li>\n<li>Set Difference    $-$</li>\n<li>Rename            $\\rho$</li>\n</ul>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(4)/%E4%BB%A3%E6%95%B0%E5%85%B3%E7%B3%BB%E5%BC%8F.png\" alt=\"代数关系式\"></p>\n<h3 id=\"代数关系和数据库语言的等价操作\"><a href=\"#代数关系和数据库语言的等价操作\" class=\"headerlink\" title=\"代数关系和数据库语言的等价操作\"></a>代数关系和数据库语言的等价操作</h3><h4 id=\"Select-and-Project-Operation\"><a href=\"#Select-and-Project-Operation\" class=\"headerlink\" title=\"Select and Project Operation\"></a>Select and Project Operation</h4><p>对于代数关系式<br>$$\\sigma_p(r)$$<br>等价于数据库语言<br>$$ Select * From r Where p $$<br>其中对于条件筛选部分可以包括大量的的不等式以及逻辑联系符。</p>\n<ul>\n<li>比较 $ A &#x3D; B、A \\neq B、A &gt; B、A &lt; B、A \\geq B、A \\leq B$</li>\n<li>逻辑联系符 $A \\land B、A \\lor B、\\lnot A$</li>\n</ul>\n<blockquote>\n<p><strong>Example</strong><br>$\\sigma_{dept_name &#x3D; “Physics” \\land salary &gt; 90000 } (instructor)$<br>$\\sigma_{dept_name&#x3D;building}  (department)$</p>\n</blockquote>\n<p>对于代数关系式<br>$$\\Pi_{A_1,A_2,…,A_N}(r)$$<br>等价于<br>$$Select A_1,A_2,…,A_N From r $$</p>\n<blockquote>\n<p><strong>Example</strong><br>$$\\Pi_{dept_name} (\\sigma_{dept_name&#x3D;”Physics”}(instructor))$$</p>\n</blockquote>\n<h4 id=\"Cartesian-Product-and-Join-Operation\"><a href=\"#Cartesian-Product-and-Join-Operation\" class=\"headerlink\" title=\"Cartesian-Product and Join Operation\"></a>Cartesian-Product and Join Operation</h4><p>$$ A \\times B $$<br>等价于<br>$$ Select * From  A,B $$</p>\n<p>这个过程中的本质上是实现了笛卡尔积，A中的每一行都会于B中的每一行进行相应的合并，区别于<code>Join</code>的操作，这个操作不会合并同名相等的属性，而是分别在新产生的表中列出。形如下表格</p>\n<table>\n<thead>\n<tr>\n<th>A.id</th>\n<th>A.name</th>\n<th>B.id</th>\n<th>B.course</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Alice</td>\n<td>101</td>\n<td>Math</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Alice</td>\n<td>102</td>\n<td>Physics</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Bob</td>\n<td>101</td>\n<td>Math</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Bob</td>\n<td>102</td>\n<td>Physics</td>\n</tr>\n</tbody></table>\n<p>对于<code>Join</code>操作<br>$$ A \\bowtie_{\\theta} B $$<br>等价于<br>$$ \\sigma_{\\theta}(A \\times B) $$</p>\n<blockquote>\n<p><strong>Example</strong><br>$$\\sigma_{instructor.id&#x3D;teacher.id}(instructor \\times teacher)$$<br>equal to<br>$$instructor \\bowtie_{instructor.id&#x3D;teacher.id} teacher$$</p>\n</blockquote>\n<h4 id=\"Union、-Set-Intersection-and-Set-Difference-Operation-交并集组合\"><a href=\"#Union、-Set-Intersection-and-Set-Difference-Operation-交并集组合\" class=\"headerlink\" title=\"Union、 Set-Intersection and Set-Difference Operation(交并集组合)\"></a>Union、 Set-Intersection and Set-Difference Operation(交并集组合)</h4><p>对于<code>Union</code>操作执行的表<code>r</code>和<code>s</code>，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。</p>\n<blockquote>\n<p><strong>Example</strong><br>Find all courses taught in the Fall 2017 semester, or in the Spring2018 semester, or in both</p>\n<p>$$\\Pi_{course_id}(\\sigma_{semester&#x3D;”Fall” \\land year&#x3D;2017}) \\cup \\Pi_{course_id}(\\sigma_{semester&#x3D;”Spring” \\land year&#x3D;2018})$$</p>\n</blockquote>\n<p>对于<code>Set-Intersection</code>操作执行的表<code>r</code>和<code>s</code>，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。</p>\n<blockquote>\n<p><strong>Example</strong><br>Find all courses taught in both Fall 2017 and Spring 2018 semesters</p>\n<p>$$\\Pi_{course_id}(\\sigma_{semester&#x3D;”Fall” \\land year&#x3D;2017}) \\cap \\Pi_{course_id}(\\sigma_{semester&#x3D;”Spring” \\land year&#x3D;2018})$$</p>\n</blockquote>\n<p>对于<code>Set-Difference</code>操作执行的表<code>r</code>和<code>s</code>，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。</p>\n<blockquote>\n<p><strong>Example</strong><br>find all courses taught in Fall 2017, but not in Spring 2018<br>$$\\Pi_{course_id}(\\sigma_{semester&#x3D;”Fall” \\land year&#x3D;2017}) - \\Pi_{course_id}(\\sigma_{semester&#x3D;”Spring” \\land year&#x3D;2018})$$</p>\n</blockquote>\n<h4 id=\"Assignment-Operation-赋予操作\"><a href=\"#Assignment-Operation-赋予操作\" class=\"headerlink\" title=\"Assignment  Operation(赋予操作)\"></a>Assignment  Operation(赋予操作)</h4><p>在关系代数中，赋值操作用于将一个关系表达式的结果赋值给一个临时的关系名。这类似于编程语言中的变量赋值，允许你为复杂的查询步骤定义中间结果，以提高查询的可读性和可维护性。</p>\n<blockquote>\n<p><strong>Example</strong><br>Find all instructor in Physics and Music department.<br>$$ Physics \\leftarrow \\sigma_{dept_name&#x3D;”Physics”}(instructor)$$<br>$$ Music   \\leftarrow \\sigma_{dept_name&#x3D;”Music”}(instructor)$$<br>$$ Physics \\cup Music $$</p>\n</blockquote>\n<h4 id=\"Rename-Operation\"><a href=\"#Rename-Operation\" class=\"headerlink\" title=\"Rename Operation\"></a>Rename Operation</h4><p>对于重命名有两种使用方法。</p>\n<p><strong>基本形式</strong><br>$$\\rho_x(E)$$<br>将关系代数表达式𝐸的结果集赋予一个新的名称𝑥。</p>\n<p><strong>带属性重命名的操作</strong><br>$$\\rho_{x(A_1,A_2,…,A_n)}(E)$$<br>将关系代数表达式𝐸的结果集赋予一个新的名称𝑥并且将其中的各个属性重名为为$A_1,A_2,…,A_n$。</p>\n<h4 id=\"等价\"><a href=\"#等价\" class=\"headerlink\" title=\"等价\"></a>等价</h4><p>在代数关系表达式中存在等价关系。两个表达式或许内容不同，但是其表达的含义相同，具有等价关系。</p>\n<blockquote>\n<p><strong>Example_1</strong><br>Find courses taught by instructors in Physics with salary greater than 90,000<br>$$\\sigma_{dept_name&#x3D;”Physics” \\land salary&gt;90000}(instructor)$$<br>$$\\sigma_{dept_name&#x3D;”Physics}(\\sigma_{salary&gt;90000}(instructor))$$</p>\n<p><strong>Example_2</strong><br>Find courses taught by instructors in Physics<br>$$\\sigma_{dept_name&#x3D;”Physics”}(instructor \\bowtie_{instructor.ID &#x3D; teaches.ID}teacher)$$<br>$$(\\sigma_{dept_name&#x3D;”Physics”}(instructor)) \\bowtie_{instructor.ID&#x3D;teacher.ID}teacher$$</p>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"关系型数据库的结构-语法\"><a href=\"#关系型数据库的结构-语法\" class=\"headerlink\" title=\"关系型数据库的结构(语法)\"></a>关系型数据库的结构(语法)</h2><h3 id=\"关系型数据库基础介绍\"><a href=\"#关系型数据库基础介绍\" class=\"headerlink\" title=\"关系型数据库基础介绍\"></a>关系型数据库基础介绍</h3><p>关系型数据库由一系列表的集合组成。对于关系模型：</p>\n<ul>\n<li>$A_1, A_2,…, A_n$为模型中的属性</li>\n<li>$D_1, D_2,…, D_n$为模型中属性的域，即对于每个属性允许的取值。<ul>\n<li>属性的域是一系列允许的值的集合</li>\n<li>属性值通常是原子的，即不可再分的，符合第一范式（1NF）</li>\n<li>特殊值<code>NULL</code>是每个域的成员，表示该值未知。但是<code>NULL</code>的操作可能会导致一些未知错误，比如索引失败</li>\n</ul>\n</li>\n<li>$R&#x3D;(A_1, A_2,…, A_n)$是关系模式(relation schema)</li>\n<li>关系实例<code>r</code>在模式<code>R</code>上的定义表示为$r(R)$</li>\n<li>其当前的值由表指定</li>\n<li>对于关系实例<code>r</code>的的一个元素<code>t</code>被称为元组(tuple)，用表中的一行表示</li>\n</ul>\n<p>或许感觉对于<code>r</code>、<code>R</code>和<code>t</code>的关系有一定的不明确。简单的来说，<code>R</code>定义了一个表的结构，<code>r</code>是对于表结构<code>R</code>的具体实现，而<code>t</code>是<code>r</code>中的一个元素，也就是表中的一条数据。</p>\n<p>对于关系顺序一般是无关的，这个无关体现在两个方面：</p>\n<ol>\n<li>对于表中存储的<strong>属性</strong>，其排列顺序无关。即$(A_1, A_2,…, A_n) &#x3D; (A_2, A_1,…, A_n)$</li>\n<li>对于表中存储的<strong>数据</strong>，其排列顺序无关。</li>\n</ol>\n<p><strong>数据库架构</strong>(Database schema)是数据库的逻辑结构<br><strong>数据库实例</strong>(Database instance)是数据库中某一特定时刻的数据快照(snapshot)。</p>\n<p>举例如下:</p>\n<ul>\n<li>数据库架构：instructor (ID, name, dept_name, salary)</li>\n<li>数据库示例：<img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(4)/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B.png\" alt=\"数据库实例\"></li>\n</ul>\n<h3 id=\"关系型数据库的键\"><a href=\"#关系型数据库的键\" class=\"headerlink\" title=\"关系型数据库的键\"></a>关系型数据库的键</h3><p>关系型数据库中存在一些特殊的键，包括有主键、侯选键和外键</p>\n<ul>\n<li><p><strong>主键</strong>是用于唯一标识表中每一条记录的一个或多个属性（列）的组合。主键的值必须是唯一的，并且不能为空（即 NOT NULL）</p>\n<ul>\n<li><strong>唯一性</strong>：每个主键值在表中必须是唯一的，不能重复。</li>\n<li><strong>非空性</strong>：主键列不能包含 NULL 值，确保每条记录都有一个有效的标识。</li>\n<li><strong>稳定性</strong>：主键的值应尽量保持不变，以避免数据引用混乱。</li>\n</ul>\n</li>\n<li><p><strong>候选键</strong>是能够唯一标识表中每一条记录的一组最小属性（列）。换句话说，候选键是没有冗余属性的候选集，每个候选键都是一个潜在的主键。</p>\n<ul>\n<li><strong>最小性</strong>：候选键中的每个属性都是必需的，去掉任何一个属性后，该组合就不再具有唯一性。</li>\n<li><strong>多样性</strong>：一个表中可能存在多个候选键，但最终只能选择其中一个作为主键。</li>\n</ul>\n</li>\n<li><p><strong>外键</strong>是依附于其他表的键，其本身会根据其他表中相应键的变化产生变化</p>\n<ul>\n<li><strong>参照完整性</strong>：外键的值必须存在于被引用表的主键或唯一键中，或者可以是 NULL（如果允许）。</li>\n<li><strong>约束行为</strong>：当被引用表中的数据发生变化（如删除或更新）时，可以通过定义外键约束的行为（如级联删除、级联更新）来自动处理相关联的数据。</li>\n<li>数据库表之间存在外键关系，导入数据时，先导入被参照关系 r2 (department) 中的数据，再导入参照关系 r1 (instructor) 中的数据。</li>\n<li>任何在参照关系 r1（instructor）中的外键属性（dept_name）出现的值，必须至少在被参照关系 r2（department）的某个元组的属性中存在。</li>\n</ul>\n</li>\n</ul>\n<p>参考数据库模式图<br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(4)/%E6%A8%A1%E5%BC%8F%E5%9B%BE.png\" alt=\"模式图\"></p>\n<p>外键在模式图中的表示如下图所示<br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(4)/%E5%A4%96%E9%94%AE%E6%A8%A1%E5%BC%8F%E5%9B%BE.png\" alt=\"外键模式图\"></p>\n<h2 id=\"关系模型操作-关系代数\"><a href=\"#关系模型操作-关系代数\" class=\"headerlink\" title=\"关系模型操作(关系代数)\"></a>关系模型操作(关系代数)</h2><h3 id=\"Pure-Languages\"><a href=\"#Pure-Languages\" class=\"headerlink\" title=\"Pure Languages\"></a>Pure Languages</h3><p>在关系型数据库中，有几种语言其在表达能力上是等价的，其中包括：</p>\n<ol>\n<li>关系代数（Relational Algebra）</li>\n<li>元组关系演算（Tuple Relational Calculus）</li>\n<li>域关系演算（Domain Relational Calculus）<br>上述纯粹的语言具有相同的表达能力，能够完成相同类型的数据查询操作。其中关系代数是关系数据库查询和操作的基础。</li>\n</ol>\n<h3 id=\"关系代数的基本操作\"><a href=\"#关系代数的基本操作\" class=\"headerlink\" title=\"关系代数的基本操作\"></a>关系代数的基本操作</h3><p>系代数作为一种过程式语言，包含六个基本操作。这些操作是构建复杂查询的基础:</p>\n<ul>\n<li>Selection         $\\sigma$</li>\n<li>projection        $\\Pi$</li>\n<li>Cartesian Product $\\times$</li>\n<li>Union             $\\cup$</li>\n<li>Set Difference    $-$</li>\n<li>Rename            $\\rho$</li>\n</ul>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(4)/%E4%BB%A3%E6%95%B0%E5%85%B3%E7%B3%BB%E5%BC%8F.png\" alt=\"代数关系式\"></p>\n<h3 id=\"代数关系和数据库语言的等价操作\"><a href=\"#代数关系和数据库语言的等价操作\" class=\"headerlink\" title=\"代数关系和数据库语言的等价操作\"></a>代数关系和数据库语言的等价操作</h3><h4 id=\"Select-and-Project-Operation\"><a href=\"#Select-and-Project-Operation\" class=\"headerlink\" title=\"Select and Project Operation\"></a>Select and Project Operation</h4><p>对于代数关系式<br>$$\\sigma_p(r)$$<br>等价于数据库语言<br>$$ Select * From r Where p $$<br>其中对于条件筛选部分可以包括大量的的不等式以及逻辑联系符。</p>\n<ul>\n<li>比较 $ A &#x3D; B、A \\neq B、A &gt; B、A &lt; B、A \\geq B、A \\leq B$</li>\n<li>逻辑联系符 $A \\land B、A \\lor B、\\lnot A$</li>\n</ul>\n<blockquote>\n<p><strong>Example</strong><br>$\\sigma_{dept_name &#x3D; “Physics” \\land salary &gt; 90000 } (instructor)$<br>$\\sigma_{dept_name&#x3D;building}  (department)$</p>\n</blockquote>\n<p>对于代数关系式<br>$$\\Pi_{A_1,A_2,…,A_N}(r)$$<br>等价于<br>$$Select A_1,A_2,…,A_N From r $$</p>\n<blockquote>\n<p><strong>Example</strong><br>$$\\Pi_{dept_name} (\\sigma_{dept_name&#x3D;”Physics”}(instructor))$$</p>\n</blockquote>\n<h4 id=\"Cartesian-Product-and-Join-Operation\"><a href=\"#Cartesian-Product-and-Join-Operation\" class=\"headerlink\" title=\"Cartesian-Product and Join Operation\"></a>Cartesian-Product and Join Operation</h4><p>$$ A \\times B $$<br>等价于<br>$$ Select * From  A,B $$</p>\n<p>这个过程中的本质上是实现了笛卡尔积，A中的每一行都会于B中的每一行进行相应的合并，区别于<code>Join</code>的操作，这个操作不会合并同名相等的属性，而是分别在新产生的表中列出。形如下表格</p>\n<table>\n<thead>\n<tr>\n<th>A.id</th>\n<th>A.name</th>\n<th>B.id</th>\n<th>B.course</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Alice</td>\n<td>101</td>\n<td>Math</td>\n</tr>\n<tr>\n<td>1</td>\n<td>Alice</td>\n<td>102</td>\n<td>Physics</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Bob</td>\n<td>101</td>\n<td>Math</td>\n</tr>\n<tr>\n<td>2</td>\n<td>Bob</td>\n<td>102</td>\n<td>Physics</td>\n</tr>\n</tbody></table>\n<p>对于<code>Join</code>操作<br>$$ A \\bowtie_{\\theta} B $$<br>等价于<br>$$ \\sigma_{\\theta}(A \\times B) $$</p>\n<blockquote>\n<p><strong>Example</strong><br>$$\\sigma_{instructor.id&#x3D;teacher.id}(instructor \\times teacher)$$<br>equal to<br>$$instructor \\bowtie_{instructor.id&#x3D;teacher.id} teacher$$</p>\n</blockquote>\n<h4 id=\"Union、-Set-Intersection-and-Set-Difference-Operation-交并集组合\"><a href=\"#Union、-Set-Intersection-and-Set-Difference-Operation-交并集组合\" class=\"headerlink\" title=\"Union、 Set-Intersection and Set-Difference Operation(交并集组合)\"></a>Union、 Set-Intersection and Set-Difference Operation(交并集组合)</h4><p>对于<code>Union</code>操作执行的表<code>r</code>和<code>s</code>，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。</p>\n<blockquote>\n<p><strong>Example</strong><br>Find all courses taught in the Fall 2017 semester, or in the Spring2018 semester, or in both</p>\n<p>$$\\Pi_{course_id}(\\sigma_{semester&#x3D;”Fall” \\land year&#x3D;2017}) \\cup \\Pi_{course_id}(\\sigma_{semester&#x3D;”Spring” \\land year&#x3D;2018})$$</p>\n</blockquote>\n<p>对于<code>Set-Intersection</code>操作执行的表<code>r</code>和<code>s</code>，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。</p>\n<blockquote>\n<p><strong>Example</strong><br>Find all courses taught in both Fall 2017 and Spring 2018 semesters</p>\n<p>$$\\Pi_{course_id}(\\sigma_{semester&#x3D;”Fall” \\land year&#x3D;2017}) \\cap \\Pi_{course_id}(\\sigma_{semester&#x3D;”Spring” \\land year&#x3D;2018})$$</p>\n</blockquote>\n<p>对于<code>Set-Difference</code>操作执行的表<code>r</code>和<code>s</code>，两者必须有相同的属性数量，而且其值域必须是可并立兼容的。</p>\n<blockquote>\n<p><strong>Example</strong><br>find all courses taught in Fall 2017, but not in Spring 2018<br>$$\\Pi_{course_id}(\\sigma_{semester&#x3D;”Fall” \\land year&#x3D;2017}) - \\Pi_{course_id}(\\sigma_{semester&#x3D;”Spring” \\land year&#x3D;2018})$$</p>\n</blockquote>\n<h4 id=\"Assignment-Operation-赋予操作\"><a href=\"#Assignment-Operation-赋予操作\" class=\"headerlink\" title=\"Assignment  Operation(赋予操作)\"></a>Assignment  Operation(赋予操作)</h4><p>在关系代数中，赋值操作用于将一个关系表达式的结果赋值给一个临时的关系名。这类似于编程语言中的变量赋值，允许你为复杂的查询步骤定义中间结果，以提高查询的可读性和可维护性。</p>\n<blockquote>\n<p><strong>Example</strong><br>Find all instructor in Physics and Music department.<br>$$ Physics \\leftarrow \\sigma_{dept_name&#x3D;”Physics”}(instructor)$$<br>$$ Music   \\leftarrow \\sigma_{dept_name&#x3D;”Music”}(instructor)$$<br>$$ Physics \\cup Music $$</p>\n</blockquote>\n<h4 id=\"Rename-Operation\"><a href=\"#Rename-Operation\" class=\"headerlink\" title=\"Rename Operation\"></a>Rename Operation</h4><p>对于重命名有两种使用方法。</p>\n<p><strong>基本形式</strong><br>$$\\rho_x(E)$$<br>将关系代数表达式𝐸的结果集赋予一个新的名称𝑥。</p>\n<p><strong>带属性重命名的操作</strong><br>$$\\rho_{x(A_1,A_2,…,A_n)}(E)$$<br>将关系代数表达式𝐸的结果集赋予一个新的名称𝑥并且将其中的各个属性重名为为$A_1,A_2,…,A_n$。</p>\n<h4 id=\"等价\"><a href=\"#等价\" class=\"headerlink\" title=\"等价\"></a>等价</h4><p>在代数关系表达式中存在等价关系。两个表达式或许内容不同，但是其表达的含义相同，具有等价关系。</p>\n<blockquote>\n<p><strong>Example_1</strong><br>Find courses taught by instructors in Physics with salary greater than 90,000<br>$$\\sigma_{dept_name&#x3D;”Physics” \\land salary&gt;90000}(instructor)$$<br>$$\\sigma_{dept_name&#x3D;”Physics}(\\sigma_{salary&gt;90000}(instructor))$$</p>\n<p><strong>Example_2</strong><br>Find courses taught by instructors in Physics<br>$$\\sigma_{dept_name&#x3D;”Physics”}(instructor \\bowtie_{instructor.ID &#x3D; teaches.ID}teacher)$$<br>$$(\\sigma_{dept_name&#x3D;”Physics”}(instructor)) \\bowtie_{instructor.ID&#x3D;teacher.ID}teacher$$</p>\n</blockquote>\n"},{"title":"数据库(5)","date":"2024-12-21T06:47:20.000Z","_content":"此处额外对一些数据库操作进行展示与说明，其中涵盖文档 1~3。由于数据库语言是大小写无关的，所以此处的编写可能与前文有一点大小写的差异\n\n## 基础模型定义\n\n### Create Table\n\n最基本的示例如下\n\n```SQL\nCreate Table r (\n    ID          char(5),\n    name        varchar(20),\n    dept_name   varchar(20),\n    salary      numeric(8,2)\n);\n```\n\n但是对于实际使用中，需要对其添加完整性约束并且声明外键和主键\n\n```SQL\nCreate Table teacher (\n    ID          char(5),\n    name        varchar(20) Not NULL,\n    course_id   varchar(8),\n    dept_name   varchar(20),\n    salary      numeric(8,2),\n    primary key(ID, name),\n    foreign key(dept_name) References department,\n    foreign key(course_id) References section\n);\n```\n\n### Drop Table\n\n直接执行`Drop 表名`就可以完成表的删除操作\n\n### Alter\n\n```SQL\nAlter table r add A D;\n```\n\n给表结构`r`增加一个名称为`A`的属性，并且其值域为`D`。执行这个操作后所有现存的数据关于属性`A`的都是`NULL`\n\n```SQL\nAlter table r drop A;\n```\n\n对于表`r`去除属性`A`。值得注意的是，这个去除属性的操作对于部分数据库而言是不支持的。\n\n值得注意的是，对于数据库中的数据，往往是按行存储的，这一点导致对于数据库属性的增删操作，其代价往往十分昂贵。\n\n### Select \n\n#### 1. **基本查询结构**\n\n```SQL\nSelect $A_1, A_2,...,A_n$\nFrom $r_1, r_2,...,r_m$\nWhere P;\n```\n\n- $A_i$是属性\n- $r_i$是关系表\n- $P$是筛选条件\n对应的关系代数为\n$$\\Pi_{A_1, A_2,...,A_n}(\\sigma_P {(r_1 \\times r_2 \\times...\\times r_m)})$$\n\n#### 2. **大小写不敏感**\n\n其中对于属性的名称本身是大小写不敏感的，也就是存在类似于有\n$\\text{Name} \\equiv \\text{NAME} \\equiv \\text{name}$\n\n#### 3. **ALL与DISTINCT关键字**\n\n对于`Select`操作额外的有`all`和`distinct`两个关键字，分别用于声明去除重复值和获取所有值\n使用方式如下\n\n```SQL\nSelect Distinct dept_name From instructor;\nSelect ALL      dept_name From instructor;\n```\n\n#### 4. 查询所有列\n\n对于`SELECT`有如下使用\n\n```SQL\nSelect * From instructor Where P;\n```\n\n这条查询会返回 instructor 表所有符合`P`情况的列和数据。\n\n#### 5. **查询常量**\n\n```SQL\nSelect '437'\n```\n\n该查询返回一个包含单列单行数据的表，列值为常量 '437'\n\n#### 6. **为查询结果指定别名** \n\n```SQL\nSELECT name AS FOO From instructor;\n```\n\n这条查询会返回`instructor`表的`name`列，并且该列的别名为`FOO`。输出时，列名会显示为`FOO`。\n\n#### 7. **常量与表结合**\n\n```SQL\nSelect `A` From instructor;\n```\n\n这条查询会返回`instructor`表中每一行的`A`常量。结果的行数与`instructor`表的记录数相同，每行的值是 `A`。\n\n#### 8. **Select 子句和算数表达式**\n\nSELECT 子句可以包含算术表达式，这些表达式涉及加法（+）、减法（-）、乘法（*）和除法（/），并操作常量或元组的属性。\n\n```SQL\nSELECT ID, name, salary/12\nFROM instructor;\n```\n\n该查询返回的结果是`instructor`表的所有列，唯一的区别是`salary`列的值被除以了 12，得到了每月的薪水。\n\n#### 9. **Where 子句和逻辑运算**\n\n`WHERE` 子句用于指定查询结果必须满足的条件，它对应于关系代数中的选择谓词（Selection Predicate）。可以使用逻辑运算符 `AND`、`OR` 和 `NOT` 来组合多个条件。\n\n```SQL\nSELECT name\nFROM instructor\nWHERE dept_name = 'Comp. Sci.' AND salary > 7000;\n```\n\n额外的存在一些其他的表达式比如`between and`和`Tuple comparison`\n\n```SQL\nSelect name\nFrom instructor\nWhere salary between 90000 and 100000\n```\n\n```SQL\nSelect name, course_id\nFrom instructor, teaches\nWhere (instructor.ID, dept_name) = (teaches.ID, 'Biology');\n```\n\n#### 10. **多表联合查询**、\n\n对于使用`Select`进行多表联合查询，其在使用中类似于关系代数$\\times$操作\n\nFind names of all instructors who have taught some course and the course_id\n\n```SQL\nSelect name, course_id\nFrom instructor , teaches\nWhere instructor.ID = teaches.ID; \n```\n\nFind names of all instructors in Art department who have taught some course and the course_id\n\n```SQL\nSelect name, course_id\nFrom instructor , teaches\nWhere instructor.ID = teaches.ID and  instructor. dept_name = 'Art';\n```\n\n值得注意的是，当使用Select查询多表结构时，`From`子句的数量不要过多，否则开销过于巨大，建议将表进行合并\n\n### Nature Join\n\n`Nature Join`用于`From`子句中，其使用方式如下\n\n```SQL\nselect name, course_id\nFrom instructor natural join teaches\nWhere instructor. dept_name = `Art`;\n```\n\n相比较于直接使用笛卡尔积的形式进行多表查询\n\n```SQL\nselect name, course_id\nFrom instructor, teaches\nWhere instructor.ID = teaches.ID and  instructor. dept_name = 'Art'; \n```\n\n使用 `Join`方法对于同名的属性进行了相关的连接合并，不会出现类似于`instructor.ID`和`teaches.ID`两个属性。同时由于自然链接，所以会合并其他同名的属性。\n\n### 语法查询完整结构\n\n```SQL\nSELECT {ALL | DISTINCT} {<column_expression1>} \nFROM {<table_name_or_view_name>}\n{WHERE <conditional_expression1>}\n{GROUP BY <column_name1> \n    HAVING {<conditional_expression2>}\n}\n{ORDER BY <column_name2> {ASC | DESC}}\n```\n\n- `GROUP BY ... Having...`根据某些列对查询结果进行分组。通常用于聚合函数（如`SUM`, `AVG`, `MAX`, `MIN`, `COUNT`）配合使用。`GROUP BY`后面跟的是一个或多个列名，结果将根据这些列进行分组。`Having`则用于过滤分组后的句子，其中可以包含 可以包含聚合条件，如对某个分组的总和、平均值等进行筛选。\n- `ORDER BY`子句用于排序查询结果。可以指定一个或多个列名，排序可以按多个列进行，列与列之间用逗号分隔。\n  - ASC：升序（默认排序方式）。\n  - DESC：降序。\n\n具体示例如下\n\n```SQL\nSELECT DISTINCT name, department\nFROM instructor\nWHERE salary > 5000\nGROUP BY department\nHAVING COUNT(*) > 1\nORDER BY salary DESC;\n```\n\n解释：\n\n- **SELECT DISTINCT**: 查询中返回唯一的 `name` 和 `department` 列，去除重复行。\n- **FROM instructor**: 从 `instructor` 表中查询数据。\n- **WHERE salary > 5000**: 筛选出 `salary` 大于 5000 的记录。\n- **GROUP BY department**: 按 `department` 列进行分组。\n- **HAVING COUNT(*) > 1**: 仅返回那些在同一个部门内有多个教师的记录。\n- **ORDER BY salary DESC**: 根据 `salary` 列按降序排列结果。\n\n![表操作顺序](/img/数据库(5)/表操作顺序.png)\n\n### 重命名操作\n\n常见的重命名方法如下\n\n```SQL\nSelect distinct T.name  as TeacherName\nFrom instructor as T, instructor as S   \nWhere T.salary > S.salary and S.dept_name = 'Comp. Sci.'\n-- 利用T和S区分不同的instructor!, 实现了对同一属性的不同值的比较\n```\n\n### 字符串操作\n\n在`SQL`中，`LIKE`运算符用于基于模式匹配对字符字符串进行比较。`%`和`_`分别用于匹配任意数量的字符和单个字符。\n\n比如查找包含“dar”子串的教师名字\n\n```SQL\nSELECT name\nFROM instructor\nWHERE name LIKE '%dar%';\n```\n\n如果其中需要查找实际的`%`和`_`，可以使用转义字符。\n如下使用转义字符查询`100%`\n\n```SQL\nSELECT *\nFROM some_table\nWHERE some_column LIKE '100\\%' ESCAPE '\\';\n/*\n'100\\%'：这个模式表示查找包含 100% 字符串的记录，而不是匹配“100”后面跟随任意字符的记录。\nESCAPE '\\'：这部分指定了反斜杠 \\ 作为转义字符。\n*/\n```\n\n`LIKE`运算符中的模式是大小写敏感的。以下是一些常见的匹配模式示例：\n\n- `Intro%`：匹配任何以“Intro”开头的字符串。\n- `%Comp%`：匹配任何包含“Comp”作为子串的字符串。\n- `___`：匹配任何正好由三个字符组成的字符串（每个下划线代表一个字符）。\n- `___%`：匹配任何长度至少为三个字符的字符串。\n\n`SQL`中还支持多种字符串操作，常见的包括：\n\n- **拼接** 使用$||$用于将多个字符串连接成一个\n\n  ```SQL\n  SELECT first_name || ' ' || last_name AS full_name\n  FROM employees;\n  ```\n\n- **转换大小写** 使用`UPPER`和`LOWER`函数将字符串转换为大写或小写。\n  例如，将名字转换为大写：\n\n  ```SQL\n  SELECT UPPER(name)\n  FROM instructor;\n  ```\n\n  将名字转换为小写：\n\n  ```SQL\n  SELECT LOWER(name)\n  FROM instructor;\n  ```\n\n- **查找字符串长度** 使用`LENGTH`函数来查找字符串的长度。\n  \n  ```SQL\n  SELECT LENGTH(name)\n  FROM instructor;\n  ```\n\n- **提取子字符串**：使用`SUBSTRING`或`SUBSTR`函数提取字符串中的一部分。\n  例如，从名字中提取前两个字符:\n  \n  ```SQL\n  SELECT SUBSTRING(name FROM 1 FOR 2)\n  FROM instructor;\n  ```\n\n### 排序操作\n\n在`SQL`中，可以使用 `ORDER BY` 子句对查询结果进行排序。\n\n#### 1. **按照单一属性排序**\n\n```SQL\nSELECT DISTINCT name\nFROM instructor\nORDER BY name DESC;\n```\n\n默认情况下，ORDER BY 会按升序（ASC）排序。如果需要按降序排序，可以使用 DESC。\n\n### 2. **按照多个属性排序**\n\n可以通过指定多个列来进行排序，默认情况下会按升序排序。\n\n```SQL\nSELECT DISTINCT dept_name, name\nFROM instructor\nORDER BY  dept_name ASC, name DESC;\n```\n\n在这个例子中，首先按 dept_name 升序排序，若 dept_name 相同，则按 name 降序排序。\n\n### 集合操作\n\nSQL 中的集合操作允许你对两个或更多的查询结果执行数学上的集合运算，包括 `UNION`（并集）、`INTERSECT`（交集）和 `EXCEPT`（差集）。这些操作符对应于关系代数中的并（$\\ucup$）、交（$\\ucap$）和差（−）运算符，并且自动去除重复的行。\n\n#### 1. **并(Union)**\n\n`UNION` 操作符用于合并两个查询的结果，并自动去除结果中的重复行。如果想要保留重复的行，可以使用`UNION ALL`。\n\n```SQL\n(SELECT course_id FROM section WHERE sem = 'Fall' AND year = 2017)\nUNION\n(SELECT course_id FROM section WHERE sem = 'Spring' AND year = 2018);\n```\n\n#### 2. **交(Intersect)**\n\n`INTERSECT`操作符返回两个查询结果中共同的行，并自动去除重复项。要保留重复项，可以使用`INTERSECT ALL`。\n\n```SQL\n(SELECT course_id FROM section WHERE sem = 'Fall' AND year = 2017)\nINTERSECT\n(SELECT course_id FROM section WHERE sem = 'Spring' AND year = 2018);\n```\n\n#### 3. **差(Except)**\n\n`EXCEPT`操作符返回第一个查询中的独有行，即这些行在第二个查询结果中不存在。与前两个操作符一样，`EXCEPT`默认去除重复项，但可以使用`EXCEPT ALL`来保留重复项。\n\n```SQL\n(SELECT course_id FROM section WHERE sem = 'Fall' AND year = 2017)\nEXCEPT\n(SELECT course_id FROM section WHERE sem = 'Spring' AND year = 2018);\n```\n\n### NULL 操作\n\n#### 1. **NULL特性**\n\n- **未知或不存在的值**：`NULL` 用来表示字段中的值未知或不存在。\n- **算术运算**：任何包含 `NULL` 的算术表达式的结果都是 `NULL`。\n\n```SQL\n-- 假设 x 是 NULL，5 + NULL 的结果是 NULL\nSELECT 5 + NULL AS result;\n```\n\n#### 2. **检查NULL值**\n\n要检查字段是否为 NULL，不能使用 $=$ 或 $!=$（不等于）。相反，必须使用`IS NULL`或`IS NOT NULL`\n\n```SQL\nSELECT name\nFROM instructor\nWHERE salary IS NULL;\n```\n\n#### 3. **NULL的逻辑操作**\n\n##### 比较操作与NULL\n\n任何试图与 `NULL` 进行比较的操作，其结果都是未知的，不是 `TRUE` 也不是 `FALSE`。\n\n- `5 < NULL` 的结果是未知。\n- `NULL <> NULL` 的结果是未知。\n- `NULL = NULL` 的结果是未知。\n\n##### 布尔操作与NULL\n\n在 SQL 中，布尔逻辑需要扩展以处理未知值。这包括 `AND`、`OR` 和 `NOT` 操作：\n\n- **AND（与）操作**：\n  - `TRUE AND UNKNOWN` = `UNKNOWN`\n  - `FALSE AND UNKNOWN` = `FALSE`\n  - `UNKNOWN AND UNKNOWN` = `UNKNOWN`\n\n- **OR（或）操作**：\n  - `UNKNOWN OR TRUE` = `TRUE`\n  - `UNKNOWN OR FALSE` = `UNKNOWN`\n  - `UNKNOWN OR UNKNOWN` = `UNKNOWN`\n\n##### WHERE 子句中的未知值处理\n\n在 `WHERE` 子句中，任何计算结果为未知的谓词都被视为 `FALSE`。这意味着那些涉及到 `NULL` 值的条件可能会导致记录被排除在查询结果之外，即使它们可能符合查询的其它条件。\n\n\n###  Join操作\n\n在 SQL 中，`JOIN` 是一种在查询中结合来自两个或更多表的行的操作。根据关联的条件，可以形成几种类型的 `JOIN`\n\n#### 1. **INNER JOIN（内连接）**\n\n`INNER JOIN` 返回两个表中满足连接条件的行。如果表中的记录在对方表中没有匹配的行，则这些记录不会出现在结果中。\n\n```SQL\nSELECT employees.name, employees.dept_id, departments.name\nFROM employees\nINNER JOIN departments ON employees.dept_id = departments.id;\n```\n\n这里，只有那些在`employees`和`departments`表中都有对应部门`ID`的记录会被返回。\n\n#### 2. **LEFT JOIN（左连接）**\n\n`LEFT JOIN`（或称为`LEFT OUTER JOIN`）返回左表中的所有记录和右表中的匹配记录。如果左表的行在右表中没有匹配，则这些行的右表列将包含 NULL。\n\n```SQL\nSELECT employees.name, departments.name\nFROM employees\nLEFT JOIN departments ON employees.dept_id = departments.id;\n```\n\n这里，所有 employees 的记录都会显示，无论它们是否在 departments 表中有匹配的记录。\n\n#### 3. **RIGHT JOIN（右连接**\n\n`RIGHT JOIN`（或称为`RIGHT OUTER JOIN`）返回右表中的所有记录和左表中的匹配记录。如果右表的行在左表中没有匹配，则这些行的左表列将包含`NULL`。\n\n```SQL\nSELECT employees.name, departments.name\nFROM employees\nRIGHT JOIN departments ON employees.dept_id = departments.id;\n```\n这里，所有 departments 的记录都会显示，无论它们是否在 employees 表中有匹配的记录。\n\n#### 4. **FULL JOIN（全连接）**\n\n`FULL JOIN`（或称为`FULL OUTER JOIN`）返回左表和右表中的所有记录。当某行在另一表中没有匹配时，会在相关列显示`NULL`。\n\n```SQL\nSELECT employees.name, departments.name\nFROM employees\nFULL JOIN departments ON employees.dept_id = departments.id;\n```\n\n这里，employees 和 departments 表中的所有记录都会显示，无论它们是否互相匹配。\n\n#### 5. **CROSS JOIN（交叉连接）**\n\n`CROSS JOIN`返回两个表所有可能的行组合，也称为笛卡尔积。通常不需要`ON`子句。\n\n```SQL\nSELECT employees.name, departments.name\nFROM employees\nCROSS JOIN departments;\n```\n\n这里，每个 employees 的记录都会与 departments 的每条记录组合。\n\n### 聚合函数和分组操作\n\nSQL 中的聚合函数对一列的值进行操作，并返回一个单一的值。这些函数特别适用于进行数据汇总和统计计算。常见的聚合函数包括：\n\n- `AVG`: 计算平均值。\n- `MIN`: 查找最小值。\n- `MAX`: 查找最大值。\n- `SUM`: 计算值的总和。\n- `COUNT`: 计算值的数量。\n\n#### 使用分组和聚合函数\n\n你可以结合使用 `GROUP BY` 子句和聚合函数来对数据进行分组，并对每个组应用聚合函数。可选的 `HAVING` 子句允许你设置分组后的筛选条件。\n\n**基本语法**：\n\n```sql\nSELECT {A1, A2, ..., Ai}, ag_fun(Ai+1), ..., ag_fun(Ai+k)\nFROM r1, r2, ..., rm\nWHERE P1\nGROUP BY A1, A2, ..., Ai\nHAVING P2;\n```\n\n- `P1`是定义在`r1, r2, ..., rm`的所有属性上的条件。\n- `P2`是定义在`A1, A2, ..., Ai`上的约束，用于`GROUP BY`。\n\n**实际用例**:\n\n- Find average salary of instructors in Computer Science department \n  \n  ``` SQL\n  select avg (salary)\n  from instructor\n  where dept_name= 'Comp. Sci.';\n  ```\n  \n  这个操作会首先提取出下表\n\n    | ID | name | dept_name | *salary* |\n    |----|------|-----------|--------|\n    |45565|Jian |Comp. Sci  | $100   |\n    |74281|Ye   |Comp. Sci  | $250   |\n    |98753|Du   |Comp. Sci  | $340   |\n    |54123|Lin  |Comp. Sci  | $200   |\n\n  然后返回其中`salary`的平均值。\n\n- Find total number of instructors who teach a course in Spring 2018\n  \n  ```SQL\n  select count (distinct ID)\n  from teaches\n  where semester = 'Spring' and year = 2018;\n  ```\n\n- Find the number of tuples in the course relation\n  \n  ```SQL\n  select count (*) from course;\n  ```\n\n#### 分组操作(Group by)\n\n- 获取每个部门的平均工资\n  \n  ```SQL\n  select dept_name, avg (salary) as avg_salary\n  from instructor\n  group by dept_name\n  having max(salary)>42000;\n  ```\n\n  事实上，在这个操作中，如果你使用\n  \n  ```SQL\n  select dept_name, salary\n  from instructor\n  group by dept_name;\n  ```\n  \n  其中`salary`并没有包含在聚合函数中，也没有被包含在`group`中，所以会引发错误。\n  > **注意**\n  > `having`子句中的谓词在组形成之后应用，而`where`子句中的谓词在形成组之前应用\n\n- NULL特殊情况：\n  除了 count(*) 外，所有聚合操作都会忽略在聚合属性上具有 NULL 值的元组。\n\n### 嵌套子句查询\n\n个人认为相似的例子在前文已经介绍了一些，所以此处只给出几个例子(当然，主要是因为这篇博客已经过长了)\n\n#### 1. **SOME**和**ALL**\n\n嵌套查询可以使用 `some`和`all`两个关键字进行查询过程中的指定，单纯字面理解，就不过多介绍。\n\n```SQL\nSELECT name\nFROM instructor\nWHERE salary > ALL (SELECT salary\n                    FROM instructor\n                    WHERE dept_name = 'Biology');\n\n```\n\n```SQL\nselect distinct course_id AS ID\nfrom section\nwhere semester = 'Fall' and year= 2009 and course_id  not in \n(select course_id \nfrom section \nwhere semester = 'Spring' and year= 2010);\n```\n\n#### 2. **exists** 和 **not exists**\n\n这个操作会根据后面的子句返回`True`或者`False`\n\n```SQL\nselect course_id\nfrom section as S\nwhere semester = 'Fall' and year = 2017 and \nexists  (select *\n        from section as T                          \n        where semester = 'Spring' and year= 2018 and S.course_id = T.course_id);\n```\n\n```SQL\nselect distinct S.ID, S.name\nfrom student as S\nwhere not exists ( (select course_id\n                    from course\n                    where dept_name = 'Biology')\n                    except (select T.course_id\n                            from takes as T\n                            where S.ID = T.ID));\n```\n\n#### 3. **Unique操作**\n\n`UNIQUE`关键字用于测试子查询是否返回了不包含重复元组（行）的结果,如果不重复返回`True`,重复则返回`False`\n\n```SQL\nSELECT T.course_id\nFROM course AS T\nWHERE UNIQUE (\n    SELECT R.course_id\n    FROM section AS R\n    WHERE T.course_id = R.course_id\n          AND R.year = 2017\n)\n```\n\n#### 4. **From操作**\n\n`FROM`在此处仍然是指定查询的表，只不过这个表可以是由子句查询返回的。\n\n```SQL\nselect dept_name, avg_salary\nfrom   (select dept_name, avg (salary) as avg_salary\n        from instructor          \n        group by dept_name) \nwhere avg_salary > 42000\n\n```\n\n#### 5. **With操作**\n\n`With`操作用于定义一个临时表，其中包含临时元素，用于后面的查询\n\n```SQL\nWITH max_budget (value) AS (\n    SELECT MAX(budget)\n    FROM department\n)\nSELECT department.name\nFROM department, max_budget\nWHERE department.budget = max_budget.value;\n```\n\n```SQL\nWITH ProjectCounts AS (\n    SELECT employee_id, COUNT(project_id) AS num_projects\n    FROM projects\n    GROUP BY employee_id\n),\nActiveEmployees AS (\n    SELECT employee_id, name AS employee_name\n    FROM employees\n    WHERE status = 'Active'\n)\nSELECT e.employee_name AS name, p.num_projects AS project_count\nFROM ActiveEmployees AS e\nJOIN ProjectCounts AS p ON e.employee_id = p.employee_id\nWHERE p.num_projects >= 2;\n```\n\n#### 标量查询操作\n\n在查询中过程中，可以将嵌套子句输出的标量作为查询对象，即相当于标量查询\n\n```SQL\nselect dept_name, ( select count(*) \n                    from instructor \n                    where department.dept_name = instructor.dept_name )\nas num_instructors\nfrom department;\n```\n\n### 嵌套操作效率\n\n很多情况下，由于多次执行嵌套内容会导致句子效率降低。所以对于SQL而言，提高执行效率的最好方式就是减少可能的嵌套语句\n\n如下给出两个`SQL`查询语句\n\n```SQL\nselect distinct T.name\nfrom instructor as T, instructor as S\nwhere T.salary > S.salary and S.dept name = 'Biology';\n```\n\n```SQL\nselect name\nfrom instructor\nwhere salary > some \n(select salary\nfrom instructor\nwhere dept name = 'Biology');\n\n```\n\n显然，前者优于后者。\n\n### 数据库修改\n\n数据库修改操作一般包括数据库的`插入`、`删除`和`更新`\n\n#### 删除\n\n`delete`删除一条数据\n\n- 删除表中的所有内容\n  \n  ```SQL\n  delete from instructor \n  ```\n\n- 灵活的指定筛选删除数据\n\n  ```SQL\n  delete from instructor\n  where dept_name in (select dept_name                                                      \n                        from department        \n                        where building = 'Watson')\n  ```\n\n  ```SQL\n  delete from instructor\n  where salary < (select avg (salary) \n                    from instructor)\n  ```\n\n#### 插入\n\n`insert`向表中插入一条数据，数据可以直接包含所有值，也可以只包含部分值，在符合域的情况下可以为`NULL`\n\n- 插入整条数据\n  \n  ```SQL\n  insert into course values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);\n  ```\n\n- 插入部分数据\n  \n  ```SQL\n  insert into course (course_id, title, dept_name, credits) values ('CS-437', 'Database \n  Systems', 'Comp. Sci.', 4);\n  ```\n\n- 插入包含`NULL`的数据\n\n  ```SQL\n  insert into student values ('3003', 'Green', 'Finance', null);\n  ```\n\n- 插入子句数据\n  \n  ```SQL\n  INSERT INTO instructor\n  SELECT ID, name, dept_name, 18000\n  FROM student\n  WHERE dept_name = 'Music' AND total_cred > 144;\n  ```\n\n#### 更新\n\n##### 1. **一般更新**\n`update`用于更新数据库表中的值\n例子如下\n\n```SQL\nupdate instructor\nset salary = salary * 1.05;\n```\n\n```SQL\nupdate instructor\nset salary = salary * 1.05 \nwhere salary < 70000;\n```\n\n```SQL\nupdate instructor\nset salary = salary * 1.05 \nwhere salary <  (select avg (salary) from instructor);\n```\n\n```SQL\nupdate student S\nset tot_cred = ( select sum(credits)\nfrom takes, course\nwhere takes.course_id = course.course_id  and S.ID= takes.ID.and takes.grade <> 'F' and takes.grade is not null );\n```\n\n##### 2. **case..end操作**\n\n对于`Update`操作，其中操作顺序非常重要，如下\n\n```SQL\nupdate instructor\nset salary = salary * 1.03\nwhere salary > 100,000;\n\nupdate instructor\nset salary = salary * 1.05\nwhere salary <= 100,000;\n```\n\n比如在这个中，调换顺序会导致薪资为99999的人加薪了两次。\n\n对于这个情况，可以使用`case`来进行更新\n\n```SQL\nupdate instructor\nset salary = case\n    when salary <= 100000 then salary * 1.05\n    else salary * 1.03\nend;\n```\n\n其中`case...end`实现了一个`if...else`的逻辑操作\n\n```SQL\ncase\n    when sum(credits) is not null then sum(credits)\n    else 0\nend\n```\n\n#### 3. **多表更新**\n\n给出有 `Student (S#, Sname, age …, C#, Grade, …)`, `SGrade (S#, C#, Grade)`\n\n利用`SGrade`的内容，更新`Student`\n\n```SQL\nupdate     Student as A \nset        Grade=B.Grade\nfrom       SGrade as B \nwhere      A.S#=B.S# and A.C#=B.C#\n```\n\n","source":"_posts/数据库-5.md","raw":"---\ntitle: 数据库(5)\ndate: 2024-12-21 14:47:20\ntags:\n    - 学习笔记\n    - 数据库\n---\n此处额外对一些数据库操作进行展示与说明，其中涵盖文档 1~3。由于数据库语言是大小写无关的，所以此处的编写可能与前文有一点大小写的差异\n\n## 基础模型定义\n\n### Create Table\n\n最基本的示例如下\n\n```SQL\nCreate Table r (\n    ID          char(5),\n    name        varchar(20),\n    dept_name   varchar(20),\n    salary      numeric(8,2)\n);\n```\n\n但是对于实际使用中，需要对其添加完整性约束并且声明外键和主键\n\n```SQL\nCreate Table teacher (\n    ID          char(5),\n    name        varchar(20) Not NULL,\n    course_id   varchar(8),\n    dept_name   varchar(20),\n    salary      numeric(8,2),\n    primary key(ID, name),\n    foreign key(dept_name) References department,\n    foreign key(course_id) References section\n);\n```\n\n### Drop Table\n\n直接执行`Drop 表名`就可以完成表的删除操作\n\n### Alter\n\n```SQL\nAlter table r add A D;\n```\n\n给表结构`r`增加一个名称为`A`的属性，并且其值域为`D`。执行这个操作后所有现存的数据关于属性`A`的都是`NULL`\n\n```SQL\nAlter table r drop A;\n```\n\n对于表`r`去除属性`A`。值得注意的是，这个去除属性的操作对于部分数据库而言是不支持的。\n\n值得注意的是，对于数据库中的数据，往往是按行存储的，这一点导致对于数据库属性的增删操作，其代价往往十分昂贵。\n\n### Select \n\n#### 1. **基本查询结构**\n\n```SQL\nSelect $A_1, A_2,...,A_n$\nFrom $r_1, r_2,...,r_m$\nWhere P;\n```\n\n- $A_i$是属性\n- $r_i$是关系表\n- $P$是筛选条件\n对应的关系代数为\n$$\\Pi_{A_1, A_2,...,A_n}(\\sigma_P {(r_1 \\times r_2 \\times...\\times r_m)})$$\n\n#### 2. **大小写不敏感**\n\n其中对于属性的名称本身是大小写不敏感的，也就是存在类似于有\n$\\text{Name} \\equiv \\text{NAME} \\equiv \\text{name}$\n\n#### 3. **ALL与DISTINCT关键字**\n\n对于`Select`操作额外的有`all`和`distinct`两个关键字，分别用于声明去除重复值和获取所有值\n使用方式如下\n\n```SQL\nSelect Distinct dept_name From instructor;\nSelect ALL      dept_name From instructor;\n```\n\n#### 4. 查询所有列\n\n对于`SELECT`有如下使用\n\n```SQL\nSelect * From instructor Where P;\n```\n\n这条查询会返回 instructor 表所有符合`P`情况的列和数据。\n\n#### 5. **查询常量**\n\n```SQL\nSelect '437'\n```\n\n该查询返回一个包含单列单行数据的表，列值为常量 '437'\n\n#### 6. **为查询结果指定别名** \n\n```SQL\nSELECT name AS FOO From instructor;\n```\n\n这条查询会返回`instructor`表的`name`列，并且该列的别名为`FOO`。输出时，列名会显示为`FOO`。\n\n#### 7. **常量与表结合**\n\n```SQL\nSelect `A` From instructor;\n```\n\n这条查询会返回`instructor`表中每一行的`A`常量。结果的行数与`instructor`表的记录数相同，每行的值是 `A`。\n\n#### 8. **Select 子句和算数表达式**\n\nSELECT 子句可以包含算术表达式，这些表达式涉及加法（+）、减法（-）、乘法（*）和除法（/），并操作常量或元组的属性。\n\n```SQL\nSELECT ID, name, salary/12\nFROM instructor;\n```\n\n该查询返回的结果是`instructor`表的所有列，唯一的区别是`salary`列的值被除以了 12，得到了每月的薪水。\n\n#### 9. **Where 子句和逻辑运算**\n\n`WHERE` 子句用于指定查询结果必须满足的条件，它对应于关系代数中的选择谓词（Selection Predicate）。可以使用逻辑运算符 `AND`、`OR` 和 `NOT` 来组合多个条件。\n\n```SQL\nSELECT name\nFROM instructor\nWHERE dept_name = 'Comp. Sci.' AND salary > 7000;\n```\n\n额外的存在一些其他的表达式比如`between and`和`Tuple comparison`\n\n```SQL\nSelect name\nFrom instructor\nWhere salary between 90000 and 100000\n```\n\n```SQL\nSelect name, course_id\nFrom instructor, teaches\nWhere (instructor.ID, dept_name) = (teaches.ID, 'Biology');\n```\n\n#### 10. **多表联合查询**、\n\n对于使用`Select`进行多表联合查询，其在使用中类似于关系代数$\\times$操作\n\nFind names of all instructors who have taught some course and the course_id\n\n```SQL\nSelect name, course_id\nFrom instructor , teaches\nWhere instructor.ID = teaches.ID; \n```\n\nFind names of all instructors in Art department who have taught some course and the course_id\n\n```SQL\nSelect name, course_id\nFrom instructor , teaches\nWhere instructor.ID = teaches.ID and  instructor. dept_name = 'Art';\n```\n\n值得注意的是，当使用Select查询多表结构时，`From`子句的数量不要过多，否则开销过于巨大，建议将表进行合并\n\n### Nature Join\n\n`Nature Join`用于`From`子句中，其使用方式如下\n\n```SQL\nselect name, course_id\nFrom instructor natural join teaches\nWhere instructor. dept_name = `Art`;\n```\n\n相比较于直接使用笛卡尔积的形式进行多表查询\n\n```SQL\nselect name, course_id\nFrom instructor, teaches\nWhere instructor.ID = teaches.ID and  instructor. dept_name = 'Art'; \n```\n\n使用 `Join`方法对于同名的属性进行了相关的连接合并，不会出现类似于`instructor.ID`和`teaches.ID`两个属性。同时由于自然链接，所以会合并其他同名的属性。\n\n### 语法查询完整结构\n\n```SQL\nSELECT {ALL | DISTINCT} {<column_expression1>} \nFROM {<table_name_or_view_name>}\n{WHERE <conditional_expression1>}\n{GROUP BY <column_name1> \n    HAVING {<conditional_expression2>}\n}\n{ORDER BY <column_name2> {ASC | DESC}}\n```\n\n- `GROUP BY ... Having...`根据某些列对查询结果进行分组。通常用于聚合函数（如`SUM`, `AVG`, `MAX`, `MIN`, `COUNT`）配合使用。`GROUP BY`后面跟的是一个或多个列名，结果将根据这些列进行分组。`Having`则用于过滤分组后的句子，其中可以包含 可以包含聚合条件，如对某个分组的总和、平均值等进行筛选。\n- `ORDER BY`子句用于排序查询结果。可以指定一个或多个列名，排序可以按多个列进行，列与列之间用逗号分隔。\n  - ASC：升序（默认排序方式）。\n  - DESC：降序。\n\n具体示例如下\n\n```SQL\nSELECT DISTINCT name, department\nFROM instructor\nWHERE salary > 5000\nGROUP BY department\nHAVING COUNT(*) > 1\nORDER BY salary DESC;\n```\n\n解释：\n\n- **SELECT DISTINCT**: 查询中返回唯一的 `name` 和 `department` 列，去除重复行。\n- **FROM instructor**: 从 `instructor` 表中查询数据。\n- **WHERE salary > 5000**: 筛选出 `salary` 大于 5000 的记录。\n- **GROUP BY department**: 按 `department` 列进行分组。\n- **HAVING COUNT(*) > 1**: 仅返回那些在同一个部门内有多个教师的记录。\n- **ORDER BY salary DESC**: 根据 `salary` 列按降序排列结果。\n\n![表操作顺序](/img/数据库(5)/表操作顺序.png)\n\n### 重命名操作\n\n常见的重命名方法如下\n\n```SQL\nSelect distinct T.name  as TeacherName\nFrom instructor as T, instructor as S   \nWhere T.salary > S.salary and S.dept_name = 'Comp. Sci.'\n-- 利用T和S区分不同的instructor!, 实现了对同一属性的不同值的比较\n```\n\n### 字符串操作\n\n在`SQL`中，`LIKE`运算符用于基于模式匹配对字符字符串进行比较。`%`和`_`分别用于匹配任意数量的字符和单个字符。\n\n比如查找包含“dar”子串的教师名字\n\n```SQL\nSELECT name\nFROM instructor\nWHERE name LIKE '%dar%';\n```\n\n如果其中需要查找实际的`%`和`_`，可以使用转义字符。\n如下使用转义字符查询`100%`\n\n```SQL\nSELECT *\nFROM some_table\nWHERE some_column LIKE '100\\%' ESCAPE '\\';\n/*\n'100\\%'：这个模式表示查找包含 100% 字符串的记录，而不是匹配“100”后面跟随任意字符的记录。\nESCAPE '\\'：这部分指定了反斜杠 \\ 作为转义字符。\n*/\n```\n\n`LIKE`运算符中的模式是大小写敏感的。以下是一些常见的匹配模式示例：\n\n- `Intro%`：匹配任何以“Intro”开头的字符串。\n- `%Comp%`：匹配任何包含“Comp”作为子串的字符串。\n- `___`：匹配任何正好由三个字符组成的字符串（每个下划线代表一个字符）。\n- `___%`：匹配任何长度至少为三个字符的字符串。\n\n`SQL`中还支持多种字符串操作，常见的包括：\n\n- **拼接** 使用$||$用于将多个字符串连接成一个\n\n  ```SQL\n  SELECT first_name || ' ' || last_name AS full_name\n  FROM employees;\n  ```\n\n- **转换大小写** 使用`UPPER`和`LOWER`函数将字符串转换为大写或小写。\n  例如，将名字转换为大写：\n\n  ```SQL\n  SELECT UPPER(name)\n  FROM instructor;\n  ```\n\n  将名字转换为小写：\n\n  ```SQL\n  SELECT LOWER(name)\n  FROM instructor;\n  ```\n\n- **查找字符串长度** 使用`LENGTH`函数来查找字符串的长度。\n  \n  ```SQL\n  SELECT LENGTH(name)\n  FROM instructor;\n  ```\n\n- **提取子字符串**：使用`SUBSTRING`或`SUBSTR`函数提取字符串中的一部分。\n  例如，从名字中提取前两个字符:\n  \n  ```SQL\n  SELECT SUBSTRING(name FROM 1 FOR 2)\n  FROM instructor;\n  ```\n\n### 排序操作\n\n在`SQL`中，可以使用 `ORDER BY` 子句对查询结果进行排序。\n\n#### 1. **按照单一属性排序**\n\n```SQL\nSELECT DISTINCT name\nFROM instructor\nORDER BY name DESC;\n```\n\n默认情况下，ORDER BY 会按升序（ASC）排序。如果需要按降序排序，可以使用 DESC。\n\n### 2. **按照多个属性排序**\n\n可以通过指定多个列来进行排序，默认情况下会按升序排序。\n\n```SQL\nSELECT DISTINCT dept_name, name\nFROM instructor\nORDER BY  dept_name ASC, name DESC;\n```\n\n在这个例子中，首先按 dept_name 升序排序，若 dept_name 相同，则按 name 降序排序。\n\n### 集合操作\n\nSQL 中的集合操作允许你对两个或更多的查询结果执行数学上的集合运算，包括 `UNION`（并集）、`INTERSECT`（交集）和 `EXCEPT`（差集）。这些操作符对应于关系代数中的并（$\\ucup$）、交（$\\ucap$）和差（−）运算符，并且自动去除重复的行。\n\n#### 1. **并(Union)**\n\n`UNION` 操作符用于合并两个查询的结果，并自动去除结果中的重复行。如果想要保留重复的行，可以使用`UNION ALL`。\n\n```SQL\n(SELECT course_id FROM section WHERE sem = 'Fall' AND year = 2017)\nUNION\n(SELECT course_id FROM section WHERE sem = 'Spring' AND year = 2018);\n```\n\n#### 2. **交(Intersect)**\n\n`INTERSECT`操作符返回两个查询结果中共同的行，并自动去除重复项。要保留重复项，可以使用`INTERSECT ALL`。\n\n```SQL\n(SELECT course_id FROM section WHERE sem = 'Fall' AND year = 2017)\nINTERSECT\n(SELECT course_id FROM section WHERE sem = 'Spring' AND year = 2018);\n```\n\n#### 3. **差(Except)**\n\n`EXCEPT`操作符返回第一个查询中的独有行，即这些行在第二个查询结果中不存在。与前两个操作符一样，`EXCEPT`默认去除重复项，但可以使用`EXCEPT ALL`来保留重复项。\n\n```SQL\n(SELECT course_id FROM section WHERE sem = 'Fall' AND year = 2017)\nEXCEPT\n(SELECT course_id FROM section WHERE sem = 'Spring' AND year = 2018);\n```\n\n### NULL 操作\n\n#### 1. **NULL特性**\n\n- **未知或不存在的值**：`NULL` 用来表示字段中的值未知或不存在。\n- **算术运算**：任何包含 `NULL` 的算术表达式的结果都是 `NULL`。\n\n```SQL\n-- 假设 x 是 NULL，5 + NULL 的结果是 NULL\nSELECT 5 + NULL AS result;\n```\n\n#### 2. **检查NULL值**\n\n要检查字段是否为 NULL，不能使用 $=$ 或 $!=$（不等于）。相反，必须使用`IS NULL`或`IS NOT NULL`\n\n```SQL\nSELECT name\nFROM instructor\nWHERE salary IS NULL;\n```\n\n#### 3. **NULL的逻辑操作**\n\n##### 比较操作与NULL\n\n任何试图与 `NULL` 进行比较的操作，其结果都是未知的，不是 `TRUE` 也不是 `FALSE`。\n\n- `5 < NULL` 的结果是未知。\n- `NULL <> NULL` 的结果是未知。\n- `NULL = NULL` 的结果是未知。\n\n##### 布尔操作与NULL\n\n在 SQL 中，布尔逻辑需要扩展以处理未知值。这包括 `AND`、`OR` 和 `NOT` 操作：\n\n- **AND（与）操作**：\n  - `TRUE AND UNKNOWN` = `UNKNOWN`\n  - `FALSE AND UNKNOWN` = `FALSE`\n  - `UNKNOWN AND UNKNOWN` = `UNKNOWN`\n\n- **OR（或）操作**：\n  - `UNKNOWN OR TRUE` = `TRUE`\n  - `UNKNOWN OR FALSE` = `UNKNOWN`\n  - `UNKNOWN OR UNKNOWN` = `UNKNOWN`\n\n##### WHERE 子句中的未知值处理\n\n在 `WHERE` 子句中，任何计算结果为未知的谓词都被视为 `FALSE`。这意味着那些涉及到 `NULL` 值的条件可能会导致记录被排除在查询结果之外，即使它们可能符合查询的其它条件。\n\n\n###  Join操作\n\n在 SQL 中，`JOIN` 是一种在查询中结合来自两个或更多表的行的操作。根据关联的条件，可以形成几种类型的 `JOIN`\n\n#### 1. **INNER JOIN（内连接）**\n\n`INNER JOIN` 返回两个表中满足连接条件的行。如果表中的记录在对方表中没有匹配的行，则这些记录不会出现在结果中。\n\n```SQL\nSELECT employees.name, employees.dept_id, departments.name\nFROM employees\nINNER JOIN departments ON employees.dept_id = departments.id;\n```\n\n这里，只有那些在`employees`和`departments`表中都有对应部门`ID`的记录会被返回。\n\n#### 2. **LEFT JOIN（左连接）**\n\n`LEFT JOIN`（或称为`LEFT OUTER JOIN`）返回左表中的所有记录和右表中的匹配记录。如果左表的行在右表中没有匹配，则这些行的右表列将包含 NULL。\n\n```SQL\nSELECT employees.name, departments.name\nFROM employees\nLEFT JOIN departments ON employees.dept_id = departments.id;\n```\n\n这里，所有 employees 的记录都会显示，无论它们是否在 departments 表中有匹配的记录。\n\n#### 3. **RIGHT JOIN（右连接**\n\n`RIGHT JOIN`（或称为`RIGHT OUTER JOIN`）返回右表中的所有记录和左表中的匹配记录。如果右表的行在左表中没有匹配，则这些行的左表列将包含`NULL`。\n\n```SQL\nSELECT employees.name, departments.name\nFROM employees\nRIGHT JOIN departments ON employees.dept_id = departments.id;\n```\n这里，所有 departments 的记录都会显示，无论它们是否在 employees 表中有匹配的记录。\n\n#### 4. **FULL JOIN（全连接）**\n\n`FULL JOIN`（或称为`FULL OUTER JOIN`）返回左表和右表中的所有记录。当某行在另一表中没有匹配时，会在相关列显示`NULL`。\n\n```SQL\nSELECT employees.name, departments.name\nFROM employees\nFULL JOIN departments ON employees.dept_id = departments.id;\n```\n\n这里，employees 和 departments 表中的所有记录都会显示，无论它们是否互相匹配。\n\n#### 5. **CROSS JOIN（交叉连接）**\n\n`CROSS JOIN`返回两个表所有可能的行组合，也称为笛卡尔积。通常不需要`ON`子句。\n\n```SQL\nSELECT employees.name, departments.name\nFROM employees\nCROSS JOIN departments;\n```\n\n这里，每个 employees 的记录都会与 departments 的每条记录组合。\n\n### 聚合函数和分组操作\n\nSQL 中的聚合函数对一列的值进行操作，并返回一个单一的值。这些函数特别适用于进行数据汇总和统计计算。常见的聚合函数包括：\n\n- `AVG`: 计算平均值。\n- `MIN`: 查找最小值。\n- `MAX`: 查找最大值。\n- `SUM`: 计算值的总和。\n- `COUNT`: 计算值的数量。\n\n#### 使用分组和聚合函数\n\n你可以结合使用 `GROUP BY` 子句和聚合函数来对数据进行分组，并对每个组应用聚合函数。可选的 `HAVING` 子句允许你设置分组后的筛选条件。\n\n**基本语法**：\n\n```sql\nSELECT {A1, A2, ..., Ai}, ag_fun(Ai+1), ..., ag_fun(Ai+k)\nFROM r1, r2, ..., rm\nWHERE P1\nGROUP BY A1, A2, ..., Ai\nHAVING P2;\n```\n\n- `P1`是定义在`r1, r2, ..., rm`的所有属性上的条件。\n- `P2`是定义在`A1, A2, ..., Ai`上的约束，用于`GROUP BY`。\n\n**实际用例**:\n\n- Find average salary of instructors in Computer Science department \n  \n  ``` SQL\n  select avg (salary)\n  from instructor\n  where dept_name= 'Comp. Sci.';\n  ```\n  \n  这个操作会首先提取出下表\n\n    | ID | name | dept_name | *salary* |\n    |----|------|-----------|--------|\n    |45565|Jian |Comp. Sci  | $100   |\n    |74281|Ye   |Comp. Sci  | $250   |\n    |98753|Du   |Comp. Sci  | $340   |\n    |54123|Lin  |Comp. Sci  | $200   |\n\n  然后返回其中`salary`的平均值。\n\n- Find total number of instructors who teach a course in Spring 2018\n  \n  ```SQL\n  select count (distinct ID)\n  from teaches\n  where semester = 'Spring' and year = 2018;\n  ```\n\n- Find the number of tuples in the course relation\n  \n  ```SQL\n  select count (*) from course;\n  ```\n\n#### 分组操作(Group by)\n\n- 获取每个部门的平均工资\n  \n  ```SQL\n  select dept_name, avg (salary) as avg_salary\n  from instructor\n  group by dept_name\n  having max(salary)>42000;\n  ```\n\n  事实上，在这个操作中，如果你使用\n  \n  ```SQL\n  select dept_name, salary\n  from instructor\n  group by dept_name;\n  ```\n  \n  其中`salary`并没有包含在聚合函数中，也没有被包含在`group`中，所以会引发错误。\n  > **注意**\n  > `having`子句中的谓词在组形成之后应用，而`where`子句中的谓词在形成组之前应用\n\n- NULL特殊情况：\n  除了 count(*) 外，所有聚合操作都会忽略在聚合属性上具有 NULL 值的元组。\n\n### 嵌套子句查询\n\n个人认为相似的例子在前文已经介绍了一些，所以此处只给出几个例子(当然，主要是因为这篇博客已经过长了)\n\n#### 1. **SOME**和**ALL**\n\n嵌套查询可以使用 `some`和`all`两个关键字进行查询过程中的指定，单纯字面理解，就不过多介绍。\n\n```SQL\nSELECT name\nFROM instructor\nWHERE salary > ALL (SELECT salary\n                    FROM instructor\n                    WHERE dept_name = 'Biology');\n\n```\n\n```SQL\nselect distinct course_id AS ID\nfrom section\nwhere semester = 'Fall' and year= 2009 and course_id  not in \n(select course_id \nfrom section \nwhere semester = 'Spring' and year= 2010);\n```\n\n#### 2. **exists** 和 **not exists**\n\n这个操作会根据后面的子句返回`True`或者`False`\n\n```SQL\nselect course_id\nfrom section as S\nwhere semester = 'Fall' and year = 2017 and \nexists  (select *\n        from section as T                          \n        where semester = 'Spring' and year= 2018 and S.course_id = T.course_id);\n```\n\n```SQL\nselect distinct S.ID, S.name\nfrom student as S\nwhere not exists ( (select course_id\n                    from course\n                    where dept_name = 'Biology')\n                    except (select T.course_id\n                            from takes as T\n                            where S.ID = T.ID));\n```\n\n#### 3. **Unique操作**\n\n`UNIQUE`关键字用于测试子查询是否返回了不包含重复元组（行）的结果,如果不重复返回`True`,重复则返回`False`\n\n```SQL\nSELECT T.course_id\nFROM course AS T\nWHERE UNIQUE (\n    SELECT R.course_id\n    FROM section AS R\n    WHERE T.course_id = R.course_id\n          AND R.year = 2017\n)\n```\n\n#### 4. **From操作**\n\n`FROM`在此处仍然是指定查询的表，只不过这个表可以是由子句查询返回的。\n\n```SQL\nselect dept_name, avg_salary\nfrom   (select dept_name, avg (salary) as avg_salary\n        from instructor          \n        group by dept_name) \nwhere avg_salary > 42000\n\n```\n\n#### 5. **With操作**\n\n`With`操作用于定义一个临时表，其中包含临时元素，用于后面的查询\n\n```SQL\nWITH max_budget (value) AS (\n    SELECT MAX(budget)\n    FROM department\n)\nSELECT department.name\nFROM department, max_budget\nWHERE department.budget = max_budget.value;\n```\n\n```SQL\nWITH ProjectCounts AS (\n    SELECT employee_id, COUNT(project_id) AS num_projects\n    FROM projects\n    GROUP BY employee_id\n),\nActiveEmployees AS (\n    SELECT employee_id, name AS employee_name\n    FROM employees\n    WHERE status = 'Active'\n)\nSELECT e.employee_name AS name, p.num_projects AS project_count\nFROM ActiveEmployees AS e\nJOIN ProjectCounts AS p ON e.employee_id = p.employee_id\nWHERE p.num_projects >= 2;\n```\n\n#### 标量查询操作\n\n在查询中过程中，可以将嵌套子句输出的标量作为查询对象，即相当于标量查询\n\n```SQL\nselect dept_name, ( select count(*) \n                    from instructor \n                    where department.dept_name = instructor.dept_name )\nas num_instructors\nfrom department;\n```\n\n### 嵌套操作效率\n\n很多情况下，由于多次执行嵌套内容会导致句子效率降低。所以对于SQL而言，提高执行效率的最好方式就是减少可能的嵌套语句\n\n如下给出两个`SQL`查询语句\n\n```SQL\nselect distinct T.name\nfrom instructor as T, instructor as S\nwhere T.salary > S.salary and S.dept name = 'Biology';\n```\n\n```SQL\nselect name\nfrom instructor\nwhere salary > some \n(select salary\nfrom instructor\nwhere dept name = 'Biology');\n\n```\n\n显然，前者优于后者。\n\n### 数据库修改\n\n数据库修改操作一般包括数据库的`插入`、`删除`和`更新`\n\n#### 删除\n\n`delete`删除一条数据\n\n- 删除表中的所有内容\n  \n  ```SQL\n  delete from instructor \n  ```\n\n- 灵活的指定筛选删除数据\n\n  ```SQL\n  delete from instructor\n  where dept_name in (select dept_name                                                      \n                        from department        \n                        where building = 'Watson')\n  ```\n\n  ```SQL\n  delete from instructor\n  where salary < (select avg (salary) \n                    from instructor)\n  ```\n\n#### 插入\n\n`insert`向表中插入一条数据，数据可以直接包含所有值，也可以只包含部分值，在符合域的情况下可以为`NULL`\n\n- 插入整条数据\n  \n  ```SQL\n  insert into course values ('CS-437', 'Database Systems', 'Comp. Sci.', 4);\n  ```\n\n- 插入部分数据\n  \n  ```SQL\n  insert into course (course_id, title, dept_name, credits) values ('CS-437', 'Database \n  Systems', 'Comp. Sci.', 4);\n  ```\n\n- 插入包含`NULL`的数据\n\n  ```SQL\n  insert into student values ('3003', 'Green', 'Finance', null);\n  ```\n\n- 插入子句数据\n  \n  ```SQL\n  INSERT INTO instructor\n  SELECT ID, name, dept_name, 18000\n  FROM student\n  WHERE dept_name = 'Music' AND total_cred > 144;\n  ```\n\n#### 更新\n\n##### 1. **一般更新**\n`update`用于更新数据库表中的值\n例子如下\n\n```SQL\nupdate instructor\nset salary = salary * 1.05;\n```\n\n```SQL\nupdate instructor\nset salary = salary * 1.05 \nwhere salary < 70000;\n```\n\n```SQL\nupdate instructor\nset salary = salary * 1.05 \nwhere salary <  (select avg (salary) from instructor);\n```\n\n```SQL\nupdate student S\nset tot_cred = ( select sum(credits)\nfrom takes, course\nwhere takes.course_id = course.course_id  and S.ID= takes.ID.and takes.grade <> 'F' and takes.grade is not null );\n```\n\n##### 2. **case..end操作**\n\n对于`Update`操作，其中操作顺序非常重要，如下\n\n```SQL\nupdate instructor\nset salary = salary * 1.03\nwhere salary > 100,000;\n\nupdate instructor\nset salary = salary * 1.05\nwhere salary <= 100,000;\n```\n\n比如在这个中，调换顺序会导致薪资为99999的人加薪了两次。\n\n对于这个情况，可以使用`case`来进行更新\n\n```SQL\nupdate instructor\nset salary = case\n    when salary <= 100000 then salary * 1.05\n    else salary * 1.03\nend;\n```\n\n其中`case...end`实现了一个`if...else`的逻辑操作\n\n```SQL\ncase\n    when sum(credits) is not null then sum(credits)\n    else 0\nend\n```\n\n#### 3. **多表更新**\n\n给出有 `Student (S#, Sname, age …, C#, Grade, …)`, `SGrade (S#, C#, Grade)`\n\n利用`SGrade`的内容，更新`Student`\n\n```SQL\nupdate     Student as A \nset        Grade=B.Grade\nfrom       SGrade as B \nwhere      A.S#=B.S# and A.C#=B.C#\n```\n\n","slug":"数据库-5","published":1,"updated":"2024-12-23T01:08:42.460Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot6000c6d6efzdpenj3","content":"<p>此处额外对一些数据库操作进行展示与说明，其中涵盖文档 1~3。由于数据库语言是大小写无关的，所以此处的编写可能与前文有一点大小写的差异</p>\n<h2 id=\"基础模型定义\"><a href=\"#基础模型定义\" class=\"headerlink\" title=\"基础模型定义\"></a>基础模型定义</h2><h3 id=\"Create-Table\"><a href=\"#Create-Table\" class=\"headerlink\" title=\"Create Table\"></a>Create Table</h3><p>最基本的示例如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Create</span> <span class=\"hljs-keyword\">Table</span> r (<br>    ID          <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">5</span>),<br>    name        <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),<br>    dept_name   <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),<br>    salary      <span class=\"hljs-type\">numeric</span>(<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>)<br>);<br></code></pre></td></tr></table></figure>\n\n<p>但是对于实际使用中，需要对其添加完整性约束并且声明外键和主键</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Create</span> <span class=\"hljs-keyword\">Table</span> teacher (<br>    ID          <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">5</span>),<br>    name        <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">Not</span> <span class=\"hljs-keyword\">NULL</span>,<br>    course_id   <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">8</span>),<br>    dept_name   <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),<br>    salary      <span class=\"hljs-type\">numeric</span>(<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>),<br>    <span class=\"hljs-keyword\">primary</span> key(ID, name),<br>    <span class=\"hljs-keyword\">foreign</span> key(dept_name) <span class=\"hljs-keyword\">References</span> department,<br>    <span class=\"hljs-keyword\">foreign</span> key(course_id) <span class=\"hljs-keyword\">References</span> section<br>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Drop-Table\"><a href=\"#Drop-Table\" class=\"headerlink\" title=\"Drop Table\"></a>Drop Table</h3><p>直接执行<code>Drop 表名</code>就可以完成表的删除操作</p>\n<h3 id=\"Alter\"><a href=\"#Alter\" class=\"headerlink\" title=\"Alter\"></a>Alter</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Alter</span> <span class=\"hljs-keyword\">table</span> r <span class=\"hljs-keyword\">add</span> A D;<br></code></pre></td></tr></table></figure>\n\n<p>给表结构<code>r</code>增加一个名称为<code>A</code>的属性，并且其值域为<code>D</code>。执行这个操作后所有现存的数据关于属性<code>A</code>的都是<code>NULL</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Alter</span> <span class=\"hljs-keyword\">table</span> r <span class=\"hljs-keyword\">drop</span> A;<br></code></pre></td></tr></table></figure>\n\n<p>对于表<code>r</code>去除属性<code>A</code>。值得注意的是，这个去除属性的操作对于部分数据库而言是不支持的。</p>\n<p>值得注意的是，对于数据库中的数据，往往是按行存储的，这一点导致对于数据库属性的增删操作，其代价往往十分昂贵。</p>\n<h3 id=\"Select\"><a href=\"#Select\" class=\"headerlink\" title=\"Select\"></a>Select</h3><h4 id=\"1-基本查询结构\"><a href=\"#1-基本查询结构\" class=\"headerlink\" title=\"1. 基本查询结构\"></a>1. <strong>基本查询结构</strong></h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> $A_1, A_2,...,A_n$<br><span class=\"hljs-keyword\">From</span> $r_1, r_2,...,r_m$<br><span class=\"hljs-keyword\">Where</span> P;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>$A_i$是属性</li>\n<li>$r_i$是关系表</li>\n<li>$P$是筛选条件<br>对应的关系代数为<br>$$\\Pi_{A_1, A_2,…,A_n}(\\sigma_P {(r_1 \\times r_2 \\times…\\times r_m)})$$</li>\n</ul>\n<h4 id=\"2-大小写不敏感\"><a href=\"#2-大小写不敏感\" class=\"headerlink\" title=\"2. 大小写不敏感\"></a>2. <strong>大小写不敏感</strong></h4><p>其中对于属性的名称本身是大小写不敏感的，也就是存在类似于有<br>$\\text{Name} \\equiv \\text{NAME} \\equiv \\text{name}$</p>\n<h4 id=\"3-ALL与DISTINCT关键字\"><a href=\"#3-ALL与DISTINCT关键字\" class=\"headerlink\" title=\"3. ALL与DISTINCT关键字\"></a>3. <strong>ALL与DISTINCT关键字</strong></h4><p>对于<code>Select</code>操作额外的有<code>all</code>和<code>distinct</code>两个关键字，分别用于声明去除重复值和获取所有值<br>使用方式如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">Distinct</span> dept_name <span class=\"hljs-keyword\">From</span> instructor;<br><span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">ALL</span>      dept_name <span class=\"hljs-keyword\">From</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-查询所有列\"><a href=\"#4-查询所有列\" class=\"headerlink\" title=\"4. 查询所有列\"></a>4. 查询所有列</h4><p>对于<code>SELECT</code>有如下使用</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">From</span> instructor <span class=\"hljs-keyword\">Where</span> P;<br></code></pre></td></tr></table></figure>\n\n<p>这条查询会返回 instructor 表所有符合<code>P</code>情况的列和数据。</p>\n<h4 id=\"5-查询常量\"><a href=\"#5-查询常量\" class=\"headerlink\" title=\"5. 查询常量\"></a>5. <strong>查询常量</strong></h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> <span class=\"hljs-string\">&#x27;437&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>该查询返回一个包含单列单行数据的表，列值为常量 ‘437’</p>\n<h4 id=\"6-为查询结果指定别名\"><a href=\"#6-为查询结果指定别名\" class=\"headerlink\" title=\"6. 为查询结果指定别名\"></a>6. <strong>为查询结果指定别名</strong></h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name <span class=\"hljs-keyword\">AS</span> FOO <span class=\"hljs-keyword\">From</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<p>这条查询会返回<code>instructor</code>表的<code>name</code>列，并且该列的别名为<code>FOO</code>。输出时，列名会显示为<code>FOO</code>。</p>\n<h4 id=\"7-常量与表结合\"><a href=\"#7-常量与表结合\" class=\"headerlink\" title=\"7. 常量与表结合\"></a>7. <strong>常量与表结合</strong></h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> `A` <span class=\"hljs-keyword\">From</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<p>这条查询会返回<code>instructor</code>表中每一行的<code>A</code>常量。结果的行数与<code>instructor</code>表的记录数相同，每行的值是 <code>A</code>。</p>\n<h4 id=\"8-Select-子句和算数表达式\"><a href=\"#8-Select-子句和算数表达式\" class=\"headerlink\" title=\"8. Select 子句和算数表达式\"></a>8. <strong>Select 子句和算数表达式</strong></h4><p>SELECT 子句可以包含算术表达式，这些表达式涉及加法（+）、减法（-）、乘法（*）和除法（&#x2F;），并操作常量或元组的属性。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> ID, name, salary<span class=\"hljs-operator\">/</span><span class=\"hljs-number\">12</span><br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<p>该查询返回的结果是<code>instructor</code>表的所有列，唯一的区别是<code>salary</code>列的值被除以了 12，得到了每月的薪水。</p>\n<h4 id=\"9-Where-子句和逻辑运算\"><a href=\"#9-Where-子句和逻辑运算\" class=\"headerlink\" title=\"9. Where 子句和逻辑运算\"></a>9. <strong>Where 子句和逻辑运算</strong></h4><p><code>WHERE</code> 子句用于指定查询结果必须满足的条件，它对应于关系代数中的选择谓词（Selection Predicate）。可以使用逻辑运算符 <code>AND</code>、<code>OR</code> 和 <code>NOT</code> 来组合多个条件。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">WHERE</span> dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Comp. Sci.&#x27;</span> <span class=\"hljs-keyword\">AND</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">7000</span>;<br></code></pre></td></tr></table></figure>\n\n<p>额外的存在一些其他的表达式比如<code>between and</code>和<code>Tuple comparison</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> name<br><span class=\"hljs-keyword\">From</span> instructor<br><span class=\"hljs-keyword\">Where</span> salary <span class=\"hljs-keyword\">between</span> <span class=\"hljs-number\">90000</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-number\">100000</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> name, course_id<br><span class=\"hljs-keyword\">From</span> instructor, teaches<br><span class=\"hljs-keyword\">Where</span> (instructor.ID, dept_name) <span class=\"hljs-operator\">=</span> (teaches.ID, <span class=\"hljs-string\">&#x27;Biology&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"10-多表联合查询、\"><a href=\"#10-多表联合查询、\" class=\"headerlink\" title=\"10. 多表联合查询、\"></a>10. <strong>多表联合查询</strong>、</h4><p>对于使用<code>Select</code>进行多表联合查询，其在使用中类似于关系代数$\\times$操作</p>\n<p>Find names of all instructors who have taught some course and the course_id</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> name, course_id<br><span class=\"hljs-keyword\">From</span> instructor , teaches<br><span class=\"hljs-keyword\">Where</span> instructor.ID <span class=\"hljs-operator\">=</span> teaches.ID; <br></code></pre></td></tr></table></figure>\n\n<p>Find names of all instructors in Art department who have taught some course and the course_id</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> name, course_id<br><span class=\"hljs-keyword\">From</span> instructor , teaches<br><span class=\"hljs-keyword\">Where</span> instructor.ID <span class=\"hljs-operator\">=</span> teaches.ID <span class=\"hljs-keyword\">and</span>  instructor. dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Art&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>值得注意的是，当使用Select查询多表结构时，<code>From</code>子句的数量不要过多，否则开销过于巨大，建议将表进行合并</p>\n<h3 id=\"Nature-Join\"><a href=\"#Nature-Join\" class=\"headerlink\" title=\"Nature Join\"></a>Nature Join</h3><p><code>Nature Join</code>用于<code>From</code>子句中，其使用方式如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> name, course_id<br><span class=\"hljs-keyword\">From</span> instructor <span class=\"hljs-keyword\">natural</span> <span class=\"hljs-keyword\">join</span> teaches<br><span class=\"hljs-keyword\">Where</span> instructor. dept_name <span class=\"hljs-operator\">=</span> `Art`;<br></code></pre></td></tr></table></figure>\n\n<p>相比较于直接使用笛卡尔积的形式进行多表查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> name, course_id<br><span class=\"hljs-keyword\">From</span> instructor, teaches<br><span class=\"hljs-keyword\">Where</span> instructor.ID <span class=\"hljs-operator\">=</span> teaches.ID <span class=\"hljs-keyword\">and</span>  instructor. dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Art&#x27;</span>; <br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>Join</code>方法对于同名的属性进行了相关的连接合并，不会出现类似于<code>instructor.ID</code>和<code>teaches.ID</code>两个属性。同时由于自然链接，所以会合并其他同名的属性。</p>\n<h3 id=\"语法查询完整结构\"><a href=\"#语法查询完整结构\" class=\"headerlink\" title=\"语法查询完整结构\"></a>语法查询完整结构</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> &#123;<span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-operator\">|</span> <span class=\"hljs-keyword\">DISTINCT</span>&#125; &#123;<span class=\"hljs-operator\">&lt;</span>column_expression1<span class=\"hljs-operator\">&gt;</span>&#125; <br><span class=\"hljs-keyword\">FROM</span> &#123;<span class=\"hljs-operator\">&lt;</span>table_name_or_view_name<span class=\"hljs-operator\">&gt;</span>&#125;<br>&#123;<span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-operator\">&lt;</span>conditional_expression1<span class=\"hljs-operator\">&gt;</span>&#125;<br>&#123;<span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-operator\">&lt;</span>column_name1<span class=\"hljs-operator\">&gt;</span> <br>    <span class=\"hljs-keyword\">HAVING</span> &#123;<span class=\"hljs-operator\">&lt;</span>conditional_expression2<span class=\"hljs-operator\">&gt;</span>&#125;<br>&#125;<br>&#123;<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-operator\">&lt;</span>column_name2<span class=\"hljs-operator\">&gt;</span> &#123;<span class=\"hljs-keyword\">ASC</span> <span class=\"hljs-operator\">|</span> <span class=\"hljs-keyword\">DESC</span>&#125;&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>GROUP BY ... Having...</code>根据某些列对查询结果进行分组。通常用于聚合函数（如<code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code>, <code>COUNT</code>）配合使用。<code>GROUP BY</code>后面跟的是一个或多个列名，结果将根据这些列进行分组。<code>Having</code>则用于过滤分组后的句子，其中可以包含 可以包含聚合条件，如对某个分组的总和、平均值等进行筛选。</li>\n<li><code>ORDER BY</code>子句用于排序查询结果。可以指定一个或多个列名，排序可以按多个列进行，列与列之间用逗号分隔。<ul>\n<li>ASC：升序（默认排序方式）。</li>\n<li>DESC：降序。</li>\n</ul>\n</li>\n</ul>\n<p>具体示例如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DISTINCT</span> name, department<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">WHERE</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">5000</span><br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> department<br><span class=\"hljs-keyword\">HAVING</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> salary <span class=\"hljs-keyword\">DESC</span>;<br></code></pre></td></tr></table></figure>\n\n<p>解释：</p>\n<ul>\n<li><strong>SELECT DISTINCT</strong>: 查询中返回唯一的 <code>name</code> 和 <code>department</code> 列，去除重复行。</li>\n<li><strong>FROM instructor</strong>: 从 <code>instructor</code> 表中查询数据。</li>\n<li><strong>WHERE salary &gt; 5000</strong>: 筛选出 <code>salary</code> 大于 5000 的记录。</li>\n<li><strong>GROUP BY department</strong>: 按 <code>department</code> 列进行分组。</li>\n<li><strong>HAVING COUNT(*) &gt; 1</strong>: 仅返回那些在同一个部门内有多个教师的记录。</li>\n<li><strong>ORDER BY salary DESC</strong>: 根据 <code>salary</code> 列按降序排列结果。</li>\n</ul>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(5)/%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F.png\" alt=\"表操作顺序\"></p>\n<h3 id=\"重命名操作\"><a href=\"#重命名操作\" class=\"headerlink\" title=\"重命名操作\"></a>重命名操作</h3><p>常见的重命名方法如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">distinct</span> T.name  <span class=\"hljs-keyword\">as</span> TeacherName<br><span class=\"hljs-keyword\">From</span> instructor <span class=\"hljs-keyword\">as</span> T, instructor <span class=\"hljs-keyword\">as</span> S   <br><span class=\"hljs-keyword\">Where</span> T.salary <span class=\"hljs-operator\">&gt;</span> S.salary <span class=\"hljs-keyword\">and</span> S.dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Comp. Sci.&#x27;</span><br><span class=\"hljs-comment\">-- 利用T和S区分不同的instructor!, 实现了对同一属性的不同值的比较</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h3><p>在<code>SQL</code>中，<code>LIKE</code>运算符用于基于模式匹配对字符字符串进行比较。<code>%</code>和<code>_</code>分别用于匹配任意数量的字符和单个字符。</p>\n<p>比如查找包含“dar”子串的教师名字</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">WHERE</span> name <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;%dar%&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>如果其中需要查找实际的<code>%</code>和<code>_</code>，可以使用转义字符。<br>如下使用转义字符查询<code>100%</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span><br><span class=\"hljs-keyword\">FROM</span> some_table<br><span class=\"hljs-keyword\">WHERE</span> some_column <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;100\\%&#x27;</span> <span class=\"hljs-keyword\">ESCAPE</span> <span class=\"hljs-string\">&#x27;\\&#x27;</span>;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">&#x27;100\\%&#x27;：这个模式表示查找包含 100% 字符串的记录，而不是匹配“100”后面跟随任意字符的记录。</span><br><span class=\"hljs-comment\">ESCAPE &#x27;\\&#x27;：这部分指定了反斜杠 \\ 作为转义字符。</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p><code>LIKE</code>运算符中的模式是大小写敏感的。以下是一些常见的匹配模式示例：</p>\n<ul>\n<li><code>Intro%</code>：匹配任何以“Intro”开头的字符串。</li>\n<li><code>%Comp%</code>：匹配任何包含“Comp”作为子串的字符串。</li>\n<li><code>___</code>：匹配任何正好由三个字符组成的字符串（每个下划线代表一个字符）。</li>\n<li><code>___%</code>：匹配任何长度至少为三个字符的字符串。</li>\n</ul>\n<p><code>SQL</code>中还支持多种字符串操作，常见的包括：</p>\n<ul>\n<li><p><strong>拼接</strong> 使用$||$用于将多个字符串连接成一个</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> first_name <span class=\"hljs-operator\">||</span> <span class=\"hljs-string\">&#x27; &#x27;</span> <span class=\"hljs-operator\">||</span> last_name <span class=\"hljs-keyword\">AS</span> full_name<br><span class=\"hljs-keyword\">FROM</span> employees;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>转换大小写</strong> 使用<code>UPPER</code>和<code>LOWER</code>函数将字符串转换为大写或小写。<br>例如，将名字转换为大写：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">UPPER</span>(name)<br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<p>将名字转换为小写：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">LOWER</span>(name)<br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>查找字符串长度</strong> 使用<code>LENGTH</code>函数来查找字符串的长度。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> LENGTH(name)<br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>提取子字符串</strong>：使用<code>SUBSTRING</code>或<code>SUBSTR</code>函数提取字符串中的一部分。<br>例如，从名字中提取前两个字符:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">SUBSTRING</span>(name <span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-number\">2</span>)<br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"排序操作\"><a href=\"#排序操作\" class=\"headerlink\" title=\"排序操作\"></a>排序操作</h3><p>在<code>SQL</code>中，可以使用 <code>ORDER BY</code> 子句对查询结果进行排序。</p>\n<h4 id=\"1-按照单一属性排序\"><a href=\"#1-按照单一属性排序\" class=\"headerlink\" title=\"1. 按照单一属性排序\"></a>1. <strong>按照单一属性排序</strong></h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DISTINCT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> name <span class=\"hljs-keyword\">DESC</span>;<br></code></pre></td></tr></table></figure>\n\n<p>默认情况下，ORDER BY 会按升序（ASC）排序。如果需要按降序排序，可以使用 DESC。</p>\n<h3 id=\"2-按照多个属性排序\"><a href=\"#2-按照多个属性排序\" class=\"headerlink\" title=\"2. 按照多个属性排序\"></a>2. <strong>按照多个属性排序</strong></h3><p>可以通过指定多个列来进行排序，默认情况下会按升序排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DISTINCT</span> dept_name, name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span>  dept_name <span class=\"hljs-keyword\">ASC</span>, name <span class=\"hljs-keyword\">DESC</span>;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，首先按 dept_name 升序排序，若 dept_name 相同，则按 name 降序排序。</p>\n<h3 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h3><p>SQL 中的集合操作允许你对两个或更多的查询结果执行数学上的集合运算，包括 <code>UNION</code>（并集）、<code>INTERSECT</code>（交集）和 <code>EXCEPT</code>（差集）。这些操作符对应于关系代数中的并（$\\ucup$）、交（$\\ucap$）和差（−）运算符，并且自动去除重复的行。</p>\n<h4 id=\"1-并-Union\"><a href=\"#1-并-Union\" class=\"headerlink\" title=\"1. 并(Union)\"></a>1. <strong>并(Union)</strong></h4><p><code>UNION</code> 操作符用于合并两个查询的结果，并自动去除结果中的重复行。如果想要保留重复的行，可以使用<code>UNION ALL</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\">(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2017</span>)<br><span class=\"hljs-keyword\">UNION</span><br>(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2018</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-交-Intersect\"><a href=\"#2-交-Intersect\" class=\"headerlink\" title=\"2. 交(Intersect)\"></a>2. <strong>交(Intersect)</strong></h4><p><code>INTERSECT</code>操作符返回两个查询结果中共同的行，并自动去除重复项。要保留重复项，可以使用<code>INTERSECT ALL</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\">(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2017</span>)<br><span class=\"hljs-keyword\">INTERSECT</span><br>(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2018</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-差-Except\"><a href=\"#3-差-Except\" class=\"headerlink\" title=\"3. 差(Except)\"></a>3. <strong>差(Except)</strong></h4><p><code>EXCEPT</code>操作符返回第一个查询中的独有行，即这些行在第二个查询结果中不存在。与前两个操作符一样，<code>EXCEPT</code>默认去除重复项，但可以使用<code>EXCEPT ALL</code>来保留重复项。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\">(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2017</span>)<br><span class=\"hljs-keyword\">EXCEPT</span><br>(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2018</span>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"NULL-操作\"><a href=\"#NULL-操作\" class=\"headerlink\" title=\"NULL 操作\"></a>NULL 操作</h3><h4 id=\"1-NULL特性\"><a href=\"#1-NULL特性\" class=\"headerlink\" title=\"1. NULL特性\"></a>1. <strong>NULL特性</strong></h4><ul>\n<li><strong>未知或不存在的值</strong>：<code>NULL</code> 用来表示字段中的值未知或不存在。</li>\n<li><strong>算术运算</strong>：任何包含 <code>NULL</code> 的算术表达式的结果都是 <code>NULL</code>。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-comment\">-- 假设 x 是 NULL，5 + NULL 的结果是 NULL</span><br><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">result</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-检查NULL值\"><a href=\"#2-检查NULL值\" class=\"headerlink\" title=\"2. 检查NULL值\"></a>2. <strong>检查NULL值</strong></h4><p>要检查字段是否为 NULL，不能使用 $&#x3D;$ 或 $!&#x3D;$（不等于）。相反，必须使用<code>IS NULL</code>或<code>IS NOT NULL</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">WHERE</span> salary <span class=\"hljs-keyword\">IS</span> <span class=\"hljs-keyword\">NULL</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-NULL的逻辑操作\"><a href=\"#3-NULL的逻辑操作\" class=\"headerlink\" title=\"3. NULL的逻辑操作\"></a>3. <strong>NULL的逻辑操作</strong></h4><h5 id=\"比较操作与NULL\"><a href=\"#比较操作与NULL\" class=\"headerlink\" title=\"比较操作与NULL\"></a>比较操作与NULL</h5><p>任何试图与 <code>NULL</code> 进行比较的操作，其结果都是未知的，不是 <code>TRUE</code> 也不是 <code>FALSE</code>。</p>\n<ul>\n<li><code>5 &lt; NULL</code> 的结果是未知。</li>\n<li><code>NULL &lt;&gt; NULL</code> 的结果是未知。</li>\n<li><code>NULL = NULL</code> 的结果是未知。</li>\n</ul>\n<h5 id=\"布尔操作与NULL\"><a href=\"#布尔操作与NULL\" class=\"headerlink\" title=\"布尔操作与NULL\"></a>布尔操作与NULL</h5><p>在 SQL 中，布尔逻辑需要扩展以处理未知值。这包括 <code>AND</code>、<code>OR</code> 和 <code>NOT</code> 操作：</p>\n<ul>\n<li><p><strong>AND（与）操作</strong>：</p>\n<ul>\n<li><code>TRUE AND UNKNOWN</code> &#x3D; <code>UNKNOWN</code></li>\n<li><code>FALSE AND UNKNOWN</code> &#x3D; <code>FALSE</code></li>\n<li><code>UNKNOWN AND UNKNOWN</code> &#x3D; <code>UNKNOWN</code></li>\n</ul>\n</li>\n<li><p><strong>OR（或）操作</strong>：</p>\n<ul>\n<li><code>UNKNOWN OR TRUE</code> &#x3D; <code>TRUE</code></li>\n<li><code>UNKNOWN OR FALSE</code> &#x3D; <code>UNKNOWN</code></li>\n<li><code>UNKNOWN OR UNKNOWN</code> &#x3D; <code>UNKNOWN</code></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"WHERE-子句中的未知值处理\"><a href=\"#WHERE-子句中的未知值处理\" class=\"headerlink\" title=\"WHERE 子句中的未知值处理\"></a>WHERE 子句中的未知值处理</h5><p>在 <code>WHERE</code> 子句中，任何计算结果为未知的谓词都被视为 <code>FALSE</code>。这意味着那些涉及到 <code>NULL</code> 值的条件可能会导致记录被排除在查询结果之外，即使它们可能符合查询的其它条件。</p>\n<h3 id=\"Join操作\"><a href=\"#Join操作\" class=\"headerlink\" title=\"Join操作\"></a>Join操作</h3><p>在 SQL 中，<code>JOIN</code> 是一种在查询中结合来自两个或更多表的行的操作。根据关联的条件，可以形成几种类型的 <code>JOIN</code></p>\n<h4 id=\"1-INNER-JOIN（内连接）\"><a href=\"#1-INNER-JOIN（内连接）\" class=\"headerlink\" title=\"1. INNER JOIN（内连接）\"></a>1. <strong>INNER JOIN（内连接）</strong></h4><p><code>INNER JOIN</code> 返回两个表中满足连接条件的行。如果表中的记录在对方表中没有匹配的行，则这些记录不会出现在结果中。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> employees.name, employees.dept_id, departments.name<br><span class=\"hljs-keyword\">FROM</span> employees<br><span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span> departments <span class=\"hljs-keyword\">ON</span> employees.dept_id <span class=\"hljs-operator\">=</span> departments.id;<br></code></pre></td></tr></table></figure>\n\n<p>这里，只有那些在<code>employees</code>和<code>departments</code>表中都有对应部门<code>ID</code>的记录会被返回。</p>\n<h4 id=\"2-LEFT-JOIN（左连接）\"><a href=\"#2-LEFT-JOIN（左连接）\" class=\"headerlink\" title=\"2. LEFT JOIN（左连接）\"></a>2. <strong>LEFT JOIN（左连接）</strong></h4><p><code>LEFT JOIN</code>（或称为<code>LEFT OUTER JOIN</code>）返回左表中的所有记录和右表中的匹配记录。如果左表的行在右表中没有匹配，则这些行的右表列将包含 NULL。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> employees.name, departments.name<br><span class=\"hljs-keyword\">FROM</span> employees<br><span class=\"hljs-keyword\">LEFT</span> <span class=\"hljs-keyword\">JOIN</span> departments <span class=\"hljs-keyword\">ON</span> employees.dept_id <span class=\"hljs-operator\">=</span> departments.id;<br></code></pre></td></tr></table></figure>\n\n<p>这里，所有 employees 的记录都会显示，无论它们是否在 departments 表中有匹配的记录。</p>\n<h4 id=\"3-RIGHT-JOIN（右连接\"><a href=\"#3-RIGHT-JOIN（右连接\" class=\"headerlink\" title=\"3. RIGHT JOIN（右连接\"></a>3. <strong>RIGHT JOIN（右连接</strong></h4><p><code>RIGHT JOIN</code>（或称为<code>RIGHT OUTER JOIN</code>）返回右表中的所有记录和左表中的匹配记录。如果右表的行在左表中没有匹配，则这些行的左表列将包含<code>NULL</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> employees.name, departments.name<br><span class=\"hljs-keyword\">FROM</span> employees<br><span class=\"hljs-keyword\">RIGHT</span> <span class=\"hljs-keyword\">JOIN</span> departments <span class=\"hljs-keyword\">ON</span> employees.dept_id <span class=\"hljs-operator\">=</span> departments.id;<br></code></pre></td></tr></table></figure>\n<p>这里，所有 departments 的记录都会显示，无论它们是否在 employees 表中有匹配的记录。</p>\n<h4 id=\"4-FULL-JOIN（全连接）\"><a href=\"#4-FULL-JOIN（全连接）\" class=\"headerlink\" title=\"4. FULL JOIN（全连接）\"></a>4. <strong>FULL JOIN（全连接）</strong></h4><p><code>FULL JOIN</code>（或称为<code>FULL OUTER JOIN</code>）返回左表和右表中的所有记录。当某行在另一表中没有匹配时，会在相关列显示<code>NULL</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> employees.name, departments.name<br><span class=\"hljs-keyword\">FROM</span> employees<br><span class=\"hljs-keyword\">FULL</span> <span class=\"hljs-keyword\">JOIN</span> departments <span class=\"hljs-keyword\">ON</span> employees.dept_id <span class=\"hljs-operator\">=</span> departments.id;<br></code></pre></td></tr></table></figure>\n\n<p>这里，employees 和 departments 表中的所有记录都会显示，无论它们是否互相匹配。</p>\n<h4 id=\"5-CROSS-JOIN（交叉连接）\"><a href=\"#5-CROSS-JOIN（交叉连接）\" class=\"headerlink\" title=\"5. CROSS JOIN（交叉连接）\"></a>5. <strong>CROSS JOIN（交叉连接）</strong></h4><p><code>CROSS JOIN</code>返回两个表所有可能的行组合，也称为笛卡尔积。通常不需要<code>ON</code>子句。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> employees.name, departments.name<br><span class=\"hljs-keyword\">FROM</span> employees<br><span class=\"hljs-keyword\">CROSS</span> <span class=\"hljs-keyword\">JOIN</span> departments;<br></code></pre></td></tr></table></figure>\n\n<p>这里，每个 employees 的记录都会与 departments 的每条记录组合。</p>\n<h3 id=\"聚合函数和分组操作\"><a href=\"#聚合函数和分组操作\" class=\"headerlink\" title=\"聚合函数和分组操作\"></a>聚合函数和分组操作</h3><p>SQL 中的聚合函数对一列的值进行操作，并返回一个单一的值。这些函数特别适用于进行数据汇总和统计计算。常见的聚合函数包括：</p>\n<ul>\n<li><code>AVG</code>: 计算平均值。</li>\n<li><code>MIN</code>: 查找最小值。</li>\n<li><code>MAX</code>: 查找最大值。</li>\n<li><code>SUM</code>: 计算值的总和。</li>\n<li><code>COUNT</code>: 计算值的数量。</li>\n</ul>\n<h4 id=\"使用分组和聚合函数\"><a href=\"#使用分组和聚合函数\" class=\"headerlink\" title=\"使用分组和聚合函数\"></a>使用分组和聚合函数</h4><p>你可以结合使用 <code>GROUP BY</code> 子句和聚合函数来对数据进行分组，并对每个组应用聚合函数。可选的 <code>HAVING</code> 子句允许你设置分组后的筛选条件。</p>\n<p><strong>基本语法</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> &#123;A1, A2, ..., Ai&#125;, ag_fun(Ai<span class=\"hljs-operator\">+</span><span class=\"hljs-number\">1</span>), ..., ag_fun(Ai<span class=\"hljs-operator\">+</span>k)<br><span class=\"hljs-keyword\">FROM</span> r1, r2, ..., rm<br><span class=\"hljs-keyword\">WHERE</span> P1<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> A1, A2, ..., Ai<br><span class=\"hljs-keyword\">HAVING</span> P2;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>P1</code>是定义在<code>r1, r2, ..., rm</code>的所有属性上的条件。</li>\n<li><code>P2</code>是定义在<code>A1, A2, ..., Ai</code>上的约束，用于<code>GROUP BY</code>。</li>\n</ul>\n<p><strong>实际用例</strong>:</p>\n<ul>\n<li><p>Find average salary of instructors in Computer Science department </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">avg</span> (salary)<br><span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">where</span> dept_name<span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Comp. Sci.&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这个操作会首先提取出下表</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>name</th>\n<th>dept_name</th>\n<th><em>salary</em></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>45565</td>\n<td>Jian</td>\n<td>Comp. Sci</td>\n<td>$100</td>\n</tr>\n<tr>\n<td>74281</td>\n<td>Ye</td>\n<td>Comp. Sci</td>\n<td>$250</td>\n</tr>\n<tr>\n<td>98753</td>\n<td>Du</td>\n<td>Comp. Sci</td>\n<td>$340</td>\n</tr>\n<tr>\n<td>54123</td>\n<td>Lin</td>\n<td>Comp. Sci</td>\n<td>$200</td>\n</tr>\n</tbody></table>\n<p>然后返回其中<code>salary</code>的平均值。</p>\n</li>\n<li><p>Find total number of instructors who teach a course in Spring 2018</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">count</span> (<span class=\"hljs-keyword\">distinct</span> ID)<br><span class=\"hljs-keyword\">from</span> teaches<br><span class=\"hljs-keyword\">where</span> semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2018</span>;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>Find the number of tuples in the course relation</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">count</span> (<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">from</span> course;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"分组操作-Group-by\"><a href=\"#分组操作-Group-by\" class=\"headerlink\" title=\"分组操作(Group by)\"></a>分组操作(Group by)</h4><ul>\n<li><p>获取每个部门的平均工资</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> dept_name, <span class=\"hljs-built_in\">avg</span> (salary) <span class=\"hljs-keyword\">as</span> avg_salary<br><span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> dept_name<br><span class=\"hljs-keyword\">having</span> <span class=\"hljs-built_in\">max</span>(salary)<span class=\"hljs-operator\">&gt;</span><span class=\"hljs-number\">42000</span>;<br></code></pre></td></tr></table></figure>\n\n<p>事实上，在这个操作中，如果你使用</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> dept_name, salary<br><span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> dept_name;<br></code></pre></td></tr></table></figure>\n\n<p>其中<code>salary</code>并没有包含在聚合函数中，也没有被包含在<code>group</code>中，所以会引发错误。</p>\n<blockquote>\n<p><strong>注意</strong><br><code>having</code>子句中的谓词在组形成之后应用，而<code>where</code>子句中的谓词在形成组之前应用</p>\n</blockquote>\n</li>\n<li><p>NULL特殊情况：<br>除了 count(*) 外，所有聚合操作都会忽略在聚合属性上具有 NULL 值的元组。</p>\n</li>\n</ul>\n<h3 id=\"嵌套子句查询\"><a href=\"#嵌套子句查询\" class=\"headerlink\" title=\"嵌套子句查询\"></a>嵌套子句查询</h3><p>个人认为相似的例子在前文已经介绍了一些，所以此处只给出几个例子(当然，主要是因为这篇博客已经过长了)</p>\n<h4 id=\"1-SOME和ALL\"><a href=\"#1-SOME和ALL\" class=\"headerlink\" title=\"1. SOME和ALL\"></a>1. <strong>SOME</strong>和<strong>ALL</strong></h4><p>嵌套查询可以使用 <code>some</code>和<code>all</code>两个关键字进行查询过程中的指定，单纯字面理解，就不过多介绍。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">WHERE</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ALL</span> (<span class=\"hljs-keyword\">SELECT</span> salary<br>                    <span class=\"hljs-keyword\">FROM</span> instructor<br>                    <span class=\"hljs-keyword\">WHERE</span> dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Biology&#x27;</span>);<br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">distinct</span> course_id <span class=\"hljs-keyword\">AS</span> ID<br><span class=\"hljs-keyword\">from</span> section<br><span class=\"hljs-keyword\">where</span> semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">year</span><span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2009</span> <span class=\"hljs-keyword\">and</span> course_id  <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> <br>(<span class=\"hljs-keyword\">select</span> course_id <br><span class=\"hljs-keyword\">from</span> section <br><span class=\"hljs-keyword\">where</span> semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">year</span><span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2010</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-exists-和-not-exists\"><a href=\"#2-exists-和-not-exists\" class=\"headerlink\" title=\"2. exists 和 not exists\"></a>2. <strong>exists</strong> 和 <strong>not exists</strong></h4><p>这个操作会根据后面的子句返回<code>True</code>或者<code>False</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> course_id<br><span class=\"hljs-keyword\">from</span> section <span class=\"hljs-keyword\">as</span> S<br><span class=\"hljs-keyword\">where</span> semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2017</span> <span class=\"hljs-keyword\">and</span> <br><span class=\"hljs-keyword\">exists</span>  (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-operator\">*</span><br>        <span class=\"hljs-keyword\">from</span> section <span class=\"hljs-keyword\">as</span> T                          <br>        <span class=\"hljs-keyword\">where</span> semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">year</span><span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2018</span> <span class=\"hljs-keyword\">and</span> S.course_id <span class=\"hljs-operator\">=</span> T.course_id);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">distinct</span> S.ID, S.name<br><span class=\"hljs-keyword\">from</span> student <span class=\"hljs-keyword\">as</span> S<br><span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> ( (<span class=\"hljs-keyword\">select</span> course_id<br>                    <span class=\"hljs-keyword\">from</span> course<br>                    <span class=\"hljs-keyword\">where</span> dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Biology&#x27;</span>)<br>                    <span class=\"hljs-keyword\">except</span> (<span class=\"hljs-keyword\">select</span> T.course_id<br>                            <span class=\"hljs-keyword\">from</span> takes <span class=\"hljs-keyword\">as</span> T<br>                            <span class=\"hljs-keyword\">where</span> S.ID <span class=\"hljs-operator\">=</span> T.ID));<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-Unique操作\"><a href=\"#3-Unique操作\" class=\"headerlink\" title=\"3. Unique操作\"></a>3. <strong>Unique操作</strong></h4><p><code>UNIQUE</code>关键字用于测试子查询是否返回了不包含重复元组（行）的结果,如果不重复返回<code>True</code>,重复则返回<code>False</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> T.course_id<br><span class=\"hljs-keyword\">FROM</span> course <span class=\"hljs-keyword\">AS</span> T<br><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">UNIQUE</span> (<br>    <span class=\"hljs-keyword\">SELECT</span> R.course_id<br>    <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">AS</span> R<br>    <span class=\"hljs-keyword\">WHERE</span> T.course_id <span class=\"hljs-operator\">=</span> R.course_id<br>          <span class=\"hljs-keyword\">AND</span> R.year <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2017</span><br>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-From操作\"><a href=\"#4-From操作\" class=\"headerlink\" title=\"4. From操作\"></a>4. <strong>From操作</strong></h4><p><code>FROM</code>在此处仍然是指定查询的表，只不过这个表可以是由子句查询返回的。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> dept_name, avg_salary<br><span class=\"hljs-keyword\">from</span>   (<span class=\"hljs-keyword\">select</span> dept_name, <span class=\"hljs-built_in\">avg</span> (salary) <span class=\"hljs-keyword\">as</span> avg_salary<br>        <span class=\"hljs-keyword\">from</span> instructor          <br>        <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> dept_name) <br><span class=\"hljs-keyword\">where</span> avg_salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">42000</span><br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-With操作\"><a href=\"#5-With操作\" class=\"headerlink\" title=\"5. With操作\"></a>5. <strong>With操作</strong></h4><p><code>With</code>操作用于定义一个临时表，其中包含临时元素，用于后面的查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">WITH</span> max_budget (<span class=\"hljs-keyword\">value</span>) <span class=\"hljs-keyword\">AS</span> (<br>    <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">MAX</span>(budget)<br>    <span class=\"hljs-keyword\">FROM</span> department<br>)<br><span class=\"hljs-keyword\">SELECT</span> department.name<br><span class=\"hljs-keyword\">FROM</span> department, max_budget<br><span class=\"hljs-keyword\">WHERE</span> department.budget <span class=\"hljs-operator\">=</span> max_budget.value;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">WITH</span> ProjectCounts <span class=\"hljs-keyword\">AS</span> (<br>    <span class=\"hljs-keyword\">SELECT</span> employee_id, <span class=\"hljs-built_in\">COUNT</span>(project_id) <span class=\"hljs-keyword\">AS</span> num_projects<br>    <span class=\"hljs-keyword\">FROM</span> projects<br>    <span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> employee_id<br>),<br>ActiveEmployees <span class=\"hljs-keyword\">AS</span> (<br>    <span class=\"hljs-keyword\">SELECT</span> employee_id, name <span class=\"hljs-keyword\">AS</span> employee_name<br>    <span class=\"hljs-keyword\">FROM</span> employees<br>    <span class=\"hljs-keyword\">WHERE</span> status <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Active&#x27;</span><br>)<br><span class=\"hljs-keyword\">SELECT</span> e.employee_name <span class=\"hljs-keyword\">AS</span> name, p.num_projects <span class=\"hljs-keyword\">AS</span> project_count<br><span class=\"hljs-keyword\">FROM</span> ActiveEmployees <span class=\"hljs-keyword\">AS</span> e<br><span class=\"hljs-keyword\">JOIN</span> ProjectCounts <span class=\"hljs-keyword\">AS</span> p <span class=\"hljs-keyword\">ON</span> e.employee_id <span class=\"hljs-operator\">=</span> p.employee_id<br><span class=\"hljs-keyword\">WHERE</span> p.num_projects <span class=\"hljs-operator\">&gt;=</span> <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"标量查询操作\"><a href=\"#标量查询操作\" class=\"headerlink\" title=\"标量查询操作\"></a>标量查询操作</h4><p>在查询中过程中，可以将嵌套子句输出的标量作为查询对象，即相当于标量查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> dept_name, ( <span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">count</span>(<span class=\"hljs-operator\">*</span>) <br>                    <span class=\"hljs-keyword\">from</span> instructor <br>                    <span class=\"hljs-keyword\">where</span> department.dept_name <span class=\"hljs-operator\">=</span> instructor.dept_name )<br><span class=\"hljs-keyword\">as</span> num_instructors<br><span class=\"hljs-keyword\">from</span> department;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"嵌套操作效率\"><a href=\"#嵌套操作效率\" class=\"headerlink\" title=\"嵌套操作效率\"></a>嵌套操作效率</h3><p>很多情况下，由于多次执行嵌套内容会导致句子效率降低。所以对于SQL而言，提高执行效率的最好方式就是减少可能的嵌套语句</p>\n<p>如下给出两个<code>SQL</code>查询语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">distinct</span> T.name<br><span class=\"hljs-keyword\">from</span> instructor <span class=\"hljs-keyword\">as</span> T, instructor <span class=\"hljs-keyword\">as</span> S<br><span class=\"hljs-keyword\">where</span> T.salary <span class=\"hljs-operator\">&gt;</span> S.salary <span class=\"hljs-keyword\">and</span> S.dept name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Biology&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> name<br><span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">some</span> <br>(<span class=\"hljs-keyword\">select</span> salary<br><span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">where</span> dept name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Biology&#x27;</span>);<br><br></code></pre></td></tr></table></figure>\n\n<p>显然，前者优于后者。</p>\n<h3 id=\"数据库修改\"><a href=\"#数据库修改\" class=\"headerlink\" title=\"数据库修改\"></a>数据库修改</h3><p>数据库修改操作一般包括数据库的<code>插入</code>、<code>删除</code>和<code>更新</code></p>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p><code>delete</code>删除一条数据</p>\n<ul>\n<li><p>删除表中的所有内容</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span> instructor <br></code></pre></td></tr></table></figure>\n</li>\n<li><p>灵活的指定筛选删除数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">where</span> dept_name <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-keyword\">select</span> dept_name                                                      <br>                      <span class=\"hljs-keyword\">from</span> department        <br>                      <span class=\"hljs-keyword\">where</span> building <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Watson&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&lt;</span> (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">avg</span> (salary) <br>                  <span class=\"hljs-keyword\">from</span> instructor)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h4><p><code>insert</code>向表中插入一条数据，数据可以直接包含所有值，也可以只包含部分值，在符合域的情况下可以为<code>NULL</code></p>\n<ul>\n<li><p>插入整条数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> course <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;CS-437&#x27;</span>, <span class=\"hljs-string\">&#x27;Database Systems&#x27;</span>, <span class=\"hljs-string\">&#x27;Comp. Sci.&#x27;</span>, <span class=\"hljs-number\">4</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>插入部分数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> course (course_id, title, dept_name, credits) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;CS-437&#x27;</span>, <span class=\"hljs-string\">&#x27;Database </span><br><span class=\"hljs-string\">Systems&#x27;</span>, <span class=\"hljs-string\">&#x27;Comp. Sci.&#x27;</span>, <span class=\"hljs-number\">4</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>插入包含<code>NULL</code>的数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> student <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;3003&#x27;</span>, <span class=\"hljs-string\">&#x27;Green&#x27;</span>, <span class=\"hljs-string\">&#x27;Finance&#x27;</span>, <span class=\"hljs-keyword\">null</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>插入子句数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> instructor<br><span class=\"hljs-keyword\">SELECT</span> ID, name, dept_name, <span class=\"hljs-number\">18000</span><br><span class=\"hljs-keyword\">FROM</span> student<br><span class=\"hljs-keyword\">WHERE</span> dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Music&#x27;</span> <span class=\"hljs-keyword\">AND</span> total_cred <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">144</span>;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><h5 id=\"1-一般更新\"><a href=\"#1-一般更新\" class=\"headerlink\" title=\"1. 一般更新\"></a>1. <strong>一般更新</strong></h5><p><code>update</code>用于更新数据库表中的值<br>例子如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.05</span>;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.05</span> <br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-number\">70000</span>;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.05</span> <br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&lt;</span>  (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">avg</span> (salary) <span class=\"hljs-keyword\">from</span> instructor);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> student S<br><span class=\"hljs-keyword\">set</span> tot_cred <span class=\"hljs-operator\">=</span> ( <span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">sum</span>(credits)<br><span class=\"hljs-keyword\">from</span> takes, course<br><span class=\"hljs-keyword\">where</span> takes.course_id <span class=\"hljs-operator\">=</span> course.course_id  <span class=\"hljs-keyword\">and</span> S.ID<span class=\"hljs-operator\">=</span> takes.ID.and takes.grade <span class=\"hljs-operator\">&lt;&gt;</span> <span class=\"hljs-string\">&#x27;F&#x27;</span> <span class=\"hljs-keyword\">and</span> takes.grade <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> );<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-case-end操作\"><a href=\"#2-case-end操作\" class=\"headerlink\" title=\"2. case..end操作\"></a>2. <strong>case..end操作</strong></h5><p>对于<code>Update</code>操作，其中操作顺序非常重要，如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.03</span><br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">000</span>;<br><br><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.05</span><br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">000</span>;<br></code></pre></td></tr></table></figure>\n\n<p>比如在这个中，调换顺序会导致薪资为99999的人加薪了两次。</p>\n<p>对于这个情况，可以使用<code>case</code>来进行更新</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">case</span><br>    <span class=\"hljs-keyword\">when</span> salary <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">100000</span> <span class=\"hljs-keyword\">then</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.05</span><br>    <span class=\"hljs-keyword\">else</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.03</span><br><span class=\"hljs-keyword\">end</span>;<br></code></pre></td></tr></table></figure>\n\n<p>其中<code>case...end</code>实现了一个<code>if...else</code>的逻辑操作</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">case</span><br>    <span class=\"hljs-keyword\">when</span> <span class=\"hljs-built_in\">sum</span>(credits) <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">then</span> <span class=\"hljs-built_in\">sum</span>(credits)<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-多表更新\"><a href=\"#3-多表更新\" class=\"headerlink\" title=\"3. 多表更新\"></a>3. <strong>多表更新</strong></h4><p>给出有 <code>Student (S#, Sname, age …, C#, Grade, …)</code>, <code>SGrade (S#, C#, Grade)</code></p>\n<p>利用<code>SGrade</code>的内容，更新<code>Student</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span>     Student <span class=\"hljs-keyword\">as</span> A <br><span class=\"hljs-keyword\">set</span>        Grade<span class=\"hljs-operator\">=</span>B.Grade<br><span class=\"hljs-keyword\">from</span>       SGrade <span class=\"hljs-keyword\">as</span> B <br><span class=\"hljs-keyword\">where</span>      A.S#<span class=\"hljs-operator\">=</span>B.S# <span class=\"hljs-keyword\">and</span> A.C#<span class=\"hljs-operator\">=</span>B.C#<br></code></pre></td></tr></table></figure>\n\n","excerpt":"","more":"<p>此处额外对一些数据库操作进行展示与说明，其中涵盖文档 1~3。由于数据库语言是大小写无关的，所以此处的编写可能与前文有一点大小写的差异</p>\n<h2 id=\"基础模型定义\"><a href=\"#基础模型定义\" class=\"headerlink\" title=\"基础模型定义\"></a>基础模型定义</h2><h3 id=\"Create-Table\"><a href=\"#Create-Table\" class=\"headerlink\" title=\"Create Table\"></a>Create Table</h3><p>最基本的示例如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Create</span> <span class=\"hljs-keyword\">Table</span> r (<br>    ID          <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">5</span>),<br>    name        <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),<br>    dept_name   <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),<br>    salary      <span class=\"hljs-type\">numeric</span>(<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>)<br>);<br></code></pre></td></tr></table></figure>\n\n<p>但是对于实际使用中，需要对其添加完整性约束并且声明外键和主键</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Create</span> <span class=\"hljs-keyword\">Table</span> teacher (<br>    ID          <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">5</span>),<br>    name        <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">Not</span> <span class=\"hljs-keyword\">NULL</span>,<br>    course_id   <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">8</span>),<br>    dept_name   <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">20</span>),<br>    salary      <span class=\"hljs-type\">numeric</span>(<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">2</span>),<br>    <span class=\"hljs-keyword\">primary</span> key(ID, name),<br>    <span class=\"hljs-keyword\">foreign</span> key(dept_name) <span class=\"hljs-keyword\">References</span> department,<br>    <span class=\"hljs-keyword\">foreign</span> key(course_id) <span class=\"hljs-keyword\">References</span> section<br>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"Drop-Table\"><a href=\"#Drop-Table\" class=\"headerlink\" title=\"Drop Table\"></a>Drop Table</h3><p>直接执行<code>Drop 表名</code>就可以完成表的删除操作</p>\n<h3 id=\"Alter\"><a href=\"#Alter\" class=\"headerlink\" title=\"Alter\"></a>Alter</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Alter</span> <span class=\"hljs-keyword\">table</span> r <span class=\"hljs-keyword\">add</span> A D;<br></code></pre></td></tr></table></figure>\n\n<p>给表结构<code>r</code>增加一个名称为<code>A</code>的属性，并且其值域为<code>D</code>。执行这个操作后所有现存的数据关于属性<code>A</code>的都是<code>NULL</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Alter</span> <span class=\"hljs-keyword\">table</span> r <span class=\"hljs-keyword\">drop</span> A;<br></code></pre></td></tr></table></figure>\n\n<p>对于表<code>r</code>去除属性<code>A</code>。值得注意的是，这个去除属性的操作对于部分数据库而言是不支持的。</p>\n<p>值得注意的是，对于数据库中的数据，往往是按行存储的，这一点导致对于数据库属性的增删操作，其代价往往十分昂贵。</p>\n<h3 id=\"Select\"><a href=\"#Select\" class=\"headerlink\" title=\"Select\"></a>Select</h3><h4 id=\"1-基本查询结构\"><a href=\"#1-基本查询结构\" class=\"headerlink\" title=\"1. 基本查询结构\"></a>1. <strong>基本查询结构</strong></h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> $A_1, A_2,...,A_n$<br><span class=\"hljs-keyword\">From</span> $r_1, r_2,...,r_m$<br><span class=\"hljs-keyword\">Where</span> P;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>$A_i$是属性</li>\n<li>$r_i$是关系表</li>\n<li>$P$是筛选条件<br>对应的关系代数为<br>$$\\Pi_{A_1, A_2,…,A_n}(\\sigma_P {(r_1 \\times r_2 \\times…\\times r_m)})$$</li>\n</ul>\n<h4 id=\"2-大小写不敏感\"><a href=\"#2-大小写不敏感\" class=\"headerlink\" title=\"2. 大小写不敏感\"></a>2. <strong>大小写不敏感</strong></h4><p>其中对于属性的名称本身是大小写不敏感的，也就是存在类似于有<br>$\\text{Name} \\equiv \\text{NAME} \\equiv \\text{name}$</p>\n<h4 id=\"3-ALL与DISTINCT关键字\"><a href=\"#3-ALL与DISTINCT关键字\" class=\"headerlink\" title=\"3. ALL与DISTINCT关键字\"></a>3. <strong>ALL与DISTINCT关键字</strong></h4><p>对于<code>Select</code>操作额外的有<code>all</code>和<code>distinct</code>两个关键字，分别用于声明去除重复值和获取所有值<br>使用方式如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">Distinct</span> dept_name <span class=\"hljs-keyword\">From</span> instructor;<br><span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">ALL</span>      dept_name <span class=\"hljs-keyword\">From</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-查询所有列\"><a href=\"#4-查询所有列\" class=\"headerlink\" title=\"4. 查询所有列\"></a>4. 查询所有列</h4><p>对于<code>SELECT</code>有如下使用</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">From</span> instructor <span class=\"hljs-keyword\">Where</span> P;<br></code></pre></td></tr></table></figure>\n\n<p>这条查询会返回 instructor 表所有符合<code>P</code>情况的列和数据。</p>\n<h4 id=\"5-查询常量\"><a href=\"#5-查询常量\" class=\"headerlink\" title=\"5. 查询常量\"></a>5. <strong>查询常量</strong></h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> <span class=\"hljs-string\">&#x27;437&#x27;</span><br></code></pre></td></tr></table></figure>\n\n<p>该查询返回一个包含单列单行数据的表，列值为常量 ‘437’</p>\n<h4 id=\"6-为查询结果指定别名\"><a href=\"#6-为查询结果指定别名\" class=\"headerlink\" title=\"6. 为查询结果指定别名\"></a>6. <strong>为查询结果指定别名</strong></h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name <span class=\"hljs-keyword\">AS</span> FOO <span class=\"hljs-keyword\">From</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<p>这条查询会返回<code>instructor</code>表的<code>name</code>列，并且该列的别名为<code>FOO</code>。输出时，列名会显示为<code>FOO</code>。</p>\n<h4 id=\"7-常量与表结合\"><a href=\"#7-常量与表结合\" class=\"headerlink\" title=\"7. 常量与表结合\"></a>7. <strong>常量与表结合</strong></h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> `A` <span class=\"hljs-keyword\">From</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<p>这条查询会返回<code>instructor</code>表中每一行的<code>A</code>常量。结果的行数与<code>instructor</code>表的记录数相同，每行的值是 <code>A</code>。</p>\n<h4 id=\"8-Select-子句和算数表达式\"><a href=\"#8-Select-子句和算数表达式\" class=\"headerlink\" title=\"8. Select 子句和算数表达式\"></a>8. <strong>Select 子句和算数表达式</strong></h4><p>SELECT 子句可以包含算术表达式，这些表达式涉及加法（+）、减法（-）、乘法（*）和除法（&#x2F;），并操作常量或元组的属性。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> ID, name, salary<span class=\"hljs-operator\">/</span><span class=\"hljs-number\">12</span><br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<p>该查询返回的结果是<code>instructor</code>表的所有列，唯一的区别是<code>salary</code>列的值被除以了 12，得到了每月的薪水。</p>\n<h4 id=\"9-Where-子句和逻辑运算\"><a href=\"#9-Where-子句和逻辑运算\" class=\"headerlink\" title=\"9. Where 子句和逻辑运算\"></a>9. <strong>Where 子句和逻辑运算</strong></h4><p><code>WHERE</code> 子句用于指定查询结果必须满足的条件，它对应于关系代数中的选择谓词（Selection Predicate）。可以使用逻辑运算符 <code>AND</code>、<code>OR</code> 和 <code>NOT</code> 来组合多个条件。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">WHERE</span> dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Comp. Sci.&#x27;</span> <span class=\"hljs-keyword\">AND</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">7000</span>;<br></code></pre></td></tr></table></figure>\n\n<p>额外的存在一些其他的表达式比如<code>between and</code>和<code>Tuple comparison</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> name<br><span class=\"hljs-keyword\">From</span> instructor<br><span class=\"hljs-keyword\">Where</span> salary <span class=\"hljs-keyword\">between</span> <span class=\"hljs-number\">90000</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-number\">100000</span><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> name, course_id<br><span class=\"hljs-keyword\">From</span> instructor, teaches<br><span class=\"hljs-keyword\">Where</span> (instructor.ID, dept_name) <span class=\"hljs-operator\">=</span> (teaches.ID, <span class=\"hljs-string\">&#x27;Biology&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"10-多表联合查询、\"><a href=\"#10-多表联合查询、\" class=\"headerlink\" title=\"10. 多表联合查询、\"></a>10. <strong>多表联合查询</strong>、</h4><p>对于使用<code>Select</code>进行多表联合查询，其在使用中类似于关系代数$\\times$操作</p>\n<p>Find names of all instructors who have taught some course and the course_id</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> name, course_id<br><span class=\"hljs-keyword\">From</span> instructor , teaches<br><span class=\"hljs-keyword\">Where</span> instructor.ID <span class=\"hljs-operator\">=</span> teaches.ID; <br></code></pre></td></tr></table></figure>\n\n<p>Find names of all instructors in Art department who have taught some course and the course_id</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> name, course_id<br><span class=\"hljs-keyword\">From</span> instructor , teaches<br><span class=\"hljs-keyword\">Where</span> instructor.ID <span class=\"hljs-operator\">=</span> teaches.ID <span class=\"hljs-keyword\">and</span>  instructor. dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Art&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>值得注意的是，当使用Select查询多表结构时，<code>From</code>子句的数量不要过多，否则开销过于巨大，建议将表进行合并</p>\n<h3 id=\"Nature-Join\"><a href=\"#Nature-Join\" class=\"headerlink\" title=\"Nature Join\"></a>Nature Join</h3><p><code>Nature Join</code>用于<code>From</code>子句中，其使用方式如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> name, course_id<br><span class=\"hljs-keyword\">From</span> instructor <span class=\"hljs-keyword\">natural</span> <span class=\"hljs-keyword\">join</span> teaches<br><span class=\"hljs-keyword\">Where</span> instructor. dept_name <span class=\"hljs-operator\">=</span> `Art`;<br></code></pre></td></tr></table></figure>\n\n<p>相比较于直接使用笛卡尔积的形式进行多表查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> name, course_id<br><span class=\"hljs-keyword\">From</span> instructor, teaches<br><span class=\"hljs-keyword\">Where</span> instructor.ID <span class=\"hljs-operator\">=</span> teaches.ID <span class=\"hljs-keyword\">and</span>  instructor. dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Art&#x27;</span>; <br></code></pre></td></tr></table></figure>\n\n<p>使用 <code>Join</code>方法对于同名的属性进行了相关的连接合并，不会出现类似于<code>instructor.ID</code>和<code>teaches.ID</code>两个属性。同时由于自然链接，所以会合并其他同名的属性。</p>\n<h3 id=\"语法查询完整结构\"><a href=\"#语法查询完整结构\" class=\"headerlink\" title=\"语法查询完整结构\"></a>语法查询完整结构</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> &#123;<span class=\"hljs-keyword\">ALL</span> <span class=\"hljs-operator\">|</span> <span class=\"hljs-keyword\">DISTINCT</span>&#125; &#123;<span class=\"hljs-operator\">&lt;</span>column_expression1<span class=\"hljs-operator\">&gt;</span>&#125; <br><span class=\"hljs-keyword\">FROM</span> &#123;<span class=\"hljs-operator\">&lt;</span>table_name_or_view_name<span class=\"hljs-operator\">&gt;</span>&#125;<br>&#123;<span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-operator\">&lt;</span>conditional_expression1<span class=\"hljs-operator\">&gt;</span>&#125;<br>&#123;<span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-operator\">&lt;</span>column_name1<span class=\"hljs-operator\">&gt;</span> <br>    <span class=\"hljs-keyword\">HAVING</span> &#123;<span class=\"hljs-operator\">&lt;</span>conditional_expression2<span class=\"hljs-operator\">&gt;</span>&#125;<br>&#125;<br>&#123;<span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-operator\">&lt;</span>column_name2<span class=\"hljs-operator\">&gt;</span> &#123;<span class=\"hljs-keyword\">ASC</span> <span class=\"hljs-operator\">|</span> <span class=\"hljs-keyword\">DESC</span>&#125;&#125;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>GROUP BY ... Having...</code>根据某些列对查询结果进行分组。通常用于聚合函数（如<code>SUM</code>, <code>AVG</code>, <code>MAX</code>, <code>MIN</code>, <code>COUNT</code>）配合使用。<code>GROUP BY</code>后面跟的是一个或多个列名，结果将根据这些列进行分组。<code>Having</code>则用于过滤分组后的句子，其中可以包含 可以包含聚合条件，如对某个分组的总和、平均值等进行筛选。</li>\n<li><code>ORDER BY</code>子句用于排序查询结果。可以指定一个或多个列名，排序可以按多个列进行，列与列之间用逗号分隔。<ul>\n<li>ASC：升序（默认排序方式）。</li>\n<li>DESC：降序。</li>\n</ul>\n</li>\n</ul>\n<p>具体示例如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DISTINCT</span> name, department<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">WHERE</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">5000</span><br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> department<br><span class=\"hljs-keyword\">HAVING</span> <span class=\"hljs-built_in\">COUNT</span>(<span class=\"hljs-operator\">*</span>) <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> salary <span class=\"hljs-keyword\">DESC</span>;<br></code></pre></td></tr></table></figure>\n\n<p>解释：</p>\n<ul>\n<li><strong>SELECT DISTINCT</strong>: 查询中返回唯一的 <code>name</code> 和 <code>department</code> 列，去除重复行。</li>\n<li><strong>FROM instructor</strong>: 从 <code>instructor</code> 表中查询数据。</li>\n<li><strong>WHERE salary &gt; 5000</strong>: 筛选出 <code>salary</code> 大于 5000 的记录。</li>\n<li><strong>GROUP BY department</strong>: 按 <code>department</code> 列进行分组。</li>\n<li><strong>HAVING COUNT(*) &gt; 1</strong>: 仅返回那些在同一个部门内有多个教师的记录。</li>\n<li><strong>ORDER BY salary DESC</strong>: 根据 <code>salary</code> 列按降序排列结果。</li>\n</ul>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(5)/%E8%A1%A8%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F.png\" alt=\"表操作顺序\"></p>\n<h3 id=\"重命名操作\"><a href=\"#重命名操作\" class=\"headerlink\" title=\"重命名操作\"></a>重命名操作</h3><p>常见的重命名方法如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">Select</span> <span class=\"hljs-keyword\">distinct</span> T.name  <span class=\"hljs-keyword\">as</span> TeacherName<br><span class=\"hljs-keyword\">From</span> instructor <span class=\"hljs-keyword\">as</span> T, instructor <span class=\"hljs-keyword\">as</span> S   <br><span class=\"hljs-keyword\">Where</span> T.salary <span class=\"hljs-operator\">&gt;</span> S.salary <span class=\"hljs-keyword\">and</span> S.dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Comp. Sci.&#x27;</span><br><span class=\"hljs-comment\">-- 利用T和S区分不同的instructor!, 实现了对同一属性的不同值的比较</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"字符串操作\"><a href=\"#字符串操作\" class=\"headerlink\" title=\"字符串操作\"></a>字符串操作</h3><p>在<code>SQL</code>中，<code>LIKE</code>运算符用于基于模式匹配对字符字符串进行比较。<code>%</code>和<code>_</code>分别用于匹配任意数量的字符和单个字符。</p>\n<p>比如查找包含“dar”子串的教师名字</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">WHERE</span> name <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;%dar%&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>如果其中需要查找实际的<code>%</code>和<code>_</code>，可以使用转义字符。<br>如下使用转义字符查询<code>100%</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span><br><span class=\"hljs-keyword\">FROM</span> some_table<br><span class=\"hljs-keyword\">WHERE</span> some_column <span class=\"hljs-keyword\">LIKE</span> <span class=\"hljs-string\">&#x27;100\\%&#x27;</span> <span class=\"hljs-keyword\">ESCAPE</span> <span class=\"hljs-string\">&#x27;\\&#x27;</span>;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">&#x27;100\\%&#x27;：这个模式表示查找包含 100% 字符串的记录，而不是匹配“100”后面跟随任意字符的记录。</span><br><span class=\"hljs-comment\">ESCAPE &#x27;\\&#x27;：这部分指定了反斜杠 \\ 作为转义字符。</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<p><code>LIKE</code>运算符中的模式是大小写敏感的。以下是一些常见的匹配模式示例：</p>\n<ul>\n<li><code>Intro%</code>：匹配任何以“Intro”开头的字符串。</li>\n<li><code>%Comp%</code>：匹配任何包含“Comp”作为子串的字符串。</li>\n<li><code>___</code>：匹配任何正好由三个字符组成的字符串（每个下划线代表一个字符）。</li>\n<li><code>___%</code>：匹配任何长度至少为三个字符的字符串。</li>\n</ul>\n<p><code>SQL</code>中还支持多种字符串操作，常见的包括：</p>\n<ul>\n<li><p><strong>拼接</strong> 使用$||$用于将多个字符串连接成一个</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> first_name <span class=\"hljs-operator\">||</span> <span class=\"hljs-string\">&#x27; &#x27;</span> <span class=\"hljs-operator\">||</span> last_name <span class=\"hljs-keyword\">AS</span> full_name<br><span class=\"hljs-keyword\">FROM</span> employees;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>转换大小写</strong> 使用<code>UPPER</code>和<code>LOWER</code>函数将字符串转换为大写或小写。<br>例如，将名字转换为大写：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">UPPER</span>(name)<br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<p>将名字转换为小写：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">LOWER</span>(name)<br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>查找字符串长度</strong> 使用<code>LENGTH</code>函数来查找字符串的长度。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> LENGTH(name)<br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>提取子字符串</strong>：使用<code>SUBSTRING</code>或<code>SUBSTR</code>函数提取字符串中的一部分。<br>例如，从名字中提取前两个字符:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">SUBSTRING</span>(name <span class=\"hljs-keyword\">FROM</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">FOR</span> <span class=\"hljs-number\">2</span>)<br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"排序操作\"><a href=\"#排序操作\" class=\"headerlink\" title=\"排序操作\"></a>排序操作</h3><p>在<code>SQL</code>中，可以使用 <code>ORDER BY</code> 子句对查询结果进行排序。</p>\n<h4 id=\"1-按照单一属性排序\"><a href=\"#1-按照单一属性排序\" class=\"headerlink\" title=\"1. 按照单一属性排序\"></a>1. <strong>按照单一属性排序</strong></h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DISTINCT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span> name <span class=\"hljs-keyword\">DESC</span>;<br></code></pre></td></tr></table></figure>\n\n<p>默认情况下，ORDER BY 会按升序（ASC）排序。如果需要按降序排序，可以使用 DESC。</p>\n<h3 id=\"2-按照多个属性排序\"><a href=\"#2-按照多个属性排序\" class=\"headerlink\" title=\"2. 按照多个属性排序\"></a>2. <strong>按照多个属性排序</strong></h3><p>可以通过指定多个列来进行排序，默认情况下会按升序排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">DISTINCT</span> dept_name, name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">ORDER</span> <span class=\"hljs-keyword\">BY</span>  dept_name <span class=\"hljs-keyword\">ASC</span>, name <span class=\"hljs-keyword\">DESC</span>;<br></code></pre></td></tr></table></figure>\n\n<p>在这个例子中，首先按 dept_name 升序排序，若 dept_name 相同，则按 name 降序排序。</p>\n<h3 id=\"集合操作\"><a href=\"#集合操作\" class=\"headerlink\" title=\"集合操作\"></a>集合操作</h3><p>SQL 中的集合操作允许你对两个或更多的查询结果执行数学上的集合运算，包括 <code>UNION</code>（并集）、<code>INTERSECT</code>（交集）和 <code>EXCEPT</code>（差集）。这些操作符对应于关系代数中的并（$\\ucup$）、交（$\\ucap$）和差（−）运算符，并且自动去除重复的行。</p>\n<h4 id=\"1-并-Union\"><a href=\"#1-并-Union\" class=\"headerlink\" title=\"1. 并(Union)\"></a>1. <strong>并(Union)</strong></h4><p><code>UNION</code> 操作符用于合并两个查询的结果，并自动去除结果中的重复行。如果想要保留重复的行，可以使用<code>UNION ALL</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\">(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2017</span>)<br><span class=\"hljs-keyword\">UNION</span><br>(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2018</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-交-Intersect\"><a href=\"#2-交-Intersect\" class=\"headerlink\" title=\"2. 交(Intersect)\"></a>2. <strong>交(Intersect)</strong></h4><p><code>INTERSECT</code>操作符返回两个查询结果中共同的行，并自动去除重复项。要保留重复项，可以使用<code>INTERSECT ALL</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\">(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2017</span>)<br><span class=\"hljs-keyword\">INTERSECT</span><br>(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2018</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-差-Except\"><a href=\"#3-差-Except\" class=\"headerlink\" title=\"3. 差(Except)\"></a>3. <strong>差(Except)</strong></h4><p><code>EXCEPT</code>操作符返回第一个查询中的独有行，即这些行在第二个查询结果中不存在。与前两个操作符一样，<code>EXCEPT</code>默认去除重复项，但可以使用<code>EXCEPT ALL</code>来保留重复项。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\">(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2017</span>)<br><span class=\"hljs-keyword\">EXCEPT</span><br>(<span class=\"hljs-keyword\">SELECT</span> course_id <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">WHERE</span> sem <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">AND</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2018</span>);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"NULL-操作\"><a href=\"#NULL-操作\" class=\"headerlink\" title=\"NULL 操作\"></a>NULL 操作</h3><h4 id=\"1-NULL特性\"><a href=\"#1-NULL特性\" class=\"headerlink\" title=\"1. NULL特性\"></a>1. <strong>NULL特性</strong></h4><ul>\n<li><strong>未知或不存在的值</strong>：<code>NULL</code> 用来表示字段中的值未知或不存在。</li>\n<li><strong>算术运算</strong>：任何包含 <code>NULL</code> 的算术表达式的结果都是 <code>NULL</code>。</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-comment\">-- 假设 x 是 NULL，5 + NULL 的结果是 NULL</span><br><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-keyword\">result</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-检查NULL值\"><a href=\"#2-检查NULL值\" class=\"headerlink\" title=\"2. 检查NULL值\"></a>2. <strong>检查NULL值</strong></h4><p>要检查字段是否为 NULL，不能使用 $&#x3D;$ 或 $!&#x3D;$（不等于）。相反，必须使用<code>IS NULL</code>或<code>IS NOT NULL</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">WHERE</span> salary <span class=\"hljs-keyword\">IS</span> <span class=\"hljs-keyword\">NULL</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-NULL的逻辑操作\"><a href=\"#3-NULL的逻辑操作\" class=\"headerlink\" title=\"3. NULL的逻辑操作\"></a>3. <strong>NULL的逻辑操作</strong></h4><h5 id=\"比较操作与NULL\"><a href=\"#比较操作与NULL\" class=\"headerlink\" title=\"比较操作与NULL\"></a>比较操作与NULL</h5><p>任何试图与 <code>NULL</code> 进行比较的操作，其结果都是未知的，不是 <code>TRUE</code> 也不是 <code>FALSE</code>。</p>\n<ul>\n<li><code>5 &lt; NULL</code> 的结果是未知。</li>\n<li><code>NULL &lt;&gt; NULL</code> 的结果是未知。</li>\n<li><code>NULL = NULL</code> 的结果是未知。</li>\n</ul>\n<h5 id=\"布尔操作与NULL\"><a href=\"#布尔操作与NULL\" class=\"headerlink\" title=\"布尔操作与NULL\"></a>布尔操作与NULL</h5><p>在 SQL 中，布尔逻辑需要扩展以处理未知值。这包括 <code>AND</code>、<code>OR</code> 和 <code>NOT</code> 操作：</p>\n<ul>\n<li><p><strong>AND（与）操作</strong>：</p>\n<ul>\n<li><code>TRUE AND UNKNOWN</code> &#x3D; <code>UNKNOWN</code></li>\n<li><code>FALSE AND UNKNOWN</code> &#x3D; <code>FALSE</code></li>\n<li><code>UNKNOWN AND UNKNOWN</code> &#x3D; <code>UNKNOWN</code></li>\n</ul>\n</li>\n<li><p><strong>OR（或）操作</strong>：</p>\n<ul>\n<li><code>UNKNOWN OR TRUE</code> &#x3D; <code>TRUE</code></li>\n<li><code>UNKNOWN OR FALSE</code> &#x3D; <code>UNKNOWN</code></li>\n<li><code>UNKNOWN OR UNKNOWN</code> &#x3D; <code>UNKNOWN</code></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"WHERE-子句中的未知值处理\"><a href=\"#WHERE-子句中的未知值处理\" class=\"headerlink\" title=\"WHERE 子句中的未知值处理\"></a>WHERE 子句中的未知值处理</h5><p>在 <code>WHERE</code> 子句中，任何计算结果为未知的谓词都被视为 <code>FALSE</code>。这意味着那些涉及到 <code>NULL</code> 值的条件可能会导致记录被排除在查询结果之外，即使它们可能符合查询的其它条件。</p>\n<h3 id=\"Join操作\"><a href=\"#Join操作\" class=\"headerlink\" title=\"Join操作\"></a>Join操作</h3><p>在 SQL 中，<code>JOIN</code> 是一种在查询中结合来自两个或更多表的行的操作。根据关联的条件，可以形成几种类型的 <code>JOIN</code></p>\n<h4 id=\"1-INNER-JOIN（内连接）\"><a href=\"#1-INNER-JOIN（内连接）\" class=\"headerlink\" title=\"1. INNER JOIN（内连接）\"></a>1. <strong>INNER JOIN（内连接）</strong></h4><p><code>INNER JOIN</code> 返回两个表中满足连接条件的行。如果表中的记录在对方表中没有匹配的行，则这些记录不会出现在结果中。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> employees.name, employees.dept_id, departments.name<br><span class=\"hljs-keyword\">FROM</span> employees<br><span class=\"hljs-keyword\">INNER</span> <span class=\"hljs-keyword\">JOIN</span> departments <span class=\"hljs-keyword\">ON</span> employees.dept_id <span class=\"hljs-operator\">=</span> departments.id;<br></code></pre></td></tr></table></figure>\n\n<p>这里，只有那些在<code>employees</code>和<code>departments</code>表中都有对应部门<code>ID</code>的记录会被返回。</p>\n<h4 id=\"2-LEFT-JOIN（左连接）\"><a href=\"#2-LEFT-JOIN（左连接）\" class=\"headerlink\" title=\"2. LEFT JOIN（左连接）\"></a>2. <strong>LEFT JOIN（左连接）</strong></h4><p><code>LEFT JOIN</code>（或称为<code>LEFT OUTER JOIN</code>）返回左表中的所有记录和右表中的匹配记录。如果左表的行在右表中没有匹配，则这些行的右表列将包含 NULL。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> employees.name, departments.name<br><span class=\"hljs-keyword\">FROM</span> employees<br><span class=\"hljs-keyword\">LEFT</span> <span class=\"hljs-keyword\">JOIN</span> departments <span class=\"hljs-keyword\">ON</span> employees.dept_id <span class=\"hljs-operator\">=</span> departments.id;<br></code></pre></td></tr></table></figure>\n\n<p>这里，所有 employees 的记录都会显示，无论它们是否在 departments 表中有匹配的记录。</p>\n<h4 id=\"3-RIGHT-JOIN（右连接\"><a href=\"#3-RIGHT-JOIN（右连接\" class=\"headerlink\" title=\"3. RIGHT JOIN（右连接\"></a>3. <strong>RIGHT JOIN（右连接</strong></h4><p><code>RIGHT JOIN</code>（或称为<code>RIGHT OUTER JOIN</code>）返回右表中的所有记录和左表中的匹配记录。如果右表的行在左表中没有匹配，则这些行的左表列将包含<code>NULL</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> employees.name, departments.name<br><span class=\"hljs-keyword\">FROM</span> employees<br><span class=\"hljs-keyword\">RIGHT</span> <span class=\"hljs-keyword\">JOIN</span> departments <span class=\"hljs-keyword\">ON</span> employees.dept_id <span class=\"hljs-operator\">=</span> departments.id;<br></code></pre></td></tr></table></figure>\n<p>这里，所有 departments 的记录都会显示，无论它们是否在 employees 表中有匹配的记录。</p>\n<h4 id=\"4-FULL-JOIN（全连接）\"><a href=\"#4-FULL-JOIN（全连接）\" class=\"headerlink\" title=\"4. FULL JOIN（全连接）\"></a>4. <strong>FULL JOIN（全连接）</strong></h4><p><code>FULL JOIN</code>（或称为<code>FULL OUTER JOIN</code>）返回左表和右表中的所有记录。当某行在另一表中没有匹配时，会在相关列显示<code>NULL</code>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> employees.name, departments.name<br><span class=\"hljs-keyword\">FROM</span> employees<br><span class=\"hljs-keyword\">FULL</span> <span class=\"hljs-keyword\">JOIN</span> departments <span class=\"hljs-keyword\">ON</span> employees.dept_id <span class=\"hljs-operator\">=</span> departments.id;<br></code></pre></td></tr></table></figure>\n\n<p>这里，employees 和 departments 表中的所有记录都会显示，无论它们是否互相匹配。</p>\n<h4 id=\"5-CROSS-JOIN（交叉连接）\"><a href=\"#5-CROSS-JOIN（交叉连接）\" class=\"headerlink\" title=\"5. CROSS JOIN（交叉连接）\"></a>5. <strong>CROSS JOIN（交叉连接）</strong></h4><p><code>CROSS JOIN</code>返回两个表所有可能的行组合，也称为笛卡尔积。通常不需要<code>ON</code>子句。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> employees.name, departments.name<br><span class=\"hljs-keyword\">FROM</span> employees<br><span class=\"hljs-keyword\">CROSS</span> <span class=\"hljs-keyword\">JOIN</span> departments;<br></code></pre></td></tr></table></figure>\n\n<p>这里，每个 employees 的记录都会与 departments 的每条记录组合。</p>\n<h3 id=\"聚合函数和分组操作\"><a href=\"#聚合函数和分组操作\" class=\"headerlink\" title=\"聚合函数和分组操作\"></a>聚合函数和分组操作</h3><p>SQL 中的聚合函数对一列的值进行操作，并返回一个单一的值。这些函数特别适用于进行数据汇总和统计计算。常见的聚合函数包括：</p>\n<ul>\n<li><code>AVG</code>: 计算平均值。</li>\n<li><code>MIN</code>: 查找最小值。</li>\n<li><code>MAX</code>: 查找最大值。</li>\n<li><code>SUM</code>: 计算值的总和。</li>\n<li><code>COUNT</code>: 计算值的数量。</li>\n</ul>\n<h4 id=\"使用分组和聚合函数\"><a href=\"#使用分组和聚合函数\" class=\"headerlink\" title=\"使用分组和聚合函数\"></a>使用分组和聚合函数</h4><p>你可以结合使用 <code>GROUP BY</code> 子句和聚合函数来对数据进行分组，并对每个组应用聚合函数。可选的 <code>HAVING</code> 子句允许你设置分组后的筛选条件。</p>\n<p><strong>基本语法</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">SELECT</span> &#123;A1, A2, ..., Ai&#125;, ag_fun(Ai<span class=\"hljs-operator\">+</span><span class=\"hljs-number\">1</span>), ..., ag_fun(Ai<span class=\"hljs-operator\">+</span>k)<br><span class=\"hljs-keyword\">FROM</span> r1, r2, ..., rm<br><span class=\"hljs-keyword\">WHERE</span> P1<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> A1, A2, ..., Ai<br><span class=\"hljs-keyword\">HAVING</span> P2;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><code>P1</code>是定义在<code>r1, r2, ..., rm</code>的所有属性上的条件。</li>\n<li><code>P2</code>是定义在<code>A1, A2, ..., Ai</code>上的约束，用于<code>GROUP BY</code>。</li>\n</ul>\n<p><strong>实际用例</strong>:</p>\n<ul>\n<li><p>Find average salary of instructors in Computer Science department </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">avg</span> (salary)<br><span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">where</span> dept_name<span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Comp. Sci.&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这个操作会首先提取出下表</p>\n<table>\n<thead>\n<tr>\n<th>ID</th>\n<th>name</th>\n<th>dept_name</th>\n<th><em>salary</em></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>45565</td>\n<td>Jian</td>\n<td>Comp. Sci</td>\n<td>$100</td>\n</tr>\n<tr>\n<td>74281</td>\n<td>Ye</td>\n<td>Comp. Sci</td>\n<td>$250</td>\n</tr>\n<tr>\n<td>98753</td>\n<td>Du</td>\n<td>Comp. Sci</td>\n<td>$340</td>\n</tr>\n<tr>\n<td>54123</td>\n<td>Lin</td>\n<td>Comp. Sci</td>\n<td>$200</td>\n</tr>\n</tbody></table>\n<p>然后返回其中<code>salary</code>的平均值。</p>\n</li>\n<li><p>Find total number of instructors who teach a course in Spring 2018</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">count</span> (<span class=\"hljs-keyword\">distinct</span> ID)<br><span class=\"hljs-keyword\">from</span> teaches<br><span class=\"hljs-keyword\">where</span> semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2018</span>;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>Find the number of tuples in the course relation</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">count</span> (<span class=\"hljs-operator\">*</span>) <span class=\"hljs-keyword\">from</span> course;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"分组操作-Group-by\"><a href=\"#分组操作-Group-by\" class=\"headerlink\" title=\"分组操作(Group by)\"></a>分组操作(Group by)</h4><ul>\n<li><p>获取每个部门的平均工资</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> dept_name, <span class=\"hljs-built_in\">avg</span> (salary) <span class=\"hljs-keyword\">as</span> avg_salary<br><span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> dept_name<br><span class=\"hljs-keyword\">having</span> <span class=\"hljs-built_in\">max</span>(salary)<span class=\"hljs-operator\">&gt;</span><span class=\"hljs-number\">42000</span>;<br></code></pre></td></tr></table></figure>\n\n<p>事实上，在这个操作中，如果你使用</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> dept_name, salary<br><span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> dept_name;<br></code></pre></td></tr></table></figure>\n\n<p>其中<code>salary</code>并没有包含在聚合函数中，也没有被包含在<code>group</code>中，所以会引发错误。</p>\n<blockquote>\n<p><strong>注意</strong><br><code>having</code>子句中的谓词在组形成之后应用，而<code>where</code>子句中的谓词在形成组之前应用</p>\n</blockquote>\n</li>\n<li><p>NULL特殊情况：<br>除了 count(*) 外，所有聚合操作都会忽略在聚合属性上具有 NULL 值的元组。</p>\n</li>\n</ul>\n<h3 id=\"嵌套子句查询\"><a href=\"#嵌套子句查询\" class=\"headerlink\" title=\"嵌套子句查询\"></a>嵌套子句查询</h3><p>个人认为相似的例子在前文已经介绍了一些，所以此处只给出几个例子(当然，主要是因为这篇博客已经过长了)</p>\n<h4 id=\"1-SOME和ALL\"><a href=\"#1-SOME和ALL\" class=\"headerlink\" title=\"1. SOME和ALL\"></a>1. <strong>SOME</strong>和<strong>ALL</strong></h4><p>嵌套查询可以使用 <code>some</code>和<code>all</code>两个关键字进行查询过程中的指定，单纯字面理解，就不过多介绍。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">WHERE</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ALL</span> (<span class=\"hljs-keyword\">SELECT</span> salary<br>                    <span class=\"hljs-keyword\">FROM</span> instructor<br>                    <span class=\"hljs-keyword\">WHERE</span> dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Biology&#x27;</span>);<br><br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">distinct</span> course_id <span class=\"hljs-keyword\">AS</span> ID<br><span class=\"hljs-keyword\">from</span> section<br><span class=\"hljs-keyword\">where</span> semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">year</span><span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2009</span> <span class=\"hljs-keyword\">and</span> course_id  <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> <br>(<span class=\"hljs-keyword\">select</span> course_id <br><span class=\"hljs-keyword\">from</span> section <br><span class=\"hljs-keyword\">where</span> semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">year</span><span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2010</span>);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-exists-和-not-exists\"><a href=\"#2-exists-和-not-exists\" class=\"headerlink\" title=\"2. exists 和 not exists\"></a>2. <strong>exists</strong> 和 <strong>not exists</strong></h4><p>这个操作会根据后面的子句返回<code>True</code>或者<code>False</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> course_id<br><span class=\"hljs-keyword\">from</span> section <span class=\"hljs-keyword\">as</span> S<br><span class=\"hljs-keyword\">where</span> semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">year</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2017</span> <span class=\"hljs-keyword\">and</span> <br><span class=\"hljs-keyword\">exists</span>  (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-operator\">*</span><br>        <span class=\"hljs-keyword\">from</span> section <span class=\"hljs-keyword\">as</span> T                          <br>        <span class=\"hljs-keyword\">where</span> semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Spring&#x27;</span> <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">year</span><span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2018</span> <span class=\"hljs-keyword\">and</span> S.course_id <span class=\"hljs-operator\">=</span> T.course_id);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">distinct</span> S.ID, S.name<br><span class=\"hljs-keyword\">from</span> student <span class=\"hljs-keyword\">as</span> S<br><span class=\"hljs-keyword\">where</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">exists</span> ( (<span class=\"hljs-keyword\">select</span> course_id<br>                    <span class=\"hljs-keyword\">from</span> course<br>                    <span class=\"hljs-keyword\">where</span> dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Biology&#x27;</span>)<br>                    <span class=\"hljs-keyword\">except</span> (<span class=\"hljs-keyword\">select</span> T.course_id<br>                            <span class=\"hljs-keyword\">from</span> takes <span class=\"hljs-keyword\">as</span> T<br>                            <span class=\"hljs-keyword\">where</span> S.ID <span class=\"hljs-operator\">=</span> T.ID));<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-Unique操作\"><a href=\"#3-Unique操作\" class=\"headerlink\" title=\"3. Unique操作\"></a>3. <strong>Unique操作</strong></h4><p><code>UNIQUE</code>关键字用于测试子查询是否返回了不包含重复元组（行）的结果,如果不重复返回<code>True</code>,重复则返回<code>False</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> T.course_id<br><span class=\"hljs-keyword\">FROM</span> course <span class=\"hljs-keyword\">AS</span> T<br><span class=\"hljs-keyword\">WHERE</span> <span class=\"hljs-keyword\">UNIQUE</span> (<br>    <span class=\"hljs-keyword\">SELECT</span> R.course_id<br>    <span class=\"hljs-keyword\">FROM</span> section <span class=\"hljs-keyword\">AS</span> R<br>    <span class=\"hljs-keyword\">WHERE</span> T.course_id <span class=\"hljs-operator\">=</span> R.course_id<br>          <span class=\"hljs-keyword\">AND</span> R.year <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2017</span><br>)<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-From操作\"><a href=\"#4-From操作\" class=\"headerlink\" title=\"4. From操作\"></a>4. <strong>From操作</strong></h4><p><code>FROM</code>在此处仍然是指定查询的表，只不过这个表可以是由子句查询返回的。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> dept_name, avg_salary<br><span class=\"hljs-keyword\">from</span>   (<span class=\"hljs-keyword\">select</span> dept_name, <span class=\"hljs-built_in\">avg</span> (salary) <span class=\"hljs-keyword\">as</span> avg_salary<br>        <span class=\"hljs-keyword\">from</span> instructor          <br>        <span class=\"hljs-keyword\">group</span> <span class=\"hljs-keyword\">by</span> dept_name) <br><span class=\"hljs-keyword\">where</span> avg_salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">42000</span><br><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"5-With操作\"><a href=\"#5-With操作\" class=\"headerlink\" title=\"5. With操作\"></a>5. <strong>With操作</strong></h4><p><code>With</code>操作用于定义一个临时表，其中包含临时元素，用于后面的查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">WITH</span> max_budget (<span class=\"hljs-keyword\">value</span>) <span class=\"hljs-keyword\">AS</span> (<br>    <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">MAX</span>(budget)<br>    <span class=\"hljs-keyword\">FROM</span> department<br>)<br><span class=\"hljs-keyword\">SELECT</span> department.name<br><span class=\"hljs-keyword\">FROM</span> department, max_budget<br><span class=\"hljs-keyword\">WHERE</span> department.budget <span class=\"hljs-operator\">=</span> max_budget.value;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">WITH</span> ProjectCounts <span class=\"hljs-keyword\">AS</span> (<br>    <span class=\"hljs-keyword\">SELECT</span> employee_id, <span class=\"hljs-built_in\">COUNT</span>(project_id) <span class=\"hljs-keyword\">AS</span> num_projects<br>    <span class=\"hljs-keyword\">FROM</span> projects<br>    <span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> employee_id<br>),<br>ActiveEmployees <span class=\"hljs-keyword\">AS</span> (<br>    <span class=\"hljs-keyword\">SELECT</span> employee_id, name <span class=\"hljs-keyword\">AS</span> employee_name<br>    <span class=\"hljs-keyword\">FROM</span> employees<br>    <span class=\"hljs-keyword\">WHERE</span> status <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Active&#x27;</span><br>)<br><span class=\"hljs-keyword\">SELECT</span> e.employee_name <span class=\"hljs-keyword\">AS</span> name, p.num_projects <span class=\"hljs-keyword\">AS</span> project_count<br><span class=\"hljs-keyword\">FROM</span> ActiveEmployees <span class=\"hljs-keyword\">AS</span> e<br><span class=\"hljs-keyword\">JOIN</span> ProjectCounts <span class=\"hljs-keyword\">AS</span> p <span class=\"hljs-keyword\">ON</span> e.employee_id <span class=\"hljs-operator\">=</span> p.employee_id<br><span class=\"hljs-keyword\">WHERE</span> p.num_projects <span class=\"hljs-operator\">&gt;=</span> <span class=\"hljs-number\">2</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"标量查询操作\"><a href=\"#标量查询操作\" class=\"headerlink\" title=\"标量查询操作\"></a>标量查询操作</h4><p>在查询中过程中，可以将嵌套子句输出的标量作为查询对象，即相当于标量查询</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> dept_name, ( <span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">count</span>(<span class=\"hljs-operator\">*</span>) <br>                    <span class=\"hljs-keyword\">from</span> instructor <br>                    <span class=\"hljs-keyword\">where</span> department.dept_name <span class=\"hljs-operator\">=</span> instructor.dept_name )<br><span class=\"hljs-keyword\">as</span> num_instructors<br><span class=\"hljs-keyword\">from</span> department;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"嵌套操作效率\"><a href=\"#嵌套操作效率\" class=\"headerlink\" title=\"嵌套操作效率\"></a>嵌套操作效率</h3><p>很多情况下，由于多次执行嵌套内容会导致句子效率降低。所以对于SQL而言，提高执行效率的最好方式就是减少可能的嵌套语句</p>\n<p>如下给出两个<code>SQL</code>查询语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">distinct</span> T.name<br><span class=\"hljs-keyword\">from</span> instructor <span class=\"hljs-keyword\">as</span> T, instructor <span class=\"hljs-keyword\">as</span> S<br><span class=\"hljs-keyword\">where</span> T.salary <span class=\"hljs-operator\">&gt;</span> S.salary <span class=\"hljs-keyword\">and</span> S.dept name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Biology&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">select</span> name<br><span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">some</span> <br>(<span class=\"hljs-keyword\">select</span> salary<br><span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">where</span> dept name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Biology&#x27;</span>);<br><br></code></pre></td></tr></table></figure>\n\n<p>显然，前者优于后者。</p>\n<h3 id=\"数据库修改\"><a href=\"#数据库修改\" class=\"headerlink\" title=\"数据库修改\"></a>数据库修改</h3><p>数据库修改操作一般包括数据库的<code>插入</code>、<code>删除</code>和<code>更新</code></p>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><p><code>delete</code>删除一条数据</p>\n<ul>\n<li><p>删除表中的所有内容</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span> instructor <br></code></pre></td></tr></table></figure>\n</li>\n<li><p>灵活的指定筛选删除数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">where</span> dept_name <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-keyword\">select</span> dept_name                                                      <br>                      <span class=\"hljs-keyword\">from</span> department        <br>                      <span class=\"hljs-keyword\">where</span> building <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Watson&#x27;</span>)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">from</span> instructor<br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&lt;</span> (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">avg</span> (salary) <br>                  <span class=\"hljs-keyword\">from</span> instructor)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"插入\"><a href=\"#插入\" class=\"headerlink\" title=\"插入\"></a>插入</h4><p><code>insert</code>向表中插入一条数据，数据可以直接包含所有值，也可以只包含部分值，在符合域的情况下可以为<code>NULL</code></p>\n<ul>\n<li><p>插入整条数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> course <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;CS-437&#x27;</span>, <span class=\"hljs-string\">&#x27;Database Systems&#x27;</span>, <span class=\"hljs-string\">&#x27;Comp. Sci.&#x27;</span>, <span class=\"hljs-number\">4</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>插入部分数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> course (course_id, title, dept_name, credits) <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;CS-437&#x27;</span>, <span class=\"hljs-string\">&#x27;Database </span><br><span class=\"hljs-string\">Systems&#x27;</span>, <span class=\"hljs-string\">&#x27;Comp. Sci.&#x27;</span>, <span class=\"hljs-number\">4</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>插入包含<code>NULL</code>的数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">insert</span> <span class=\"hljs-keyword\">into</span> student <span class=\"hljs-keyword\">values</span> (<span class=\"hljs-string\">&#x27;3003&#x27;</span>, <span class=\"hljs-string\">&#x27;Green&#x27;</span>, <span class=\"hljs-string\">&#x27;Finance&#x27;</span>, <span class=\"hljs-keyword\">null</span>);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>插入子句数据</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> instructor<br><span class=\"hljs-keyword\">SELECT</span> ID, name, dept_name, <span class=\"hljs-number\">18000</span><br><span class=\"hljs-keyword\">FROM</span> student<br><span class=\"hljs-keyword\">WHERE</span> dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Music&#x27;</span> <span class=\"hljs-keyword\">AND</span> total_cred <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">144</span>;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h4><h5 id=\"1-一般更新\"><a href=\"#1-一般更新\" class=\"headerlink\" title=\"1. 一般更新\"></a>1. <strong>一般更新</strong></h5><p><code>update</code>用于更新数据库表中的值<br>例子如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.05</span>;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.05</span> <br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-number\">70000</span>;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.05</span> <br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&lt;</span>  (<span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">avg</span> (salary) <span class=\"hljs-keyword\">from</span> instructor);<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> student S<br><span class=\"hljs-keyword\">set</span> tot_cred <span class=\"hljs-operator\">=</span> ( <span class=\"hljs-keyword\">select</span> <span class=\"hljs-built_in\">sum</span>(credits)<br><span class=\"hljs-keyword\">from</span> takes, course<br><span class=\"hljs-keyword\">where</span> takes.course_id <span class=\"hljs-operator\">=</span> course.course_id  <span class=\"hljs-keyword\">and</span> S.ID<span class=\"hljs-operator\">=</span> takes.ID.and takes.grade <span class=\"hljs-operator\">&lt;&gt;</span> <span class=\"hljs-string\">&#x27;F&#x27;</span> <span class=\"hljs-keyword\">and</span> takes.grade <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> );<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-case-end操作\"><a href=\"#2-case-end操作\" class=\"headerlink\" title=\"2. case..end操作\"></a>2. <strong>case..end操作</strong></h5><p>对于<code>Update</code>操作，其中操作顺序非常重要，如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.03</span><br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">000</span>;<br><br><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.05</span><br><span class=\"hljs-keyword\">where</span> salary <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">100</span>,<span class=\"hljs-number\">000</span>;<br></code></pre></td></tr></table></figure>\n\n<p>比如在这个中，调换顺序会导致薪资为99999的人加薪了两次。</p>\n<p>对于这个情况，可以使用<code>case</code>来进行更新</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span> instructor<br><span class=\"hljs-keyword\">set</span> salary <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">case</span><br>    <span class=\"hljs-keyword\">when</span> salary <span class=\"hljs-operator\">&lt;=</span> <span class=\"hljs-number\">100000</span> <span class=\"hljs-keyword\">then</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.05</span><br>    <span class=\"hljs-keyword\">else</span> salary <span class=\"hljs-operator\">*</span> <span class=\"hljs-number\">1.03</span><br><span class=\"hljs-keyword\">end</span>;<br></code></pre></td></tr></table></figure>\n\n<p>其中<code>case...end</code>实现了一个<code>if...else</code>的逻辑操作</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">case</span><br>    <span class=\"hljs-keyword\">when</span> <span class=\"hljs-built_in\">sum</span>(credits) <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">null</span> <span class=\"hljs-keyword\">then</span> <span class=\"hljs-built_in\">sum</span>(credits)<br>    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-number\">0</span><br><span class=\"hljs-keyword\">end</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"3-多表更新\"><a href=\"#3-多表更新\" class=\"headerlink\" title=\"3. 多表更新\"></a>3. <strong>多表更新</strong></h4><p>给出有 <code>Student (S#, Sname, age …, C#, Grade, …)</code>, <code>SGrade (S#, C#, Grade)</code></p>\n<p>利用<code>SGrade</code>的内容，更新<code>Student</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">update</span>     Student <span class=\"hljs-keyword\">as</span> A <br><span class=\"hljs-keyword\">set</span>        Grade<span class=\"hljs-operator\">=</span>B.Grade<br><span class=\"hljs-keyword\">from</span>       SGrade <span class=\"hljs-keyword\">as</span> B <br><span class=\"hljs-keyword\">where</span>      A.S#<span class=\"hljs-operator\">=</span>B.S# <span class=\"hljs-keyword\">and</span> A.C#<span class=\"hljs-operator\">=</span>B.C#<br></code></pre></td></tr></table></figure>\n\n"},{"title":"数据库(6)","date":"2024-12-22T08:33:49.000Z","_content":"\n## 视图(View)\n\n视图本身常在数据库中进行使用，用于限制对敏感或不相关数据的访问。对于一个多用户使用的`SQL`设计中，这个操作是必要且相关的。\n从理解上来看，`View`本身是对基础的`SQL`数据进行了一层封装，本质是用于方便访问查询`SQL`中的数据，但是其本身对于`SQL`的数据不进行增删改的操作。\n\n**视图的本质是对于一个或多个的投影关系。**\n![视图](/img/数据库(6)/视图映射.png)\n\n### 视图的存储与计算\n\n视图被定义为虚拟关系或虚拟表，它们在数据库系统中只存储定义，而不存储实际的数据。视图的数据是在查询执行时动态生成的，基于它的定义来实时计算得到的。\n\n- **存储方式**：数据库中只存储视图的定义，而不是视图的数据。这意味着视图所展示的数据实际上是通过执行视图定义中的 SQL 表达式动态生成的。\n- **计算方式**：视图的计算可以归约为对其定义中包含的关系代数表达式的求值。当查询涉及到视图时，数据库系统会根据视图的定义来实时地计算数据，而不是从物理存储中检索。\n\n### 视图与物化视图的区别\n\n除了普通的视图（动态视图），数据库中还存在一种称为“物化视图”的结构，这种视图不仅存储定义，同时也存储对应的数据。\n\n- 物化视图（Materialized Views）：\n  - 定义与数据存储：物化视图的定义和数据都被存储在数据库系统(`DBS`)中。这使得物化视图在查询时可以直接从物理存储中检索数据，而不需要进行复杂的计算。\n  - 性能优势：对于数据访问频繁且查询代价高的情况，物化视图可以显著提高查询性能，因为避免了每次查询时的重复计算。\n  - 维护代价：物化视图需要在基础数据更新时同步更新，这可能会增加维护成本和复杂性。\n\n### 与 WITH 子句的比较\n\n在 SQL 中，WITH 子句通常用于定义临时的结果集，这些结果集在 SQL 执行结束后不会被保留。\n\n- WITH 子句（临时表）：\n  - 临时性质：通过 WITH 子句创建的是临时表，这些表仅在 SQL 执行的上下文中存在，执行结束后将被自动销毁。\n  - 使用场景：适用于需要临时组织或转换数据以供后续查询使用的情况，特别是在复杂的查询中。\n\n通过对比视图、物化视图和 WITH 子句创建的临时表，我们可以更深入地理解这些数据库对象的用途和适用场景，以及它们在数据管理和性能优化中的作用。\n\n### 创建和使用视图\n\n视图是通过`CREATE VIEW`语句定义的，它允许用户保存`SQL`表达式，以便重复使用。视图本质上是一个虚拟的表，其内容由`SQL`查询表达式定义，但它并不在数据库中以物理形式存储数据。\n\n#### 视图的定义\n\n视图的创建语法如下\n\n```SQL\nCREATE VIEW view_name AS\n<query_expression>;\n```\n\n其中`view_name`是视图的名称，<query_expression> 是定义视图内容的 SQL 表达式。\n\n**示例1: 创建视图隐藏敏感信息**\n例如，如果我们想创建一个视图来展示教师信息，但不包括薪资信息，可以使用以下`SQL`命令：\n\n```SQL\nCREATE VIEW faculty AS\nSELECT ID, name, dept_name\nFROM instructor;\n```\n\n这个视图`faculty`包括了教师的 ID、姓名和所在部门，但故意省略了薪资信息以保护敏感数据。\n\n**示例2：查询特定部门的教师**\n基于上述视图，如果需要找出生物学部门的所有教师，可以简单地执行以下查询：\n\n```SQL\nSELECT name\nFROM faculty\nWHERE dept_name = 'Biology';\n```\n\n这个查询利用了`faculty`视图，它从视图中检索生物学部门的所有教师，而不直接从原始的`instructor` 表中查询。\n\n**示例3: 创建视图统计部门薪资总和**\n还可以创建一个视图来计算每个部门的薪资总和，这对于管理和财务分析特别有用：\n\n```SQL\nCREATE VIEW departments_total_salary (dept_name, total_salary) AS\nSELECT dept_name, SUM(salary)\nFROM instructor\nGROUP BY dept_name;\n```\n\n这个视图 departments_total_salary 提供了每个部门的总薪资，通过从 instructor 表中汇总薪资数据得到。\n\n#### 视图依赖与视图嵌套\n\n在数据库设计中，视图可以基于其他视图来创建，形成依赖关系。这种特性使得视图不仅能够隐藏复杂的 SQL 逻辑，还能构建基于已有数据抽象的新抽象。\n\n**示例1：创建基础视图**\n考虑以下 SQL 语句，它创建了一个名为 physics_fall_2019 的视图，包含 2019 年秋季学期物理系的所有课程和相应教室信息：\n\n```SQL\nCREATE VIEW physics_fall_2019 AS\nSELECT course.course_id, sec_id, building, room_number\nFROM course, section\nWHERE course.course_id = section.course_id\n    AND course.dept_name = 'Physics'\n    AND section.semester = 'Fall'\n    AND section.year = 2019;\n```\n\n**示例2: 基于已有视图创建新视图**\n接下来，基于`physics_fall_2019`视图，创建另一个视图`physics_fall_2019_watson`，只包括在 Watson 建筑中的课程：\n\n```SQL\nCREATE VIEW physics_fall_2019_watson AS\nSELECT course_id, room_number\nFROM physics_fall_2019\nWHERE building = 'Watson';\n```\n\n##### 视图依赖的定义\n\n- 直接依赖：如果一个视图 v1 在其定义中使用了另一个视图 v2，则称 v1 直接依赖于 v2。\n- 间接依赖：如果视图 v1 依赖于视图 v2，这种依赖可以是直接的，或者通过一系列其他视图的依赖链实现的。\n- 递归依赖：如果视图在定义中直接或间接依赖于它自身，则称该视图具有递归依赖。\n\n### 更新视图\n\n#### 向视图中添加数据\n\n在数据库中，视图通常是只读的，特别是当视图由复杂的查询或多个表连接生成时。然而，如果视图定义简单且直接反映了单一表的内容，向视图添加数据可能会隐式地向基础表添加数据。\n\n**示例：向视图添加元组**\n假设有一个名为 faculty 的视图，它是从 instructor 表派生而来的，仅包含教师的 ID、姓名和部门信息。如果尝试向 faculty 视图插入新数据：\n\n```SQL\nINSERT INTO faculty VALUES ('30765', 'Green', 'Music');\n```\n\n这种插入操作需要在基础的`instructor`表中反映，因为`faculty`视图直接依赖于这个表。实际插入的元组将是：\n\n```SQL\nINSERT INTO instructor VALUES ('30765', 'Green', 'Music', NULL);\n```\n\n这里的`NULL`可能代表了在`instructor`表中存在但在`faculty`视图中未显示的列（如`salary`）。此操作展示了视图可以在特定条件下用于数据插入，但必须确保所有必需字段都得到适当处理，包括那些在视图中未直接显示的字段。\n\n### 物化图(Materialized Views)\n\n#### 物化视图的创建和维护\n\n物化视图不同于普通视图，它实际存储了查询结果的数据，从而提高了查询性能，尤其是在处理复杂计算和大数据集时。\n\n**创建物化视图**\n物化视图通过在数据库中存储其查询结果，创建语法如下：\n\n```SQL\nCREATE MATERIALIZED VIEW view_name AS\nSELECT columns\nFROM tables\nWHERE conditions;\n```\n\n这个操作创建一个物理表，其中包含由定义的查询生成的所有元组。\n\n**维护物化视图**\n由于物化视图包含实际的数据，当基于该视图的表更新时，物化视图可能会过时：\n\n- **自动更新**：某些数据库系统支持物化视图的自动更新，即当底层数据变化时，物化视图会自动重新计算和更新。\n- **手动维护**：在不支持自动更新的系统中，需要手动重新生成物化视图以保持数据的最新状态。\n\n物化视图的维护是确保数据一致性的关键，尤其是在数据频繁变更的环境中。\n\n## 事务(Transactions)\n\n在数据库系统中，事务是由一系列查询和/或更新语句组成的一个执行单元，通常用于执行需要保持数据完整性的复杂操作。\n\n### 事务的定义\n\n事务是一连串的数据库操作，它们被视为一个单一的工作单元。这些操作要么全部完成，要么全部不发生，保证了数据库的完整性。\n\n### ACID 属性\n\n事务的关键特性可以总结为ACID属性：\n\n- **原子性**（Atomicity）：事务是一个不可分割的工作单元，操作要么完全完成，要么完全不发生。\n- **一致性**（Consistency）：事务确保数据库从一个一致的状态转变到另一个一致的状态。\n- **隔离性**（Isolation）：事务的执行不会被其他事务干扰。\n- **持久性**（Durability）：一旦事务提交，其结果就永久保存在数据库中。\n\n**事务的操作示例**\n以下是一个事务处理的示例，该事务涉及在两个账户间转账：\n\n```SQL\nDECLARE @transfer_name varchar(10) /* 定义事务变量 */\nSET @transfer_name = 'I-transfer-from-A-to-B' /* 命名事务 */\nBEGIN TRANSACTION @transfer_name /* 开始事务 */\nUSE ACCOUNT /* 打开数据库 ACCOUNT */\nGO /* 将上述批SQL语句提交给 SQL Server */\nUPDATE A /* 修改A账户 */\n    SET balance = balance - 50\n    WHERE branch_name = 'Brooklyn'\nUPDATE B /* 修改B账户 */\n    SET balance = balance + 50\n    WHERE branch_name = 'Brooklyn'\nGO\nCOMMIT TRANSACTION @transfer_name /* 提交事务 */\nGO\n```\n\n### 事务的开始和结束\n\n- **开始**：事务隐式地开始于执行的第一个语句。\n- **结束**：通过 COMMIT 或 ROLLBACK 语句来结束事务。\n  - **提交（Commit）**：确认所有数据修改，并将修改永久保存。\n  - **回滚（Rollback）**：撤销事务中的所有修改，恢复到事务开始前的状态。\n\n## 完整性约束(Integrity Constraints)\n\n完整性约束是数据库管理系统中用于维护数据准确性和一致性的规则和限制。它们防止无效数据的输入，并确保数据库中的数据始终保持逻辑上的正确和完整。\n\n### 定义\n\n完整性约束是自动应用的规则，用于防止数据库中的非法或不一致的信息存储。它们保护数据库免受意外损坏，确保即使在数据库修改过程中也不会丢失数据的一致性。\n\n### 分类\n\n| 类型       | 级别         | 示例                                         |\n|------------|--------------|---------------------------------------------|\n| **静态**   | 属性级别     | - 数据类型、数据格式、域约束、空值           |\n|            | 元组级别     | - 属性值间的约束、映射基数约束              |\n|            | 关系级别     | - 实体完整性、引用完整性、函数依赖           |\n| **动态**   | 属性级别     | - 更新属性值或属性定义的约束                |\n|            | 元组级别     | - 属性值间的动态约束                        |\n|            | 关系级别     | - 事务约束：原子性、一致性、隔离性、持久性   |\n\n对于此处存在有一些例子\n> E.g. 1   the salary of manager should not be lower than $1000 in Employee\n> E.g. 2   table T (x, y, z ), z =x+y, z is a derived attributes from x and y.\n> E.g. 3   the student# for table student should not be null\n> E.g. 4   the age  of students should only be added\n> E.g. 5   when  employee tuples is modified,  new.sal > old.sal + 0.5*age\n> E.g. 6   statistical  constraints\n\n### 常见的完整性约束\n\n常见的完整性约束包括\n\n- primary key                           (主键)\n- not null                              (非空)\n- unique                                (不同)\n- check (P ), where P is a predicate    (限制取值)\n\n```SQL\ncreate table section (\n    course_id       varchar (8),\n    sec_id          varchar (8),\n    semester        varchar (6),\n    year            numeric (4,0),\n    room_number     varchar (7),\n    primary key     (course_id, sec_id, semester, year),\n    check           (semester in (’Fall’, ’Winter’, ’Spring’, ’Summer’)));\n```\n\n### 参考完整性(Referential Integrity)\n\n参照完整性是数据库设计中用于维持表之间数据一致性的一种约束，它确保一个关系中的属性值（通常是外键）在另一个关系中也存在对应的属性值（通常是主键）。\n\n#### 定义和重要性\n\n参照完整性保证在一个表中引用另一个表的数据时，引用的数据必须有效存在。这是通过在外键属性上设置约束来实现的，以确保外键值在被引用的表的主键中存在。\n\n**示例**\n假设有两个表：`instructor`和`department`。`instructor`表中的`dept_name`字段是一个外键，它引用了`department`表中的`dept_name`字段（作为主键）。参照完整性约束确保每个在`instructor`表中列出的部门名称在`department`表中都有对应的记录。\n\n```SQL\n-- 示例：确保 instructor 表中的 dept_name 在 department 表中存在\nALTER TABLE instructor\nADD CONSTRAINT fk_department_name\nFOREIGN KEY (dept_name) REFERENCES department(dept_name);\n```\n\n#### 功能和操作\n\n- **删除和更新的约束**：当启用参照完整性时，不能删除或修改`department`表中的一个部门名称，如果它在`instructor`表中作为外键被引用，除非同时更新或删除引用该值的所有行。\n- **数据一致性**：通过参照完整性约束，可以避免数据孤岛的产生，即避免在引用表中存在无法对应到主表的外键值。\n\n#### 数学表述\n\n在关系代数中，参照完整性可以表示为子集关系，其中一个表的特定列是另一个表特定列的子集。\n\n- **表达式**\n  - 例如，如果`course`表中的`dept_name`是外键，那么所有在`course`表中的`dept_name`值必须是`department`表中`dept_name`值的子集：\n  $$\n  \\Pi_{dept\\_name}(course)  \\in \\Pi_{dept\\_name}(department) \n  $$\n  \n  - 这里，$\\Pi$符号代表投影操作，用于提取指定的列。\n\n### 级联操作\n\n#### ON DELETE CASCADE\n\n- **定义**：如果主键表中的一行被删除，那么在外键表中依赖于该行的所有行也将被自动删除。\n- **用途**：这个选项用于维护数据库的参照完整性，确保不会有悬挂的引用存在于数据库中。\n\n#### ON UPDATE CASCADE\n\n- **定义**：如果主键表中的一行被更新（尤其是关键字段），那么在外键表中依赖于该行的所有行的相关字段也将被自动更新。\n- **用途**：这个选项同样用于维护数据库的参照完整性，确保外键表中的数据随主键表的更新而更新。\n\n#### 其他级联操作\n\nset null, set default\n\n### 事务过程中的完整性约束\n\n```SQL\ncreate table person (ID  char(10),\n                    name char(40), \n                    mother char(10),\n                    father  char(10),\n                    primary key ID,\n                    foreign key father references person, foreign key mother references person);\n```\n\n## 格式转换(Formatting Functions)\n\n- 数据转换需求\n  - 特定数字位数：有时数值数据需要以特定的数字位数显示，这可能需要使用零填充数字或截断到特定的小数位。\n  - 特定格式：数据可能需要以特定格式显示，例如日期格式化为“月-日-年”或“日-月-年”。这有助于在数据呈现时保持一致性，尤其是在用于报告、用户界面或进一步处理时。\n- 数据库格式化函数：\n  - MySQL：提供FORMAT函数，允许您将数字格式化为特定的小数位，有助于美化数据显示。\n  - Oracle 和 PostgreSQL：提供TO_CHAR、TO_NUMBER和TO_DATE等函数。这些函数对于数据类型转换非常灵活，可以在显示和处理数据时进行数据类型的转换和格式化。\n  - SQL Server：提供CONVERT函数，同样支持数据类型的转换和格式化，使数据更适合特定的显示或处理需求。\n\n### CAST\\CONVERT 操作\n\n`CAST`和`CONVERT`是`SQL`中用于数据类型转换的两个函数。\n\n#### CAST 函数\n\n`CAST`函数的语法比较直接，用于将一个表达式转换为指定的数据类型。其基本语法结构如下：\n\n```SQL\nCAST(expression AS data_type)\n```\n\n**参数说明：**\n\n- expression：要转换的表达式。\n- data_type：目标数据类型，可以是整数、小数、日期等。\n- 示例:\n  将字符串 '2021-12-31' 转换为日期类型：\n  \n  ```SQL\n  SELECT CAST('2021-12-31' AS DATE);\n  ```\n\n  将数字类型的字符串 '123' 转换为整型\n\n  ```SQL\n  SELECT CAST('123' AS INT);\n  ```\n\n#### CONVERT 函数\n\n`CONVERT`函数功能类似于`CAST`，但语法更灵活，允许在进行类型转换的同时指定一些格式设置。其基本语法结构如下：\n\n```SQL\nCONVERT(data_type, expression [, style])\n```\n\n**参数说明：**\n\n- data_type: 目标数据类型。\n- expression: 要转换的表达式。\n- style(可选): 用于日期和时间类型转换的格式代码，这个参数在`SQL Server`中特别有用，可以控制日期和时间数据的显示格式。\n- 示例:\n  将日期时间转换为格式化的字符串（SQL Server）：\n  \n  ```SQL\n  SELECT CONVERT(VARCHAR, GETDATE(), 101); -- 输出 mm/dd/yyyy 格式的日期\n  ```\n\n  将字符串 '2021-12-31' 转换为日期类型：\n\n  ```SQL\n  SELECT CONVERT(DATE, '2021-12-31');\n  ```\n\n**下面直接给出一些相关解释**  \n![格式转换_1](/img/数据库(6)/格式转换_1.png)\n![格式转换_2](/img/数据库(6)/格式转换_2.png)\n![格式转换_3](/img/数据库(6)/格式转换_3.png)\n![格式转换_4](/img/数据库(6)/格式转换_4.png)\n\n## 存储约束\n\n### 大型对象存储\n\n在数据库中，针对需要存储大量数据的场景（如照片、视频等），常使用以下两种数据类型：\n\n- **BLOB (Binary Large Object)**:\n  - 用于存储大量的未解释二进制数据。\n  - 例如，定义一个可以存储10MB大小的图像：\n  \n    ```sql\n    image BLOB(10MB)\n    ```\n\n- **CLOB (Character Large Object)**:\n  - 用于存储大量的文本数据。\n  - 例如，定义一个可以存储10KB文本数据的 CLOB：\n  \n    ```sql\n    book_view CLOB(10KB)\n    ```\n\n### XML 数据类型\n\n- XML 数据类型用于在关系数据库中存储和查询结构化的 XML 数据。\n- 示例：\n  \n  ```sql\n  CREATE TABLE book (\n      book_id INT PRIMARY KEY,\n      book_view CLOB(10KB),\n      image BLOB(10MB),\n      movie BLOB(2GB),\n      catalog XML\n  );\n  ```\n\n### 用户定义类型 (UDT)\n\n- 使用`CREATE TYPE`语句可以定义新的数据类型，用于表定义中。\n- 示例：定义一个代表货币的类型：\n\n  ```sql\n  CREATE TYPE Dollars AS NUMERIC(12,2) FINAL;\n  ```\n\n### 用户定义域\n\n- `CREATE DOMAIN`语句创建带有特定约束的自定义域，用于更细致的数据控制。\n- 示例：定义一个代表货币的类型：\n\n  ```sql\n  CREATE DOMAIN person_name CHAR(20) NOT NULL;\n  CREATE DOMAIN degree_level VARCHAR(10)\n  CONSTRAINT degree_level_test\n  CHECK (value IN ('Bachelors', 'Masters', 'Doctorate'));\n  ```\n\n## 数据库的三级层次结构\n\n在现代数据库系统中，存在一个三级层次结构，用以组织和管理数据对象，如关系和视图。这一结构提供了对数据库对象的逻辑分类和隔离，便于管理和访问。\n\n### 目录（Catalogs）\n\n- 目录也常被称为数据库（Database）。\n- 一个数据库系统可以包含多个目录，每个目录可包含多个模式（Schemas）。\n- 示例：`catalog5` 可以看作是一个目录。\n\n### 模式（Schemas）\n\n- 模式是存储关系（Relations）和视图（Views）的容器。\n- 模式对象代表了数据库对象的所有权上下文。\n- 示例：`univ_schema` 是 `catalog5` 目录中的一个模式。\n\n### 关系与视图（SQL Objects）\n\n- 关系和视图是存储在模式中的SQL对象。\n- 这些对象可以通过三部分名称来访问，例如：`catalog5.univ_schema.course`。\n\n### 数据库连接与用户环境\n\n- 要对数据库执行任何操作，用户必须首先连接到数据库。\n- 用户需要提供用户名和通常的密码来验证用户身份。\n- 每个用户都有一个默认的目录和模式，且此组合对于用户是唯一的。\n- SQL环境包括用户标识符、连接、目录和模式等。\n\n通过这种结构化的管理方式，数据库不仅能够提高数据访问的效率，还能加强数据安全性和隔离性。这对于处理大量复杂数据的企业级应用尤为重要。\n\n![数据库三层次结构](/img/数据库(6)/数据库三层次结构.png)\n\n## 断言(Assertions)\n\n断言是一个谓词表达式，用于表示数据库应始终满足的条件。例如，域约束和引用完整性约束。\n\n- 断言形式：\n  \n  ```sql\n  CREATE ASSERTION <assertion-name> CHECK <predicate>\n  ```\n\n- 断言的实施可能会导致显著的性能开销，因为数据库管理系统（DBMS）需要在每次数据库修改时验证断言的有效性。因此，应谨慎使用断言。\n\n**示例**:\n\n```SQL\nCREATE ASSERTION credits_earned_constraints CHECK (\n    NOT EXISTS (\n        SELECT ID FROM student\n        WHERE tot_cred <> (\n            SELECT SUM(credits) FROM takes NATURAL JOIN course\n            WHERE student.ID = takes.ID AND grade IS NOT NULL AND grade <> 'F'\n        )\n    )\n)\n```\n\n## 索引(Indexes)\n\n索引是一个使数据库系统能够有效找到具有特定属性值的元组的数据结构，而无需扫描整个关系的所有元组。\n\n- 创建索引的命令：\n  \n  ```SQL\n  CREATE INDEX <name> ON <relation-name> (attribute);\n  ```\n\n- 创建索引能够有效提高根据索引查找的速度，因为索引的本质是另外维护了一张图，在这个过程中并不用遍历整张表。但是这同时增加了数据库在存储上的开销\n- 一旦索引创建完成，当我们执行涉及到索引列的查询时，数据库管理系统会自动使用这个索引来加速查找过程。\n\n**示例**：\n\n``` SQL\nCREATE INDEX idx_registration_date ON students(registration_date);\nSELECT * FROM students WHERE registration_date >= '2021-01-01';\n```\n\n## 访问授权（Authorization）\n\n数据库系统中的访问授权可以控制不同用户对数据库的不同部分的访问权限。授权类型包括读取、插入、更新和删除。\n\n- 授权命令：\n  \n  ```SQL\n  GRANT <privilege list> ON <relation-name or view-name> TO <user-list>\n  ```\n\n- 数据库部分的授权形式\n  - **读取(Read)**：允许读取数据，但不能修改数据。\n  - **插入(Insert)**：允许插入新数据，但不能修改现有数据。\n  - **更新(Update)**：允许修改数据，但不能删除数据。\n  - **删除(Delete)**：允许删除数据。\n- 修改数据库架构的授权形式\n  - **资源(Resources)**：允许创建新的关系。\n  - **变更(Alteration)**：允许在关系中添加或删除属性。\n  - **删除(Drop)**：允许删除关系。\n  - **索引(Index)**：与索引相关的权限。\n- **all privileges**：所有权限\n- 用户列表内容\n  - user_id\n  - public, which allows all valid users the privilege granted\n  - 角色(role)\n\n**示例**：\n\n```SQL\ngrant select on instructor to U1, U2, U3;\n```\n\n## 创建和管理角色\n\n角色是一种用于管理权限的机制，可以简化权限的分配和管理过程。角色可以包含一组权限，并且可以被授予给用户或其他角色。\n\n### 创建角色\n\n使用`create role`语句来创建一个新的角色。例如，创建一个名为`instructor`的角色：\n\n```SQL\ncreate role instructor;\n```\n\n### 授权角色\n\n将角色授予用户，使用户可以获得该角色所拥有的权限。例如，将`instructor`角色授予用户`Amit`\n\n```SQL\ngrant instructor to Amit;\n```\n\n### 角色的权限管理\n\n可以直接向角色授权特定的数据库操作权限。例如，授予`instructor`角色在`takes`表上的选择权限：\n\n```SQL\ngrant select on takes to instructor;\n```\n\n### 角色的继承\n\n角色可以被授予给其他角色，从而实现权限的继承。例如，创建一个名为`teaching_assistant`的角色，并将其授予`instructor`角色。这样，`instructor`角色会继承`teaching_assistant`角色的所有权限：\n\n```SQL\ncreate role teaching_assistant;\ngrant teaching_assistant to instructor;\n```\n\n### 角色链\n\n角色可以形成一个授权链，其中每个角色可以被授予给其他角色。例如，创建一个`dean`角色，并将`instructor`角色授予`dean`，然后将`dean`角色授予用户`Satoshi`：\n\n```SQL\ncreate role dean;\ngrant instructor to dean;\ngrant dean to Satoshi;\n```\n\n## 视图权限\n\n视图权限和语法的使用和上述同理\n","source":"_posts/数据库-6.md","raw":"---\ntitle: 数据库(6)\ndate: 2024-12-22 16:33:49\ntags:\n    - 学习笔记\n    - 数据库\n---\n\n## 视图(View)\n\n视图本身常在数据库中进行使用，用于限制对敏感或不相关数据的访问。对于一个多用户使用的`SQL`设计中，这个操作是必要且相关的。\n从理解上来看，`View`本身是对基础的`SQL`数据进行了一层封装，本质是用于方便访问查询`SQL`中的数据，但是其本身对于`SQL`的数据不进行增删改的操作。\n\n**视图的本质是对于一个或多个的投影关系。**\n![视图](/img/数据库(6)/视图映射.png)\n\n### 视图的存储与计算\n\n视图被定义为虚拟关系或虚拟表，它们在数据库系统中只存储定义，而不存储实际的数据。视图的数据是在查询执行时动态生成的，基于它的定义来实时计算得到的。\n\n- **存储方式**：数据库中只存储视图的定义，而不是视图的数据。这意味着视图所展示的数据实际上是通过执行视图定义中的 SQL 表达式动态生成的。\n- **计算方式**：视图的计算可以归约为对其定义中包含的关系代数表达式的求值。当查询涉及到视图时，数据库系统会根据视图的定义来实时地计算数据，而不是从物理存储中检索。\n\n### 视图与物化视图的区别\n\n除了普通的视图（动态视图），数据库中还存在一种称为“物化视图”的结构，这种视图不仅存储定义，同时也存储对应的数据。\n\n- 物化视图（Materialized Views）：\n  - 定义与数据存储：物化视图的定义和数据都被存储在数据库系统(`DBS`)中。这使得物化视图在查询时可以直接从物理存储中检索数据，而不需要进行复杂的计算。\n  - 性能优势：对于数据访问频繁且查询代价高的情况，物化视图可以显著提高查询性能，因为避免了每次查询时的重复计算。\n  - 维护代价：物化视图需要在基础数据更新时同步更新，这可能会增加维护成本和复杂性。\n\n### 与 WITH 子句的比较\n\n在 SQL 中，WITH 子句通常用于定义临时的结果集，这些结果集在 SQL 执行结束后不会被保留。\n\n- WITH 子句（临时表）：\n  - 临时性质：通过 WITH 子句创建的是临时表，这些表仅在 SQL 执行的上下文中存在，执行结束后将被自动销毁。\n  - 使用场景：适用于需要临时组织或转换数据以供后续查询使用的情况，特别是在复杂的查询中。\n\n通过对比视图、物化视图和 WITH 子句创建的临时表，我们可以更深入地理解这些数据库对象的用途和适用场景，以及它们在数据管理和性能优化中的作用。\n\n### 创建和使用视图\n\n视图是通过`CREATE VIEW`语句定义的，它允许用户保存`SQL`表达式，以便重复使用。视图本质上是一个虚拟的表，其内容由`SQL`查询表达式定义，但它并不在数据库中以物理形式存储数据。\n\n#### 视图的定义\n\n视图的创建语法如下\n\n```SQL\nCREATE VIEW view_name AS\n<query_expression>;\n```\n\n其中`view_name`是视图的名称，<query_expression> 是定义视图内容的 SQL 表达式。\n\n**示例1: 创建视图隐藏敏感信息**\n例如，如果我们想创建一个视图来展示教师信息，但不包括薪资信息，可以使用以下`SQL`命令：\n\n```SQL\nCREATE VIEW faculty AS\nSELECT ID, name, dept_name\nFROM instructor;\n```\n\n这个视图`faculty`包括了教师的 ID、姓名和所在部门，但故意省略了薪资信息以保护敏感数据。\n\n**示例2：查询特定部门的教师**\n基于上述视图，如果需要找出生物学部门的所有教师，可以简单地执行以下查询：\n\n```SQL\nSELECT name\nFROM faculty\nWHERE dept_name = 'Biology';\n```\n\n这个查询利用了`faculty`视图，它从视图中检索生物学部门的所有教师，而不直接从原始的`instructor` 表中查询。\n\n**示例3: 创建视图统计部门薪资总和**\n还可以创建一个视图来计算每个部门的薪资总和，这对于管理和财务分析特别有用：\n\n```SQL\nCREATE VIEW departments_total_salary (dept_name, total_salary) AS\nSELECT dept_name, SUM(salary)\nFROM instructor\nGROUP BY dept_name;\n```\n\n这个视图 departments_total_salary 提供了每个部门的总薪资，通过从 instructor 表中汇总薪资数据得到。\n\n#### 视图依赖与视图嵌套\n\n在数据库设计中，视图可以基于其他视图来创建，形成依赖关系。这种特性使得视图不仅能够隐藏复杂的 SQL 逻辑，还能构建基于已有数据抽象的新抽象。\n\n**示例1：创建基础视图**\n考虑以下 SQL 语句，它创建了一个名为 physics_fall_2019 的视图，包含 2019 年秋季学期物理系的所有课程和相应教室信息：\n\n```SQL\nCREATE VIEW physics_fall_2019 AS\nSELECT course.course_id, sec_id, building, room_number\nFROM course, section\nWHERE course.course_id = section.course_id\n    AND course.dept_name = 'Physics'\n    AND section.semester = 'Fall'\n    AND section.year = 2019;\n```\n\n**示例2: 基于已有视图创建新视图**\n接下来，基于`physics_fall_2019`视图，创建另一个视图`physics_fall_2019_watson`，只包括在 Watson 建筑中的课程：\n\n```SQL\nCREATE VIEW physics_fall_2019_watson AS\nSELECT course_id, room_number\nFROM physics_fall_2019\nWHERE building = 'Watson';\n```\n\n##### 视图依赖的定义\n\n- 直接依赖：如果一个视图 v1 在其定义中使用了另一个视图 v2，则称 v1 直接依赖于 v2。\n- 间接依赖：如果视图 v1 依赖于视图 v2，这种依赖可以是直接的，或者通过一系列其他视图的依赖链实现的。\n- 递归依赖：如果视图在定义中直接或间接依赖于它自身，则称该视图具有递归依赖。\n\n### 更新视图\n\n#### 向视图中添加数据\n\n在数据库中，视图通常是只读的，特别是当视图由复杂的查询或多个表连接生成时。然而，如果视图定义简单且直接反映了单一表的内容，向视图添加数据可能会隐式地向基础表添加数据。\n\n**示例：向视图添加元组**\n假设有一个名为 faculty 的视图，它是从 instructor 表派生而来的，仅包含教师的 ID、姓名和部门信息。如果尝试向 faculty 视图插入新数据：\n\n```SQL\nINSERT INTO faculty VALUES ('30765', 'Green', 'Music');\n```\n\n这种插入操作需要在基础的`instructor`表中反映，因为`faculty`视图直接依赖于这个表。实际插入的元组将是：\n\n```SQL\nINSERT INTO instructor VALUES ('30765', 'Green', 'Music', NULL);\n```\n\n这里的`NULL`可能代表了在`instructor`表中存在但在`faculty`视图中未显示的列（如`salary`）。此操作展示了视图可以在特定条件下用于数据插入，但必须确保所有必需字段都得到适当处理，包括那些在视图中未直接显示的字段。\n\n### 物化图(Materialized Views)\n\n#### 物化视图的创建和维护\n\n物化视图不同于普通视图，它实际存储了查询结果的数据，从而提高了查询性能，尤其是在处理复杂计算和大数据集时。\n\n**创建物化视图**\n物化视图通过在数据库中存储其查询结果，创建语法如下：\n\n```SQL\nCREATE MATERIALIZED VIEW view_name AS\nSELECT columns\nFROM tables\nWHERE conditions;\n```\n\n这个操作创建一个物理表，其中包含由定义的查询生成的所有元组。\n\n**维护物化视图**\n由于物化视图包含实际的数据，当基于该视图的表更新时，物化视图可能会过时：\n\n- **自动更新**：某些数据库系统支持物化视图的自动更新，即当底层数据变化时，物化视图会自动重新计算和更新。\n- **手动维护**：在不支持自动更新的系统中，需要手动重新生成物化视图以保持数据的最新状态。\n\n物化视图的维护是确保数据一致性的关键，尤其是在数据频繁变更的环境中。\n\n## 事务(Transactions)\n\n在数据库系统中，事务是由一系列查询和/或更新语句组成的一个执行单元，通常用于执行需要保持数据完整性的复杂操作。\n\n### 事务的定义\n\n事务是一连串的数据库操作，它们被视为一个单一的工作单元。这些操作要么全部完成，要么全部不发生，保证了数据库的完整性。\n\n### ACID 属性\n\n事务的关键特性可以总结为ACID属性：\n\n- **原子性**（Atomicity）：事务是一个不可分割的工作单元，操作要么完全完成，要么完全不发生。\n- **一致性**（Consistency）：事务确保数据库从一个一致的状态转变到另一个一致的状态。\n- **隔离性**（Isolation）：事务的执行不会被其他事务干扰。\n- **持久性**（Durability）：一旦事务提交，其结果就永久保存在数据库中。\n\n**事务的操作示例**\n以下是一个事务处理的示例，该事务涉及在两个账户间转账：\n\n```SQL\nDECLARE @transfer_name varchar(10) /* 定义事务变量 */\nSET @transfer_name = 'I-transfer-from-A-to-B' /* 命名事务 */\nBEGIN TRANSACTION @transfer_name /* 开始事务 */\nUSE ACCOUNT /* 打开数据库 ACCOUNT */\nGO /* 将上述批SQL语句提交给 SQL Server */\nUPDATE A /* 修改A账户 */\n    SET balance = balance - 50\n    WHERE branch_name = 'Brooklyn'\nUPDATE B /* 修改B账户 */\n    SET balance = balance + 50\n    WHERE branch_name = 'Brooklyn'\nGO\nCOMMIT TRANSACTION @transfer_name /* 提交事务 */\nGO\n```\n\n### 事务的开始和结束\n\n- **开始**：事务隐式地开始于执行的第一个语句。\n- **结束**：通过 COMMIT 或 ROLLBACK 语句来结束事务。\n  - **提交（Commit）**：确认所有数据修改，并将修改永久保存。\n  - **回滚（Rollback）**：撤销事务中的所有修改，恢复到事务开始前的状态。\n\n## 完整性约束(Integrity Constraints)\n\n完整性约束是数据库管理系统中用于维护数据准确性和一致性的规则和限制。它们防止无效数据的输入，并确保数据库中的数据始终保持逻辑上的正确和完整。\n\n### 定义\n\n完整性约束是自动应用的规则，用于防止数据库中的非法或不一致的信息存储。它们保护数据库免受意外损坏，确保即使在数据库修改过程中也不会丢失数据的一致性。\n\n### 分类\n\n| 类型       | 级别         | 示例                                         |\n|------------|--------------|---------------------------------------------|\n| **静态**   | 属性级别     | - 数据类型、数据格式、域约束、空值           |\n|            | 元组级别     | - 属性值间的约束、映射基数约束              |\n|            | 关系级别     | - 实体完整性、引用完整性、函数依赖           |\n| **动态**   | 属性级别     | - 更新属性值或属性定义的约束                |\n|            | 元组级别     | - 属性值间的动态约束                        |\n|            | 关系级别     | - 事务约束：原子性、一致性、隔离性、持久性   |\n\n对于此处存在有一些例子\n> E.g. 1   the salary of manager should not be lower than $1000 in Employee\n> E.g. 2   table T (x, y, z ), z =x+y, z is a derived attributes from x and y.\n> E.g. 3   the student# for table student should not be null\n> E.g. 4   the age  of students should only be added\n> E.g. 5   when  employee tuples is modified,  new.sal > old.sal + 0.5*age\n> E.g. 6   statistical  constraints\n\n### 常见的完整性约束\n\n常见的完整性约束包括\n\n- primary key                           (主键)\n- not null                              (非空)\n- unique                                (不同)\n- check (P ), where P is a predicate    (限制取值)\n\n```SQL\ncreate table section (\n    course_id       varchar (8),\n    sec_id          varchar (8),\n    semester        varchar (6),\n    year            numeric (4,0),\n    room_number     varchar (7),\n    primary key     (course_id, sec_id, semester, year),\n    check           (semester in (’Fall’, ’Winter’, ’Spring’, ’Summer’)));\n```\n\n### 参考完整性(Referential Integrity)\n\n参照完整性是数据库设计中用于维持表之间数据一致性的一种约束，它确保一个关系中的属性值（通常是外键）在另一个关系中也存在对应的属性值（通常是主键）。\n\n#### 定义和重要性\n\n参照完整性保证在一个表中引用另一个表的数据时，引用的数据必须有效存在。这是通过在外键属性上设置约束来实现的，以确保外键值在被引用的表的主键中存在。\n\n**示例**\n假设有两个表：`instructor`和`department`。`instructor`表中的`dept_name`字段是一个外键，它引用了`department`表中的`dept_name`字段（作为主键）。参照完整性约束确保每个在`instructor`表中列出的部门名称在`department`表中都有对应的记录。\n\n```SQL\n-- 示例：确保 instructor 表中的 dept_name 在 department 表中存在\nALTER TABLE instructor\nADD CONSTRAINT fk_department_name\nFOREIGN KEY (dept_name) REFERENCES department(dept_name);\n```\n\n#### 功能和操作\n\n- **删除和更新的约束**：当启用参照完整性时，不能删除或修改`department`表中的一个部门名称，如果它在`instructor`表中作为外键被引用，除非同时更新或删除引用该值的所有行。\n- **数据一致性**：通过参照完整性约束，可以避免数据孤岛的产生，即避免在引用表中存在无法对应到主表的外键值。\n\n#### 数学表述\n\n在关系代数中，参照完整性可以表示为子集关系，其中一个表的特定列是另一个表特定列的子集。\n\n- **表达式**\n  - 例如，如果`course`表中的`dept_name`是外键，那么所有在`course`表中的`dept_name`值必须是`department`表中`dept_name`值的子集：\n  $$\n  \\Pi_{dept\\_name}(course)  \\in \\Pi_{dept\\_name}(department) \n  $$\n  \n  - 这里，$\\Pi$符号代表投影操作，用于提取指定的列。\n\n### 级联操作\n\n#### ON DELETE CASCADE\n\n- **定义**：如果主键表中的一行被删除，那么在外键表中依赖于该行的所有行也将被自动删除。\n- **用途**：这个选项用于维护数据库的参照完整性，确保不会有悬挂的引用存在于数据库中。\n\n#### ON UPDATE CASCADE\n\n- **定义**：如果主键表中的一行被更新（尤其是关键字段），那么在外键表中依赖于该行的所有行的相关字段也将被自动更新。\n- **用途**：这个选项同样用于维护数据库的参照完整性，确保外键表中的数据随主键表的更新而更新。\n\n#### 其他级联操作\n\nset null, set default\n\n### 事务过程中的完整性约束\n\n```SQL\ncreate table person (ID  char(10),\n                    name char(40), \n                    mother char(10),\n                    father  char(10),\n                    primary key ID,\n                    foreign key father references person, foreign key mother references person);\n```\n\n## 格式转换(Formatting Functions)\n\n- 数据转换需求\n  - 特定数字位数：有时数值数据需要以特定的数字位数显示，这可能需要使用零填充数字或截断到特定的小数位。\n  - 特定格式：数据可能需要以特定格式显示，例如日期格式化为“月-日-年”或“日-月-年”。这有助于在数据呈现时保持一致性，尤其是在用于报告、用户界面或进一步处理时。\n- 数据库格式化函数：\n  - MySQL：提供FORMAT函数，允许您将数字格式化为特定的小数位，有助于美化数据显示。\n  - Oracle 和 PostgreSQL：提供TO_CHAR、TO_NUMBER和TO_DATE等函数。这些函数对于数据类型转换非常灵活，可以在显示和处理数据时进行数据类型的转换和格式化。\n  - SQL Server：提供CONVERT函数，同样支持数据类型的转换和格式化，使数据更适合特定的显示或处理需求。\n\n### CAST\\CONVERT 操作\n\n`CAST`和`CONVERT`是`SQL`中用于数据类型转换的两个函数。\n\n#### CAST 函数\n\n`CAST`函数的语法比较直接，用于将一个表达式转换为指定的数据类型。其基本语法结构如下：\n\n```SQL\nCAST(expression AS data_type)\n```\n\n**参数说明：**\n\n- expression：要转换的表达式。\n- data_type：目标数据类型，可以是整数、小数、日期等。\n- 示例:\n  将字符串 '2021-12-31' 转换为日期类型：\n  \n  ```SQL\n  SELECT CAST('2021-12-31' AS DATE);\n  ```\n\n  将数字类型的字符串 '123' 转换为整型\n\n  ```SQL\n  SELECT CAST('123' AS INT);\n  ```\n\n#### CONVERT 函数\n\n`CONVERT`函数功能类似于`CAST`，但语法更灵活，允许在进行类型转换的同时指定一些格式设置。其基本语法结构如下：\n\n```SQL\nCONVERT(data_type, expression [, style])\n```\n\n**参数说明：**\n\n- data_type: 目标数据类型。\n- expression: 要转换的表达式。\n- style(可选): 用于日期和时间类型转换的格式代码，这个参数在`SQL Server`中特别有用，可以控制日期和时间数据的显示格式。\n- 示例:\n  将日期时间转换为格式化的字符串（SQL Server）：\n  \n  ```SQL\n  SELECT CONVERT(VARCHAR, GETDATE(), 101); -- 输出 mm/dd/yyyy 格式的日期\n  ```\n\n  将字符串 '2021-12-31' 转换为日期类型：\n\n  ```SQL\n  SELECT CONVERT(DATE, '2021-12-31');\n  ```\n\n**下面直接给出一些相关解释**  \n![格式转换_1](/img/数据库(6)/格式转换_1.png)\n![格式转换_2](/img/数据库(6)/格式转换_2.png)\n![格式转换_3](/img/数据库(6)/格式转换_3.png)\n![格式转换_4](/img/数据库(6)/格式转换_4.png)\n\n## 存储约束\n\n### 大型对象存储\n\n在数据库中，针对需要存储大量数据的场景（如照片、视频等），常使用以下两种数据类型：\n\n- **BLOB (Binary Large Object)**:\n  - 用于存储大量的未解释二进制数据。\n  - 例如，定义一个可以存储10MB大小的图像：\n  \n    ```sql\n    image BLOB(10MB)\n    ```\n\n- **CLOB (Character Large Object)**:\n  - 用于存储大量的文本数据。\n  - 例如，定义一个可以存储10KB文本数据的 CLOB：\n  \n    ```sql\n    book_view CLOB(10KB)\n    ```\n\n### XML 数据类型\n\n- XML 数据类型用于在关系数据库中存储和查询结构化的 XML 数据。\n- 示例：\n  \n  ```sql\n  CREATE TABLE book (\n      book_id INT PRIMARY KEY,\n      book_view CLOB(10KB),\n      image BLOB(10MB),\n      movie BLOB(2GB),\n      catalog XML\n  );\n  ```\n\n### 用户定义类型 (UDT)\n\n- 使用`CREATE TYPE`语句可以定义新的数据类型，用于表定义中。\n- 示例：定义一个代表货币的类型：\n\n  ```sql\n  CREATE TYPE Dollars AS NUMERIC(12,2) FINAL;\n  ```\n\n### 用户定义域\n\n- `CREATE DOMAIN`语句创建带有特定约束的自定义域，用于更细致的数据控制。\n- 示例：定义一个代表货币的类型：\n\n  ```sql\n  CREATE DOMAIN person_name CHAR(20) NOT NULL;\n  CREATE DOMAIN degree_level VARCHAR(10)\n  CONSTRAINT degree_level_test\n  CHECK (value IN ('Bachelors', 'Masters', 'Doctorate'));\n  ```\n\n## 数据库的三级层次结构\n\n在现代数据库系统中，存在一个三级层次结构，用以组织和管理数据对象，如关系和视图。这一结构提供了对数据库对象的逻辑分类和隔离，便于管理和访问。\n\n### 目录（Catalogs）\n\n- 目录也常被称为数据库（Database）。\n- 一个数据库系统可以包含多个目录，每个目录可包含多个模式（Schemas）。\n- 示例：`catalog5` 可以看作是一个目录。\n\n### 模式（Schemas）\n\n- 模式是存储关系（Relations）和视图（Views）的容器。\n- 模式对象代表了数据库对象的所有权上下文。\n- 示例：`univ_schema` 是 `catalog5` 目录中的一个模式。\n\n### 关系与视图（SQL Objects）\n\n- 关系和视图是存储在模式中的SQL对象。\n- 这些对象可以通过三部分名称来访问，例如：`catalog5.univ_schema.course`。\n\n### 数据库连接与用户环境\n\n- 要对数据库执行任何操作，用户必须首先连接到数据库。\n- 用户需要提供用户名和通常的密码来验证用户身份。\n- 每个用户都有一个默认的目录和模式，且此组合对于用户是唯一的。\n- SQL环境包括用户标识符、连接、目录和模式等。\n\n通过这种结构化的管理方式，数据库不仅能够提高数据访问的效率，还能加强数据安全性和隔离性。这对于处理大量复杂数据的企业级应用尤为重要。\n\n![数据库三层次结构](/img/数据库(6)/数据库三层次结构.png)\n\n## 断言(Assertions)\n\n断言是一个谓词表达式，用于表示数据库应始终满足的条件。例如，域约束和引用完整性约束。\n\n- 断言形式：\n  \n  ```sql\n  CREATE ASSERTION <assertion-name> CHECK <predicate>\n  ```\n\n- 断言的实施可能会导致显著的性能开销，因为数据库管理系统（DBMS）需要在每次数据库修改时验证断言的有效性。因此，应谨慎使用断言。\n\n**示例**:\n\n```SQL\nCREATE ASSERTION credits_earned_constraints CHECK (\n    NOT EXISTS (\n        SELECT ID FROM student\n        WHERE tot_cred <> (\n            SELECT SUM(credits) FROM takes NATURAL JOIN course\n            WHERE student.ID = takes.ID AND grade IS NOT NULL AND grade <> 'F'\n        )\n    )\n)\n```\n\n## 索引(Indexes)\n\n索引是一个使数据库系统能够有效找到具有特定属性值的元组的数据结构，而无需扫描整个关系的所有元组。\n\n- 创建索引的命令：\n  \n  ```SQL\n  CREATE INDEX <name> ON <relation-name> (attribute);\n  ```\n\n- 创建索引能够有效提高根据索引查找的速度，因为索引的本质是另外维护了一张图，在这个过程中并不用遍历整张表。但是这同时增加了数据库在存储上的开销\n- 一旦索引创建完成，当我们执行涉及到索引列的查询时，数据库管理系统会自动使用这个索引来加速查找过程。\n\n**示例**：\n\n``` SQL\nCREATE INDEX idx_registration_date ON students(registration_date);\nSELECT * FROM students WHERE registration_date >= '2021-01-01';\n```\n\n## 访问授权（Authorization）\n\n数据库系统中的访问授权可以控制不同用户对数据库的不同部分的访问权限。授权类型包括读取、插入、更新和删除。\n\n- 授权命令：\n  \n  ```SQL\n  GRANT <privilege list> ON <relation-name or view-name> TO <user-list>\n  ```\n\n- 数据库部分的授权形式\n  - **读取(Read)**：允许读取数据，但不能修改数据。\n  - **插入(Insert)**：允许插入新数据，但不能修改现有数据。\n  - **更新(Update)**：允许修改数据，但不能删除数据。\n  - **删除(Delete)**：允许删除数据。\n- 修改数据库架构的授权形式\n  - **资源(Resources)**：允许创建新的关系。\n  - **变更(Alteration)**：允许在关系中添加或删除属性。\n  - **删除(Drop)**：允许删除关系。\n  - **索引(Index)**：与索引相关的权限。\n- **all privileges**：所有权限\n- 用户列表内容\n  - user_id\n  - public, which allows all valid users the privilege granted\n  - 角色(role)\n\n**示例**：\n\n```SQL\ngrant select on instructor to U1, U2, U3;\n```\n\n## 创建和管理角色\n\n角色是一种用于管理权限的机制，可以简化权限的分配和管理过程。角色可以包含一组权限，并且可以被授予给用户或其他角色。\n\n### 创建角色\n\n使用`create role`语句来创建一个新的角色。例如，创建一个名为`instructor`的角色：\n\n```SQL\ncreate role instructor;\n```\n\n### 授权角色\n\n将角色授予用户，使用户可以获得该角色所拥有的权限。例如，将`instructor`角色授予用户`Amit`\n\n```SQL\ngrant instructor to Amit;\n```\n\n### 角色的权限管理\n\n可以直接向角色授权特定的数据库操作权限。例如，授予`instructor`角色在`takes`表上的选择权限：\n\n```SQL\ngrant select on takes to instructor;\n```\n\n### 角色的继承\n\n角色可以被授予给其他角色，从而实现权限的继承。例如，创建一个名为`teaching_assistant`的角色，并将其授予`instructor`角色。这样，`instructor`角色会继承`teaching_assistant`角色的所有权限：\n\n```SQL\ncreate role teaching_assistant;\ngrant teaching_assistant to instructor;\n```\n\n### 角色链\n\n角色可以形成一个授权链，其中每个角色可以被授予给其他角色。例如，创建一个`dean`角色，并将`instructor`角色授予`dean`，然后将`dean`角色授予用户`Satoshi`：\n\n```SQL\ncreate role dean;\ngrant instructor to dean;\ngrant dean to Satoshi;\n```\n\n## 视图权限\n\n视图权限和语法的使用和上述同理\n","slug":"数据库-6","published":1,"updated":"2024-12-23T01:08:42.460Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot7000e6d6ehchghiz8","content":"<h2 id=\"视图-View\"><a href=\"#视图-View\" class=\"headerlink\" title=\"视图(View)\"></a>视图(View)</h2><p>视图本身常在数据库中进行使用，用于限制对敏感或不相关数据的访问。对于一个多用户使用的<code>SQL</code>设计中，这个操作是必要且相关的。<br>从理解上来看，<code>View</code>本身是对基础的<code>SQL</code>数据进行了一层封装，本质是用于方便访问查询<code>SQL</code>中的数据，但是其本身对于<code>SQL</code>的数据不进行增删改的操作。</p>\n<p><strong>视图的本质是对于一个或多个的投影关系。</strong><br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E8%A7%86%E5%9B%BE%E6%98%A0%E5%B0%84.png\" alt=\"视图\"></p>\n<h3 id=\"视图的存储与计算\"><a href=\"#视图的存储与计算\" class=\"headerlink\" title=\"视图的存储与计算\"></a>视图的存储与计算</h3><p>视图被定义为虚拟关系或虚拟表，它们在数据库系统中只存储定义，而不存储实际的数据。视图的数据是在查询执行时动态生成的，基于它的定义来实时计算得到的。</p>\n<ul>\n<li><strong>存储方式</strong>：数据库中只存储视图的定义，而不是视图的数据。这意味着视图所展示的数据实际上是通过执行视图定义中的 SQL 表达式动态生成的。</li>\n<li><strong>计算方式</strong>：视图的计算可以归约为对其定义中包含的关系代数表达式的求值。当查询涉及到视图时，数据库系统会根据视图的定义来实时地计算数据，而不是从物理存储中检索。</li>\n</ul>\n<h3 id=\"视图与物化视图的区别\"><a href=\"#视图与物化视图的区别\" class=\"headerlink\" title=\"视图与物化视图的区别\"></a>视图与物化视图的区别</h3><p>除了普通的视图（动态视图），数据库中还存在一种称为“物化视图”的结构，这种视图不仅存储定义，同时也存储对应的数据。</p>\n<ul>\n<li>物化视图（Materialized Views）：<ul>\n<li>定义与数据存储：物化视图的定义和数据都被存储在数据库系统(<code>DBS</code>)中。这使得物化视图在查询时可以直接从物理存储中检索数据，而不需要进行复杂的计算。</li>\n<li>性能优势：对于数据访问频繁且查询代价高的情况，物化视图可以显著提高查询性能，因为避免了每次查询时的重复计算。</li>\n<li>维护代价：物化视图需要在基础数据更新时同步更新，这可能会增加维护成本和复杂性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与-WITH-子句的比较\"><a href=\"#与-WITH-子句的比较\" class=\"headerlink\" title=\"与 WITH 子句的比较\"></a>与 WITH 子句的比较</h3><p>在 SQL 中，WITH 子句通常用于定义临时的结果集，这些结果集在 SQL 执行结束后不会被保留。</p>\n<ul>\n<li>WITH 子句（临时表）：<ul>\n<li>临时性质：通过 WITH 子句创建的是临时表，这些表仅在 SQL 执行的上下文中存在，执行结束后将被自动销毁。</li>\n<li>使用场景：适用于需要临时组织或转换数据以供后续查询使用的情况，特别是在复杂的查询中。</li>\n</ul>\n</li>\n</ul>\n<p>通过对比视图、物化视图和 WITH 子句创建的临时表，我们可以更深入地理解这些数据库对象的用途和适用场景，以及它们在数据管理和性能优化中的作用。</p>\n<h3 id=\"创建和使用视图\"><a href=\"#创建和使用视图\" class=\"headerlink\" title=\"创建和使用视图\"></a>创建和使用视图</h3><p>视图是通过<code>CREATE VIEW</code>语句定义的，它允许用户保存<code>SQL</code>表达式，以便重复使用。视图本质上是一个虚拟的表，其内容由<code>SQL</code>查询表达式定义，但它并不在数据库中以物理形式存储数据。</p>\n<h4 id=\"视图的定义\"><a href=\"#视图的定义\" class=\"headerlink\" title=\"视图的定义\"></a>视图的定义</h4><p>视图的创建语法如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> view_name <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-operator\">&lt;</span>query_expression<span class=\"hljs-operator\">&gt;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>其中<code>view_name</code>是视图的名称，<query_expression> 是定义视图内容的 SQL 表达式。</p>\n<p><strong>示例1: 创建视图隐藏敏感信息</strong><br>例如，如果我们想创建一个视图来展示教师信息，但不包括薪资信息，可以使用以下<code>SQL</code>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> faculty <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-keyword\">SELECT</span> ID, name, dept_name<br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<p>这个视图<code>faculty</code>包括了教师的 ID、姓名和所在部门，但故意省略了薪资信息以保护敏感数据。</p>\n<p><strong>示例2：查询特定部门的教师</strong><br>基于上述视图，如果需要找出生物学部门的所有教师，可以简单地执行以下查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> faculty<br><span class=\"hljs-keyword\">WHERE</span> dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Biology&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这个查询利用了<code>faculty</code>视图，它从视图中检索生物学部门的所有教师，而不直接从原始的<code>instructor</code> 表中查询。</p>\n<p><strong>示例3: 创建视图统计部门薪资总和</strong><br>还可以创建一个视图来计算每个部门的薪资总和，这对于管理和财务分析特别有用：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> departments_total_salary (dept_name, total_salary) <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-keyword\">SELECT</span> dept_name, <span class=\"hljs-built_in\">SUM</span>(salary)<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> dept_name;<br></code></pre></td></tr></table></figure>\n\n<p>这个视图 departments_total_salary 提供了每个部门的总薪资，通过从 instructor 表中汇总薪资数据得到。</p>\n<h4 id=\"视图依赖与视图嵌套\"><a href=\"#视图依赖与视图嵌套\" class=\"headerlink\" title=\"视图依赖与视图嵌套\"></a>视图依赖与视图嵌套</h4><p>在数据库设计中，视图可以基于其他视图来创建，形成依赖关系。这种特性使得视图不仅能够隐藏复杂的 SQL 逻辑，还能构建基于已有数据抽象的新抽象。</p>\n<p><strong>示例1：创建基础视图</strong><br>考虑以下 SQL 语句，它创建了一个名为 physics_fall_2019 的视图，包含 2019 年秋季学期物理系的所有课程和相应教室信息：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> physics_fall_2019 <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-keyword\">SELECT</span> course.course_id, sec_id, building, room_number<br><span class=\"hljs-keyword\">FROM</span> course, section<br><span class=\"hljs-keyword\">WHERE</span> course.course_id <span class=\"hljs-operator\">=</span> section.course_id<br>    <span class=\"hljs-keyword\">AND</span> course.dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Physics&#x27;</span><br>    <span class=\"hljs-keyword\">AND</span> section.semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span><br>    <span class=\"hljs-keyword\">AND</span> section.year <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2019</span>;<br></code></pre></td></tr></table></figure>\n\n<p><strong>示例2: 基于已有视图创建新视图</strong><br>接下来，基于<code>physics_fall_2019</code>视图，创建另一个视图<code>physics_fall_2019_watson</code>，只包括在 Watson 建筑中的课程：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> physics_fall_2019_watson <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-keyword\">SELECT</span> course_id, room_number<br><span class=\"hljs-keyword\">FROM</span> physics_fall_2019<br><span class=\"hljs-keyword\">WHERE</span> building <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Watson&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"视图依赖的定义\"><a href=\"#视图依赖的定义\" class=\"headerlink\" title=\"视图依赖的定义\"></a>视图依赖的定义</h5><ul>\n<li>直接依赖：如果一个视图 v1 在其定义中使用了另一个视图 v2，则称 v1 直接依赖于 v2。</li>\n<li>间接依赖：如果视图 v1 依赖于视图 v2，这种依赖可以是直接的，或者通过一系列其他视图的依赖链实现的。</li>\n<li>递归依赖：如果视图在定义中直接或间接依赖于它自身，则称该视图具有递归依赖。</li>\n</ul>\n<h3 id=\"更新视图\"><a href=\"#更新视图\" class=\"headerlink\" title=\"更新视图\"></a>更新视图</h3><h4 id=\"向视图中添加数据\"><a href=\"#向视图中添加数据\" class=\"headerlink\" title=\"向视图中添加数据\"></a>向视图中添加数据</h4><p>在数据库中，视图通常是只读的，特别是当视图由复杂的查询或多个表连接生成时。然而，如果视图定义简单且直接反映了单一表的内容，向视图添加数据可能会隐式地向基础表添加数据。</p>\n<p><strong>示例：向视图添加元组</strong><br>假设有一个名为 faculty 的视图，它是从 instructor 表派生而来的，仅包含教师的 ID、姓名和部门信息。如果尝试向 faculty 视图插入新数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> faculty <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;30765&#x27;</span>, <span class=\"hljs-string\">&#x27;Green&#x27;</span>, <span class=\"hljs-string\">&#x27;Music&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>这种插入操作需要在基础的<code>instructor</code>表中反映，因为<code>faculty</code>视图直接依赖于这个表。实际插入的元组将是：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> instructor <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;30765&#x27;</span>, <span class=\"hljs-string\">&#x27;Green&#x27;</span>, <span class=\"hljs-string\">&#x27;Music&#x27;</span>, <span class=\"hljs-keyword\">NULL</span>);<br></code></pre></td></tr></table></figure>\n\n<p>这里的<code>NULL</code>可能代表了在<code>instructor</code>表中存在但在<code>faculty</code>视图中未显示的列（如<code>salary</code>）。此操作展示了视图可以在特定条件下用于数据插入，但必须确保所有必需字段都得到适当处理，包括那些在视图中未直接显示的字段。</p>\n<h3 id=\"物化图-Materialized-Views\"><a href=\"#物化图-Materialized-Views\" class=\"headerlink\" title=\"物化图(Materialized Views)\"></a>物化图(Materialized Views)</h3><h4 id=\"物化视图的创建和维护\"><a href=\"#物化视图的创建和维护\" class=\"headerlink\" title=\"物化视图的创建和维护\"></a>物化视图的创建和维护</h4><p>物化视图不同于普通视图，它实际存储了查询结果的数据，从而提高了查询性能，尤其是在处理复杂计算和大数据集时。</p>\n<p><strong>创建物化视图</strong><br>物化视图通过在数据库中存储其查询结果，创建语法如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> MATERIALIZED <span class=\"hljs-keyword\">VIEW</span> view_name <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-keyword\">SELECT</span> columns<br><span class=\"hljs-keyword\">FROM</span> tables<br><span class=\"hljs-keyword\">WHERE</span> conditions;<br></code></pre></td></tr></table></figure>\n\n<p>这个操作创建一个物理表，其中包含由定义的查询生成的所有元组。</p>\n<p><strong>维护物化视图</strong><br>由于物化视图包含实际的数据，当基于该视图的表更新时，物化视图可能会过时：</p>\n<ul>\n<li><strong>自动更新</strong>：某些数据库系统支持物化视图的自动更新，即当底层数据变化时，物化视图会自动重新计算和更新。</li>\n<li><strong>手动维护</strong>：在不支持自动更新的系统中，需要手动重新生成物化视图以保持数据的最新状态。</li>\n</ul>\n<p>物化视图的维护是确保数据一致性的关键，尤其是在数据频繁变更的环境中。</p>\n<h2 id=\"事务-Transactions\"><a href=\"#事务-Transactions\" class=\"headerlink\" title=\"事务(Transactions)\"></a>事务(Transactions)</h2><p>在数据库系统中，事务是由一系列查询和&#x2F;或更新语句组成的一个执行单元，通常用于执行需要保持数据完整性的复杂操作。</p>\n<h3 id=\"事务的定义\"><a href=\"#事务的定义\" class=\"headerlink\" title=\"事务的定义\"></a>事务的定义</h3><p>事务是一连串的数据库操作，它们被视为一个单一的工作单元。这些操作要么全部完成，要么全部不发生，保证了数据库的完整性。</p>\n<h3 id=\"ACID-属性\"><a href=\"#ACID-属性\" class=\"headerlink\" title=\"ACID 属性\"></a>ACID 属性</h3><p>事务的关键特性可以总结为ACID属性：</p>\n<ul>\n<li><strong>原子性</strong>（Atomicity）：事务是一个不可分割的工作单元，操作要么完全完成，要么完全不发生。</li>\n<li><strong>一致性</strong>（Consistency）：事务确保数据库从一个一致的状态转变到另一个一致的状态。</li>\n<li><strong>隔离性</strong>（Isolation）：事务的执行不会被其他事务干扰。</li>\n<li><strong>持久性</strong>（Durability）：一旦事务提交，其结果就永久保存在数据库中。</li>\n</ul>\n<p><strong>事务的操作示例</strong><br>以下是一个事务处理的示例，该事务涉及在两个账户间转账：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">DECLARE</span> <span class=\"hljs-variable\">@transfer_name</span> <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\">/* 定义事务变量 */</span><br><span class=\"hljs-keyword\">SET</span> <span class=\"hljs-variable\">@transfer_name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;I-transfer-from-A-to-B&#x27;</span> <span class=\"hljs-comment\">/* 命名事务 */</span><br><span class=\"hljs-keyword\">BEGIN</span> TRANSACTION <span class=\"hljs-variable\">@transfer_name</span> <span class=\"hljs-comment\">/* 开始事务 */</span><br>USE ACCOUNT <span class=\"hljs-comment\">/* 打开数据库 ACCOUNT */</span><br>GO <span class=\"hljs-comment\">/* 将上述批SQL语句提交给 SQL Server */</span><br><span class=\"hljs-keyword\">UPDATE</span> A <span class=\"hljs-comment\">/* 修改A账户 */</span><br>    <span class=\"hljs-keyword\">SET</span> balance <span class=\"hljs-operator\">=</span> balance <span class=\"hljs-operator\">-</span> <span class=\"hljs-number\">50</span><br>    <span class=\"hljs-keyword\">WHERE</span> branch_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Brooklyn&#x27;</span><br><span class=\"hljs-keyword\">UPDATE</span> B <span class=\"hljs-comment\">/* 修改B账户 */</span><br>    <span class=\"hljs-keyword\">SET</span> balance <span class=\"hljs-operator\">=</span> balance <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">50</span><br>    <span class=\"hljs-keyword\">WHERE</span> branch_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Brooklyn&#x27;</span><br>GO<br><span class=\"hljs-keyword\">COMMIT</span> TRANSACTION <span class=\"hljs-variable\">@transfer_name</span> <span class=\"hljs-comment\">/* 提交事务 */</span><br>GO<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"事务的开始和结束\"><a href=\"#事务的开始和结束\" class=\"headerlink\" title=\"事务的开始和结束\"></a>事务的开始和结束</h3><ul>\n<li><strong>开始</strong>：事务隐式地开始于执行的第一个语句。</li>\n<li><strong>结束</strong>：通过 COMMIT 或 ROLLBACK 语句来结束事务。<ul>\n<li><strong>提交（Commit）</strong>：确认所有数据修改，并将修改永久保存。</li>\n<li><strong>回滚（Rollback）</strong>：撤销事务中的所有修改，恢复到事务开始前的状态。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"完整性约束-Integrity-Constraints\"><a href=\"#完整性约束-Integrity-Constraints\" class=\"headerlink\" title=\"完整性约束(Integrity Constraints)\"></a>完整性约束(Integrity Constraints)</h2><p>完整性约束是数据库管理系统中用于维护数据准确性和一致性的规则和限制。它们防止无效数据的输入，并确保数据库中的数据始终保持逻辑上的正确和完整。</p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>完整性约束是自动应用的规则，用于防止数据库中的非法或不一致的信息存储。它们保护数据库免受意外损坏，确保即使在数据库修改过程中也不会丢失数据的一致性。</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>级别</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>静态</strong></td>\n<td>属性级别</td>\n<td>- 数据类型、数据格式、域约束、空值</td>\n</tr>\n<tr>\n<td></td>\n<td>元组级别</td>\n<td>- 属性值间的约束、映射基数约束</td>\n</tr>\n<tr>\n<td></td>\n<td>关系级别</td>\n<td>- 实体完整性、引用完整性、函数依赖</td>\n</tr>\n<tr>\n<td><strong>动态</strong></td>\n<td>属性级别</td>\n<td>- 更新属性值或属性定义的约束</td>\n</tr>\n<tr>\n<td></td>\n<td>元组级别</td>\n<td>- 属性值间的动态约束</td>\n</tr>\n<tr>\n<td></td>\n<td>关系级别</td>\n<td>- 事务约束：原子性、一致性、隔离性、持久性</td>\n</tr>\n</tbody></table>\n<p>对于此处存在有一些例子</p>\n<blockquote>\n<p>E.g. 1   the salary of manager should not be lower than $1000 in Employee<br>E.g. 2   table T (x, y, z ), z &#x3D;x+y, z is a derived attributes from x and y.<br>E.g. 3   the student# for table student should not be null<br>E.g. 4   the age  of students should only be added<br>E.g. 5   when  employee tuples is modified,  new.sal &gt; old.sal + 0.5*age<br>E.g. 6   statistical  constraints</p>\n</blockquote>\n<h3 id=\"常见的完整性约束\"><a href=\"#常见的完整性约束\" class=\"headerlink\" title=\"常见的完整性约束\"></a>常见的完整性约束</h3><p>常见的完整性约束包括</p>\n<ul>\n<li>primary key                           (主键)</li>\n<li>not null                              (非空)</li>\n<li>unique                                (不同)</li>\n<li>check (P ), where P is a predicate    (限制取值)</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> section (<br>    course_id       <span class=\"hljs-type\">varchar</span> (<span class=\"hljs-number\">8</span>),<br>    sec_id          <span class=\"hljs-type\">varchar</span> (<span class=\"hljs-number\">8</span>),<br>    semester        <span class=\"hljs-type\">varchar</span> (<span class=\"hljs-number\">6</span>),<br>    <span class=\"hljs-keyword\">year</span>            <span class=\"hljs-type\">numeric</span> (<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">0</span>),<br>    room_number     <span class=\"hljs-type\">varchar</span> (<span class=\"hljs-number\">7</span>),<br>    <span class=\"hljs-keyword\">primary</span> key     (course_id, sec_id, semester, <span class=\"hljs-keyword\">year</span>),<br>    <span class=\"hljs-keyword\">check</span>           (semester <span class=\"hljs-keyword\">in</span> (’Fall’, ’Winter’, ’Spring’, ’Summer’)));<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参考完整性-Referential-Integrity\"><a href=\"#参考完整性-Referential-Integrity\" class=\"headerlink\" title=\"参考完整性(Referential Integrity)\"></a>参考完整性(Referential Integrity)</h3><p>参照完整性是数据库设计中用于维持表之间数据一致性的一种约束，它确保一个关系中的属性值（通常是外键）在另一个关系中也存在对应的属性值（通常是主键）。</p>\n<h4 id=\"定义和重要性\"><a href=\"#定义和重要性\" class=\"headerlink\" title=\"定义和重要性\"></a>定义和重要性</h4><p>参照完整性保证在一个表中引用另一个表的数据时，引用的数据必须有效存在。这是通过在外键属性上设置约束来实现的，以确保外键值在被引用的表的主键中存在。</p>\n<p><strong>示例</strong><br>假设有两个表：<code>instructor</code>和<code>department</code>。<code>instructor</code>表中的<code>dept_name</code>字段是一个外键，它引用了<code>department</code>表中的<code>dept_name</code>字段（作为主键）。参照完整性约束确保每个在<code>instructor</code>表中列出的部门名称在<code>department</code>表中都有对应的记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-comment\">-- 示例：确保 instructor 表中的 dept_name 在 department 表中存在</span><br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> instructor<br><span class=\"hljs-keyword\">ADD</span> <span class=\"hljs-keyword\">CONSTRAINT</span> fk_department_name<br><span class=\"hljs-keyword\">FOREIGN</span> KEY (dept_name) <span class=\"hljs-keyword\">REFERENCES</span> department(dept_name);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"功能和操作\"><a href=\"#功能和操作\" class=\"headerlink\" title=\"功能和操作\"></a>功能和操作</h4><ul>\n<li><strong>删除和更新的约束</strong>：当启用参照完整性时，不能删除或修改<code>department</code>表中的一个部门名称，如果它在<code>instructor</code>表中作为外键被引用，除非同时更新或删除引用该值的所有行。</li>\n<li><strong>数据一致性</strong>：通过参照完整性约束，可以避免数据孤岛的产生，即避免在引用表中存在无法对应到主表的外键值。</li>\n</ul>\n<h4 id=\"数学表述\"><a href=\"#数学表述\" class=\"headerlink\" title=\"数学表述\"></a>数学表述</h4><p>在关系代数中，参照完整性可以表示为子集关系，其中一个表的特定列是另一个表特定列的子集。</p>\n<ul>\n<li><strong>表达式</strong><ul>\n<li><p>例如，如果<code>course</code>表中的<code>dept_name</code>是外键，那么所有在<code>course</code>表中的<code>dept_name</code>值必须是<code>department</code>表中<code>dept_name</code>值的子集：<br>$$<br>\\Pi_{dept_name}(course)  \\in \\Pi_{dept_name}(department)<br>$$</p>\n</li>\n<li><p>这里，$\\Pi$符号代表投影操作，用于提取指定的列。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"级联操作\"><a href=\"#级联操作\" class=\"headerlink\" title=\"级联操作\"></a>级联操作</h3><h4 id=\"ON-DELETE-CASCADE\"><a href=\"#ON-DELETE-CASCADE\" class=\"headerlink\" title=\"ON DELETE CASCADE\"></a>ON DELETE CASCADE</h4><ul>\n<li><strong>定义</strong>：如果主键表中的一行被删除，那么在外键表中依赖于该行的所有行也将被自动删除。</li>\n<li><strong>用途</strong>：这个选项用于维护数据库的参照完整性，确保不会有悬挂的引用存在于数据库中。</li>\n</ul>\n<h4 id=\"ON-UPDATE-CASCADE\"><a href=\"#ON-UPDATE-CASCADE\" class=\"headerlink\" title=\"ON UPDATE CASCADE\"></a>ON UPDATE CASCADE</h4><ul>\n<li><strong>定义</strong>：如果主键表中的一行被更新（尤其是关键字段），那么在外键表中依赖于该行的所有行的相关字段也将被自动更新。</li>\n<li><strong>用途</strong>：这个选项同样用于维护数据库的参照完整性，确保外键表中的数据随主键表的更新而更新。</li>\n</ul>\n<h4 id=\"其他级联操作\"><a href=\"#其他级联操作\" class=\"headerlink\" title=\"其他级联操作\"></a>其他级联操作</h4><p>set null, set default</p>\n<h3 id=\"事务过程中的完整性约束\"><a href=\"#事务过程中的完整性约束\" class=\"headerlink\" title=\"事务过程中的完整性约束\"></a>事务过程中的完整性约束</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> person (ID  <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">10</span>),<br>                    name <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">40</span>), <br>                    mother <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">10</span>),<br>                    father  <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">10</span>),<br>                    <span class=\"hljs-keyword\">primary</span> key ID,<br>                    <span class=\"hljs-keyword\">foreign</span> key father <span class=\"hljs-keyword\">references</span> person, <span class=\"hljs-keyword\">foreign</span> key mother <span class=\"hljs-keyword\">references</span> person);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"格式转换-Formatting-Functions\"><a href=\"#格式转换-Formatting-Functions\" class=\"headerlink\" title=\"格式转换(Formatting Functions)\"></a>格式转换(Formatting Functions)</h2><ul>\n<li>数据转换需求<ul>\n<li>特定数字位数：有时数值数据需要以特定的数字位数显示，这可能需要使用零填充数字或截断到特定的小数位。</li>\n<li>特定格式：数据可能需要以特定格式显示，例如日期格式化为“月-日-年”或“日-月-年”。这有助于在数据呈现时保持一致性，尤其是在用于报告、用户界面或进一步处理时。</li>\n</ul>\n</li>\n<li>数据库格式化函数：<ul>\n<li>MySQL：提供FORMAT函数，允许您将数字格式化为特定的小数位，有助于美化数据显示。</li>\n<li>Oracle 和 PostgreSQL：提供TO_CHAR、TO_NUMBER和TO_DATE等函数。这些函数对于数据类型转换非常灵活，可以在显示和处理数据时进行数据类型的转换和格式化。</li>\n<li>SQL Server：提供CONVERT函数，同样支持数据类型的转换和格式化，使数据更适合特定的显示或处理需求。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CAST-CONVERT-操作\"><a href=\"#CAST-CONVERT-操作\" class=\"headerlink\" title=\"CAST\\CONVERT 操作\"></a>CAST\\CONVERT 操作</h3><p><code>CAST</code>和<code>CONVERT</code>是<code>SQL</code>中用于数据类型转换的两个函数。</p>\n<h4 id=\"CAST-函数\"><a href=\"#CAST-函数\" class=\"headerlink\" title=\"CAST 函数\"></a>CAST 函数</h4><p><code>CAST</code>函数的语法比较直接，用于将一个表达式转换为指定的数据类型。其基本语法结构如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-built_in\">CAST</span>(expression <span class=\"hljs-keyword\">AS</span> data_type)<br></code></pre></td></tr></table></figure>\n\n<p><strong>参数说明：</strong></p>\n<ul>\n<li><p>expression：要转换的表达式。</p>\n</li>\n<li><p>data_type：目标数据类型，可以是整数、小数、日期等。</p>\n</li>\n<li><p>示例:<br>将字符串 ‘2021-12-31’ 转换为日期类型：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">CAST</span>(<span class=\"hljs-string\">&#x27;2021-12-31&#x27;</span> <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-type\">DATE</span>);<br></code></pre></td></tr></table></figure>\n\n<p>将数字类型的字符串 ‘123’ 转换为整型</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">CAST</span>(<span class=\"hljs-string\">&#x27;123&#x27;</span> <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-type\">INT</span>);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"CONVERT-函数\"><a href=\"#CONVERT-函数\" class=\"headerlink\" title=\"CONVERT 函数\"></a>CONVERT 函数</h4><p><code>CONVERT</code>函数功能类似于<code>CAST</code>，但语法更灵活，允许在进行类型转换的同时指定一些格式设置。其基本语法结构如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CONVERT</span>(data_type, expression [, style])<br></code></pre></td></tr></table></figure>\n\n<p><strong>参数说明：</strong></p>\n<ul>\n<li><p>data_type: 目标数据类型。</p>\n</li>\n<li><p>expression: 要转换的表达式。</p>\n</li>\n<li><p>style(可选): 用于日期和时间类型转换的格式代码，这个参数在<code>SQL Server</code>中特别有用，可以控制日期和时间数据的显示格式。</p>\n</li>\n<li><p>示例:<br>将日期时间转换为格式化的字符串（SQL Server）：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">CONVERT</span>(<span class=\"hljs-type\">VARCHAR</span>, GETDATE(), <span class=\"hljs-number\">101</span>); <span class=\"hljs-comment\">-- 输出 mm/dd/yyyy 格式的日期</span><br></code></pre></td></tr></table></figure>\n\n<p>将字符串 ‘2021-12-31’ 转换为日期类型：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">CONVERT</span>(<span class=\"hljs-type\">DATE</span>, <span class=\"hljs-string\">&#x27;2021-12-31&#x27;</span>);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>下面直接给出一些相关解释</strong><br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2_1.png\" alt=\"格式转换_1\"><br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2_2.png\" alt=\"格式转换_2\"><br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2_3.png\" alt=\"格式转换_3\"><br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2_4.png\" alt=\"格式转换_4\"></p>\n<h2 id=\"存储约束\"><a href=\"#存储约束\" class=\"headerlink\" title=\"存储约束\"></a>存储约束</h2><h3 id=\"大型对象存储\"><a href=\"#大型对象存储\" class=\"headerlink\" title=\"大型对象存储\"></a>大型对象存储</h3><p>在数据库中，针对需要存储大量数据的场景（如照片、视频等），常使用以下两种数据类型：</p>\n<ul>\n<li><p><strong>BLOB (Binary Large Object)</strong>:</p>\n<ul>\n<li><p>用于存储大量的未解释二进制数据。</p>\n</li>\n<li><p>例如，定义一个可以存储10MB大小的图像：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">image <span class=\"hljs-type\">BLOB</span>(<span class=\"hljs-number\">10</span>MB)<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>CLOB (Character Large Object)</strong>:</p>\n<ul>\n<li><p>用于存储大量的文本数据。</p>\n</li>\n<li><p>例如，定义一个可以存储10KB文本数据的 CLOB：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">book_view <span class=\"hljs-type\">CLOB</span>(<span class=\"hljs-number\">10</span>KB)<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"XML-数据类型\"><a href=\"#XML-数据类型\" class=\"headerlink\" title=\"XML 数据类型\"></a>XML 数据类型</h3><ul>\n<li><p>XML 数据类型用于在关系数据库中存储和查询结构化的 XML 数据。</p>\n</li>\n<li><p>示例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> book (<br>    book_id <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY,<br>    book_view <span class=\"hljs-type\">CLOB</span>(<span class=\"hljs-number\">10</span>KB),<br>    image <span class=\"hljs-type\">BLOB</span>(<span class=\"hljs-number\">10</span>MB),<br>    movie <span class=\"hljs-type\">BLOB</span>(<span class=\"hljs-number\">2</span>GB),<br>    catalog XML<br>);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"用户定义类型-UDT\"><a href=\"#用户定义类型-UDT\" class=\"headerlink\" title=\"用户定义类型 (UDT)\"></a>用户定义类型 (UDT)</h3><ul>\n<li><p>使用<code>CREATE TYPE</code>语句可以定义新的数据类型，用于表定义中。</p>\n</li>\n<li><p>示例：定义一个代表货币的类型：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> TYPE Dollars <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-type\">NUMERIC</span>(<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">FINAL</span>;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"用户定义域\"><a href=\"#用户定义域\" class=\"headerlink\" title=\"用户定义域\"></a>用户定义域</h3><ul>\n<li><p><code>CREATE DOMAIN</code>语句创建带有特定约束的自定义域，用于更细致的数据控制。</p>\n</li>\n<li><p>示例：定义一个代表货币的类型：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> DOMAIN person_name <span class=\"hljs-type\">CHAR</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>;<br><span class=\"hljs-keyword\">CREATE</span> DOMAIN degree_level <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">10</span>)<br><span class=\"hljs-keyword\">CONSTRAINT</span> degree_level_test<br><span class=\"hljs-keyword\">CHECK</span> (<span class=\"hljs-keyword\">value</span> <span class=\"hljs-keyword\">IN</span> (<span class=\"hljs-string\">&#x27;Bachelors&#x27;</span>, <span class=\"hljs-string\">&#x27;Masters&#x27;</span>, <span class=\"hljs-string\">&#x27;Doctorate&#x27;</span>));<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"数据库的三级层次结构\"><a href=\"#数据库的三级层次结构\" class=\"headerlink\" title=\"数据库的三级层次结构\"></a>数据库的三级层次结构</h2><p>在现代数据库系统中，存在一个三级层次结构，用以组织和管理数据对象，如关系和视图。这一结构提供了对数据库对象的逻辑分类和隔离，便于管理和访问。</p>\n<h3 id=\"目录（Catalogs）\"><a href=\"#目录（Catalogs）\" class=\"headerlink\" title=\"目录（Catalogs）\"></a>目录（Catalogs）</h3><ul>\n<li>目录也常被称为数据库（Database）。</li>\n<li>一个数据库系统可以包含多个目录，每个目录可包含多个模式（Schemas）。</li>\n<li>示例：<code>catalog5</code> 可以看作是一个目录。</li>\n</ul>\n<h3 id=\"模式（Schemas）\"><a href=\"#模式（Schemas）\" class=\"headerlink\" title=\"模式（Schemas）\"></a>模式（Schemas）</h3><ul>\n<li>模式是存储关系（Relations）和视图（Views）的容器。</li>\n<li>模式对象代表了数据库对象的所有权上下文。</li>\n<li>示例：<code>univ_schema</code> 是 <code>catalog5</code> 目录中的一个模式。</li>\n</ul>\n<h3 id=\"关系与视图（SQL-Objects）\"><a href=\"#关系与视图（SQL-Objects）\" class=\"headerlink\" title=\"关系与视图（SQL Objects）\"></a>关系与视图（SQL Objects）</h3><ul>\n<li>关系和视图是存储在模式中的SQL对象。</li>\n<li>这些对象可以通过三部分名称来访问，例如：<code>catalog5.univ_schema.course</code>。</li>\n</ul>\n<h3 id=\"数据库连接与用户环境\"><a href=\"#数据库连接与用户环境\" class=\"headerlink\" title=\"数据库连接与用户环境\"></a>数据库连接与用户环境</h3><ul>\n<li>要对数据库执行任何操作，用户必须首先连接到数据库。</li>\n<li>用户需要提供用户名和通常的密码来验证用户身份。</li>\n<li>每个用户都有一个默认的目录和模式，且此组合对于用户是唯一的。</li>\n<li>SQL环境包括用户标识符、连接、目录和模式等。</li>\n</ul>\n<p>通过这种结构化的管理方式，数据库不仅能够提高数据访问的效率，还能加强数据安全性和隔离性。这对于处理大量复杂数据的企业级应用尤为重要。</p>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png\" alt=\"数据库三层次结构\"></p>\n<h2 id=\"断言-Assertions\"><a href=\"#断言-Assertions\" class=\"headerlink\" title=\"断言(Assertions)\"></a>断言(Assertions)</h2><p>断言是一个谓词表达式，用于表示数据库应始终满足的条件。例如，域约束和引用完整性约束。</p>\n<ul>\n<li><p>断言形式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> ASSERTION <span class=\"hljs-operator\">&lt;</span>assertion<span class=\"hljs-operator\">-</span>name<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">CHECK</span> <span class=\"hljs-operator\">&lt;</span>predicate<span class=\"hljs-operator\">&gt;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>断言的实施可能会导致显著的性能开销，因为数据库管理系统（DBMS）需要在每次数据库修改时验证断言的有效性。因此，应谨慎使用断言。</p>\n</li>\n</ul>\n<p><strong>示例</strong>:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> ASSERTION credits_earned_constraints <span class=\"hljs-keyword\">CHECK</span> (<br>    <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">EXISTS</span> (<br>        <span class=\"hljs-keyword\">SELECT</span> ID <span class=\"hljs-keyword\">FROM</span> student<br>        <span class=\"hljs-keyword\">WHERE</span> tot_cred <span class=\"hljs-operator\">&lt;&gt;</span> (<br>            <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">SUM</span>(credits) <span class=\"hljs-keyword\">FROM</span> takes <span class=\"hljs-keyword\">NATURAL</span> <span class=\"hljs-keyword\">JOIN</span> course<br>            <span class=\"hljs-keyword\">WHERE</span> student.ID <span class=\"hljs-operator\">=</span> takes.ID <span class=\"hljs-keyword\">AND</span> grade <span class=\"hljs-keyword\">IS</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">AND</span> grade <span class=\"hljs-operator\">&lt;&gt;</span> <span class=\"hljs-string\">&#x27;F&#x27;</span><br>        )<br>    )<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"索引-Indexes\"><a href=\"#索引-Indexes\" class=\"headerlink\" title=\"索引(Indexes)\"></a>索引(Indexes)</h2><p>索引是一个使数据库系统能够有效找到具有特定属性值的元组的数据结构，而无需扫描整个关系的所有元组。</p>\n<ul>\n<li><p>创建索引的命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> INDEX <span class=\"hljs-operator\">&lt;</span>name<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-operator\">&lt;</span>relation<span class=\"hljs-operator\">-</span>name<span class=\"hljs-operator\">&gt;</span> (attribute);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>创建索引能够有效提高根据索引查找的速度，因为索引的本质是另外维护了一张图，在这个过程中并不用遍历整张表。但是这同时增加了数据库在存储上的开销</p>\n</li>\n<li><p>一旦索引创建完成，当我们执行涉及到索引列的查询时，数据库管理系统会自动使用这个索引来加速查找过程。</p>\n</li>\n</ul>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> INDEX idx_registration_date <span class=\"hljs-keyword\">ON</span> students(registration_date);<br><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> students <span class=\"hljs-keyword\">WHERE</span> registration_date <span class=\"hljs-operator\">&gt;=</span> <span class=\"hljs-string\">&#x27;2021-01-01&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"访问授权（Authorization）\"><a href=\"#访问授权（Authorization）\" class=\"headerlink\" title=\"访问授权（Authorization）\"></a>访问授权（Authorization）</h2><p>数据库系统中的访问授权可以控制不同用户对数据库的不同部分的访问权限。授权类型包括读取、插入、更新和删除。</p>\n<ul>\n<li><p>授权命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-operator\">&lt;</span>privilege list<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-operator\">&lt;</span>relation<span class=\"hljs-operator\">-</span>name <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">view</span><span class=\"hljs-operator\">-</span>name<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-operator\">&lt;</span><span class=\"hljs-keyword\">user</span><span class=\"hljs-operator\">-</span>list<span class=\"hljs-operator\">&gt;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>数据库部分的授权形式</p>\n<ul>\n<li>**读取(Read)**：允许读取数据，但不能修改数据。</li>\n<li>**插入(Insert)**：允许插入新数据，但不能修改现有数据。</li>\n<li>**更新(Update)**：允许修改数据，但不能删除数据。</li>\n<li>**删除(Delete)**：允许删除数据。</li>\n</ul>\n</li>\n<li><p>修改数据库架构的授权形式</p>\n<ul>\n<li>**资源(Resources)**：允许创建新的关系。</li>\n<li>**变更(Alteration)**：允许在关系中添加或删除属性。</li>\n<li>**删除(Drop)**：允许删除关系。</li>\n<li>**索引(Index)**：与索引相关的权限。</li>\n</ul>\n</li>\n<li><p><strong>all privileges</strong>：所有权限</p>\n</li>\n<li><p>用户列表内容</p>\n<ul>\n<li>user_id</li>\n<li>public, which allows all valid users the privilege granted</li>\n<li>角色(role)</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">on</span> instructor <span class=\"hljs-keyword\">to</span> U1, U2, U3;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"创建和管理角色\"><a href=\"#创建和管理角色\" class=\"headerlink\" title=\"创建和管理角色\"></a>创建和管理角色</h2><p>角色是一种用于管理权限的机制，可以简化权限的分配和管理过程。角色可以包含一组权限，并且可以被授予给用户或其他角色。</p>\n<h3 id=\"创建角色\"><a href=\"#创建角色\" class=\"headerlink\" title=\"创建角色\"></a>创建角色</h3><p>使用<code>create role</code>语句来创建一个新的角色。例如，创建一个名为<code>instructor</code>的角色：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">create</span> role instructor;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"授权角色\"><a href=\"#授权角色\" class=\"headerlink\" title=\"授权角色\"></a>授权角色</h3><p>将角色授予用户，使用户可以获得该角色所拥有的权限。例如，将<code>instructor</code>角色授予用户<code>Amit</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">grant</span> instructor <span class=\"hljs-keyword\">to</span> Amit;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"角色的权限管理\"><a href=\"#角色的权限管理\" class=\"headerlink\" title=\"角色的权限管理\"></a>角色的权限管理</h3><p>可以直接向角色授权特定的数据库操作权限。例如，授予<code>instructor</code>角色在<code>takes</code>表上的选择权限：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">on</span> takes <span class=\"hljs-keyword\">to</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"角色的继承\"><a href=\"#角色的继承\" class=\"headerlink\" title=\"角色的继承\"></a>角色的继承</h3><p>角色可以被授予给其他角色，从而实现权限的继承。例如，创建一个名为<code>teaching_assistant</code>的角色，并将其授予<code>instructor</code>角色。这样，<code>instructor</code>角色会继承<code>teaching_assistant</code>角色的所有权限：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">create</span> role teaching_assistant;<br><span class=\"hljs-keyword\">grant</span> teaching_assistant <span class=\"hljs-keyword\">to</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"角色链\"><a href=\"#角色链\" class=\"headerlink\" title=\"角色链\"></a>角色链</h3><p>角色可以形成一个授权链，其中每个角色可以被授予给其他角色。例如，创建一个<code>dean</code>角色，并将<code>instructor</code>角色授予<code>dean</code>，然后将<code>dean</code>角色授予用户<code>Satoshi</code>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">create</span> role dean;<br><span class=\"hljs-keyword\">grant</span> instructor <span class=\"hljs-keyword\">to</span> dean;<br><span class=\"hljs-keyword\">grant</span> dean <span class=\"hljs-keyword\">to</span> Satoshi;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"视图权限\"><a href=\"#视图权限\" class=\"headerlink\" title=\"视图权限\"></a>视图权限</h2><p>视图权限和语法的使用和上述同理</p>\n","excerpt":"","more":"<h2 id=\"视图-View\"><a href=\"#视图-View\" class=\"headerlink\" title=\"视图(View)\"></a>视图(View)</h2><p>视图本身常在数据库中进行使用，用于限制对敏感或不相关数据的访问。对于一个多用户使用的<code>SQL</code>设计中，这个操作是必要且相关的。<br>从理解上来看，<code>View</code>本身是对基础的<code>SQL</code>数据进行了一层封装，本质是用于方便访问查询<code>SQL</code>中的数据，但是其本身对于<code>SQL</code>的数据不进行增删改的操作。</p>\n<p><strong>视图的本质是对于一个或多个的投影关系。</strong><br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E8%A7%86%E5%9B%BE%E6%98%A0%E5%B0%84.png\" alt=\"视图\"></p>\n<h3 id=\"视图的存储与计算\"><a href=\"#视图的存储与计算\" class=\"headerlink\" title=\"视图的存储与计算\"></a>视图的存储与计算</h3><p>视图被定义为虚拟关系或虚拟表，它们在数据库系统中只存储定义，而不存储实际的数据。视图的数据是在查询执行时动态生成的，基于它的定义来实时计算得到的。</p>\n<ul>\n<li><strong>存储方式</strong>：数据库中只存储视图的定义，而不是视图的数据。这意味着视图所展示的数据实际上是通过执行视图定义中的 SQL 表达式动态生成的。</li>\n<li><strong>计算方式</strong>：视图的计算可以归约为对其定义中包含的关系代数表达式的求值。当查询涉及到视图时，数据库系统会根据视图的定义来实时地计算数据，而不是从物理存储中检索。</li>\n</ul>\n<h3 id=\"视图与物化视图的区别\"><a href=\"#视图与物化视图的区别\" class=\"headerlink\" title=\"视图与物化视图的区别\"></a>视图与物化视图的区别</h3><p>除了普通的视图（动态视图），数据库中还存在一种称为“物化视图”的结构，这种视图不仅存储定义，同时也存储对应的数据。</p>\n<ul>\n<li>物化视图（Materialized Views）：<ul>\n<li>定义与数据存储：物化视图的定义和数据都被存储在数据库系统(<code>DBS</code>)中。这使得物化视图在查询时可以直接从物理存储中检索数据，而不需要进行复杂的计算。</li>\n<li>性能优势：对于数据访问频繁且查询代价高的情况，物化视图可以显著提高查询性能，因为避免了每次查询时的重复计算。</li>\n<li>维护代价：物化视图需要在基础数据更新时同步更新，这可能会增加维护成本和复杂性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"与-WITH-子句的比较\"><a href=\"#与-WITH-子句的比较\" class=\"headerlink\" title=\"与 WITH 子句的比较\"></a>与 WITH 子句的比较</h3><p>在 SQL 中，WITH 子句通常用于定义临时的结果集，这些结果集在 SQL 执行结束后不会被保留。</p>\n<ul>\n<li>WITH 子句（临时表）：<ul>\n<li>临时性质：通过 WITH 子句创建的是临时表，这些表仅在 SQL 执行的上下文中存在，执行结束后将被自动销毁。</li>\n<li>使用场景：适用于需要临时组织或转换数据以供后续查询使用的情况，特别是在复杂的查询中。</li>\n</ul>\n</li>\n</ul>\n<p>通过对比视图、物化视图和 WITH 子句创建的临时表，我们可以更深入地理解这些数据库对象的用途和适用场景，以及它们在数据管理和性能优化中的作用。</p>\n<h3 id=\"创建和使用视图\"><a href=\"#创建和使用视图\" class=\"headerlink\" title=\"创建和使用视图\"></a>创建和使用视图</h3><p>视图是通过<code>CREATE VIEW</code>语句定义的，它允许用户保存<code>SQL</code>表达式，以便重复使用。视图本质上是一个虚拟的表，其内容由<code>SQL</code>查询表达式定义，但它并不在数据库中以物理形式存储数据。</p>\n<h4 id=\"视图的定义\"><a href=\"#视图的定义\" class=\"headerlink\" title=\"视图的定义\"></a>视图的定义</h4><p>视图的创建语法如下</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> view_name <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-operator\">&lt;</span>query_expression<span class=\"hljs-operator\">&gt;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>其中<code>view_name</code>是视图的名称，<query_expression> 是定义视图内容的 SQL 表达式。</p>\n<p><strong>示例1: 创建视图隐藏敏感信息</strong><br>例如，如果我们想创建一个视图来展示教师信息，但不包括薪资信息，可以使用以下<code>SQL</code>命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> faculty <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-keyword\">SELECT</span> ID, name, dept_name<br><span class=\"hljs-keyword\">FROM</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<p>这个视图<code>faculty</code>包括了教师的 ID、姓名和所在部门，但故意省略了薪资信息以保护敏感数据。</p>\n<p><strong>示例2：查询特定部门的教师</strong><br>基于上述视图，如果需要找出生物学部门的所有教师，可以简单地执行以下查询：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> name<br><span class=\"hljs-keyword\">FROM</span> faculty<br><span class=\"hljs-keyword\">WHERE</span> dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Biology&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<p>这个查询利用了<code>faculty</code>视图，它从视图中检索生物学部门的所有教师，而不直接从原始的<code>instructor</code> 表中查询。</p>\n<p><strong>示例3: 创建视图统计部门薪资总和</strong><br>还可以创建一个视图来计算每个部门的薪资总和，这对于管理和财务分析特别有用：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> departments_total_salary (dept_name, total_salary) <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-keyword\">SELECT</span> dept_name, <span class=\"hljs-built_in\">SUM</span>(salary)<br><span class=\"hljs-keyword\">FROM</span> instructor<br><span class=\"hljs-keyword\">GROUP</span> <span class=\"hljs-keyword\">BY</span> dept_name;<br></code></pre></td></tr></table></figure>\n\n<p>这个视图 departments_total_salary 提供了每个部门的总薪资，通过从 instructor 表中汇总薪资数据得到。</p>\n<h4 id=\"视图依赖与视图嵌套\"><a href=\"#视图依赖与视图嵌套\" class=\"headerlink\" title=\"视图依赖与视图嵌套\"></a>视图依赖与视图嵌套</h4><p>在数据库设计中，视图可以基于其他视图来创建，形成依赖关系。这种特性使得视图不仅能够隐藏复杂的 SQL 逻辑，还能构建基于已有数据抽象的新抽象。</p>\n<p><strong>示例1：创建基础视图</strong><br>考虑以下 SQL 语句，它创建了一个名为 physics_fall_2019 的视图，包含 2019 年秋季学期物理系的所有课程和相应教室信息：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> physics_fall_2019 <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-keyword\">SELECT</span> course.course_id, sec_id, building, room_number<br><span class=\"hljs-keyword\">FROM</span> course, section<br><span class=\"hljs-keyword\">WHERE</span> course.course_id <span class=\"hljs-operator\">=</span> section.course_id<br>    <span class=\"hljs-keyword\">AND</span> course.dept_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Physics&#x27;</span><br>    <span class=\"hljs-keyword\">AND</span> section.semester <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Fall&#x27;</span><br>    <span class=\"hljs-keyword\">AND</span> section.year <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2019</span>;<br></code></pre></td></tr></table></figure>\n\n<p><strong>示例2: 基于已有视图创建新视图</strong><br>接下来，基于<code>physics_fall_2019</code>视图，创建另一个视图<code>physics_fall_2019_watson</code>，只包括在 Watson 建筑中的课程：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">VIEW</span> physics_fall_2019_watson <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-keyword\">SELECT</span> course_id, room_number<br><span class=\"hljs-keyword\">FROM</span> physics_fall_2019<br><span class=\"hljs-keyword\">WHERE</span> building <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Watson&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"视图依赖的定义\"><a href=\"#视图依赖的定义\" class=\"headerlink\" title=\"视图依赖的定义\"></a>视图依赖的定义</h5><ul>\n<li>直接依赖：如果一个视图 v1 在其定义中使用了另一个视图 v2，则称 v1 直接依赖于 v2。</li>\n<li>间接依赖：如果视图 v1 依赖于视图 v2，这种依赖可以是直接的，或者通过一系列其他视图的依赖链实现的。</li>\n<li>递归依赖：如果视图在定义中直接或间接依赖于它自身，则称该视图具有递归依赖。</li>\n</ul>\n<h3 id=\"更新视图\"><a href=\"#更新视图\" class=\"headerlink\" title=\"更新视图\"></a>更新视图</h3><h4 id=\"向视图中添加数据\"><a href=\"#向视图中添加数据\" class=\"headerlink\" title=\"向视图中添加数据\"></a>向视图中添加数据</h4><p>在数据库中，视图通常是只读的，特别是当视图由复杂的查询或多个表连接生成时。然而，如果视图定义简单且直接反映了单一表的内容，向视图添加数据可能会隐式地向基础表添加数据。</p>\n<p><strong>示例：向视图添加元组</strong><br>假设有一个名为 faculty 的视图，它是从 instructor 表派生而来的，仅包含教师的 ID、姓名和部门信息。如果尝试向 faculty 视图插入新数据：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> faculty <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;30765&#x27;</span>, <span class=\"hljs-string\">&#x27;Green&#x27;</span>, <span class=\"hljs-string\">&#x27;Music&#x27;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>这种插入操作需要在基础的<code>instructor</code>表中反映，因为<code>faculty</code>视图直接依赖于这个表。实际插入的元组将是：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> instructor <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;30765&#x27;</span>, <span class=\"hljs-string\">&#x27;Green&#x27;</span>, <span class=\"hljs-string\">&#x27;Music&#x27;</span>, <span class=\"hljs-keyword\">NULL</span>);<br></code></pre></td></tr></table></figure>\n\n<p>这里的<code>NULL</code>可能代表了在<code>instructor</code>表中存在但在<code>faculty</code>视图中未显示的列（如<code>salary</code>）。此操作展示了视图可以在特定条件下用于数据插入，但必须确保所有必需字段都得到适当处理，包括那些在视图中未直接显示的字段。</p>\n<h3 id=\"物化图-Materialized-Views\"><a href=\"#物化图-Materialized-Views\" class=\"headerlink\" title=\"物化图(Materialized Views)\"></a>物化图(Materialized Views)</h3><h4 id=\"物化视图的创建和维护\"><a href=\"#物化视图的创建和维护\" class=\"headerlink\" title=\"物化视图的创建和维护\"></a>物化视图的创建和维护</h4><p>物化视图不同于普通视图，它实际存储了查询结果的数据，从而提高了查询性能，尤其是在处理复杂计算和大数据集时。</p>\n<p><strong>创建物化视图</strong><br>物化视图通过在数据库中存储其查询结果，创建语法如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> MATERIALIZED <span class=\"hljs-keyword\">VIEW</span> view_name <span class=\"hljs-keyword\">AS</span><br><span class=\"hljs-keyword\">SELECT</span> columns<br><span class=\"hljs-keyword\">FROM</span> tables<br><span class=\"hljs-keyword\">WHERE</span> conditions;<br></code></pre></td></tr></table></figure>\n\n<p>这个操作创建一个物理表，其中包含由定义的查询生成的所有元组。</p>\n<p><strong>维护物化视图</strong><br>由于物化视图包含实际的数据，当基于该视图的表更新时，物化视图可能会过时：</p>\n<ul>\n<li><strong>自动更新</strong>：某些数据库系统支持物化视图的自动更新，即当底层数据变化时，物化视图会自动重新计算和更新。</li>\n<li><strong>手动维护</strong>：在不支持自动更新的系统中，需要手动重新生成物化视图以保持数据的最新状态。</li>\n</ul>\n<p>物化视图的维护是确保数据一致性的关键，尤其是在数据频繁变更的环境中。</p>\n<h2 id=\"事务-Transactions\"><a href=\"#事务-Transactions\" class=\"headerlink\" title=\"事务(Transactions)\"></a>事务(Transactions)</h2><p>在数据库系统中，事务是由一系列查询和&#x2F;或更新语句组成的一个执行单元，通常用于执行需要保持数据完整性的复杂操作。</p>\n<h3 id=\"事务的定义\"><a href=\"#事务的定义\" class=\"headerlink\" title=\"事务的定义\"></a>事务的定义</h3><p>事务是一连串的数据库操作，它们被视为一个单一的工作单元。这些操作要么全部完成，要么全部不发生，保证了数据库的完整性。</p>\n<h3 id=\"ACID-属性\"><a href=\"#ACID-属性\" class=\"headerlink\" title=\"ACID 属性\"></a>ACID 属性</h3><p>事务的关键特性可以总结为ACID属性：</p>\n<ul>\n<li><strong>原子性</strong>（Atomicity）：事务是一个不可分割的工作单元，操作要么完全完成，要么完全不发生。</li>\n<li><strong>一致性</strong>（Consistency）：事务确保数据库从一个一致的状态转变到另一个一致的状态。</li>\n<li><strong>隔离性</strong>（Isolation）：事务的执行不会被其他事务干扰。</li>\n<li><strong>持久性</strong>（Durability）：一旦事务提交，其结果就永久保存在数据库中。</li>\n</ul>\n<p><strong>事务的操作示例</strong><br>以下是一个事务处理的示例，该事务涉及在两个账户间转账：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">DECLARE</span> <span class=\"hljs-variable\">@transfer_name</span> <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\">/* 定义事务变量 */</span><br><span class=\"hljs-keyword\">SET</span> <span class=\"hljs-variable\">@transfer_name</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;I-transfer-from-A-to-B&#x27;</span> <span class=\"hljs-comment\">/* 命名事务 */</span><br><span class=\"hljs-keyword\">BEGIN</span> TRANSACTION <span class=\"hljs-variable\">@transfer_name</span> <span class=\"hljs-comment\">/* 开始事务 */</span><br>USE ACCOUNT <span class=\"hljs-comment\">/* 打开数据库 ACCOUNT */</span><br>GO <span class=\"hljs-comment\">/* 将上述批SQL语句提交给 SQL Server */</span><br><span class=\"hljs-keyword\">UPDATE</span> A <span class=\"hljs-comment\">/* 修改A账户 */</span><br>    <span class=\"hljs-keyword\">SET</span> balance <span class=\"hljs-operator\">=</span> balance <span class=\"hljs-operator\">-</span> <span class=\"hljs-number\">50</span><br>    <span class=\"hljs-keyword\">WHERE</span> branch_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Brooklyn&#x27;</span><br><span class=\"hljs-keyword\">UPDATE</span> B <span class=\"hljs-comment\">/* 修改B账户 */</span><br>    <span class=\"hljs-keyword\">SET</span> balance <span class=\"hljs-operator\">=</span> balance <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">50</span><br>    <span class=\"hljs-keyword\">WHERE</span> branch_name <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&#x27;Brooklyn&#x27;</span><br>GO<br><span class=\"hljs-keyword\">COMMIT</span> TRANSACTION <span class=\"hljs-variable\">@transfer_name</span> <span class=\"hljs-comment\">/* 提交事务 */</span><br>GO<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"事务的开始和结束\"><a href=\"#事务的开始和结束\" class=\"headerlink\" title=\"事务的开始和结束\"></a>事务的开始和结束</h3><ul>\n<li><strong>开始</strong>：事务隐式地开始于执行的第一个语句。</li>\n<li><strong>结束</strong>：通过 COMMIT 或 ROLLBACK 语句来结束事务。<ul>\n<li><strong>提交（Commit）</strong>：确认所有数据修改，并将修改永久保存。</li>\n<li><strong>回滚（Rollback）</strong>：撤销事务中的所有修改，恢复到事务开始前的状态。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"完整性约束-Integrity-Constraints\"><a href=\"#完整性约束-Integrity-Constraints\" class=\"headerlink\" title=\"完整性约束(Integrity Constraints)\"></a>完整性约束(Integrity Constraints)</h2><p>完整性约束是数据库管理系统中用于维护数据准确性和一致性的规则和限制。它们防止无效数据的输入，并确保数据库中的数据始终保持逻辑上的正确和完整。</p>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>完整性约束是自动应用的规则，用于防止数据库中的非法或不一致的信息存储。它们保护数据库免受意外损坏，确保即使在数据库修改过程中也不会丢失数据的一致性。</p>\n<h3 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h3><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>级别</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>静态</strong></td>\n<td>属性级别</td>\n<td>- 数据类型、数据格式、域约束、空值</td>\n</tr>\n<tr>\n<td></td>\n<td>元组级别</td>\n<td>- 属性值间的约束、映射基数约束</td>\n</tr>\n<tr>\n<td></td>\n<td>关系级别</td>\n<td>- 实体完整性、引用完整性、函数依赖</td>\n</tr>\n<tr>\n<td><strong>动态</strong></td>\n<td>属性级别</td>\n<td>- 更新属性值或属性定义的约束</td>\n</tr>\n<tr>\n<td></td>\n<td>元组级别</td>\n<td>- 属性值间的动态约束</td>\n</tr>\n<tr>\n<td></td>\n<td>关系级别</td>\n<td>- 事务约束：原子性、一致性、隔离性、持久性</td>\n</tr>\n</tbody></table>\n<p>对于此处存在有一些例子</p>\n<blockquote>\n<p>E.g. 1   the salary of manager should not be lower than $1000 in Employee<br>E.g. 2   table T (x, y, z ), z &#x3D;x+y, z is a derived attributes from x and y.<br>E.g. 3   the student# for table student should not be null<br>E.g. 4   the age  of students should only be added<br>E.g. 5   when  employee tuples is modified,  new.sal &gt; old.sal + 0.5*age<br>E.g. 6   statistical  constraints</p>\n</blockquote>\n<h3 id=\"常见的完整性约束\"><a href=\"#常见的完整性约束\" class=\"headerlink\" title=\"常见的完整性约束\"></a>常见的完整性约束</h3><p>常见的完整性约束包括</p>\n<ul>\n<li>primary key                           (主键)</li>\n<li>not null                              (非空)</li>\n<li>unique                                (不同)</li>\n<li>check (P ), where P is a predicate    (限制取值)</li>\n</ul>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> section (<br>    course_id       <span class=\"hljs-type\">varchar</span> (<span class=\"hljs-number\">8</span>),<br>    sec_id          <span class=\"hljs-type\">varchar</span> (<span class=\"hljs-number\">8</span>),<br>    semester        <span class=\"hljs-type\">varchar</span> (<span class=\"hljs-number\">6</span>),<br>    <span class=\"hljs-keyword\">year</span>            <span class=\"hljs-type\">numeric</span> (<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">0</span>),<br>    room_number     <span class=\"hljs-type\">varchar</span> (<span class=\"hljs-number\">7</span>),<br>    <span class=\"hljs-keyword\">primary</span> key     (course_id, sec_id, semester, <span class=\"hljs-keyword\">year</span>),<br>    <span class=\"hljs-keyword\">check</span>           (semester <span class=\"hljs-keyword\">in</span> (’Fall’, ’Winter’, ’Spring’, ’Summer’)));<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"参考完整性-Referential-Integrity\"><a href=\"#参考完整性-Referential-Integrity\" class=\"headerlink\" title=\"参考完整性(Referential Integrity)\"></a>参考完整性(Referential Integrity)</h3><p>参照完整性是数据库设计中用于维持表之间数据一致性的一种约束，它确保一个关系中的属性值（通常是外键）在另一个关系中也存在对应的属性值（通常是主键）。</p>\n<h4 id=\"定义和重要性\"><a href=\"#定义和重要性\" class=\"headerlink\" title=\"定义和重要性\"></a>定义和重要性</h4><p>参照完整性保证在一个表中引用另一个表的数据时，引用的数据必须有效存在。这是通过在外键属性上设置约束来实现的，以确保外键值在被引用的表的主键中存在。</p>\n<p><strong>示例</strong><br>假设有两个表：<code>instructor</code>和<code>department</code>。<code>instructor</code>表中的<code>dept_name</code>字段是一个外键，它引用了<code>department</code>表中的<code>dept_name</code>字段（作为主键）。参照完整性约束确保每个在<code>instructor</code>表中列出的部门名称在<code>department</code>表中都有对应的记录。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-comment\">-- 示例：确保 instructor 表中的 dept_name 在 department 表中存在</span><br><span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">TABLE</span> instructor<br><span class=\"hljs-keyword\">ADD</span> <span class=\"hljs-keyword\">CONSTRAINT</span> fk_department_name<br><span class=\"hljs-keyword\">FOREIGN</span> KEY (dept_name) <span class=\"hljs-keyword\">REFERENCES</span> department(dept_name);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"功能和操作\"><a href=\"#功能和操作\" class=\"headerlink\" title=\"功能和操作\"></a>功能和操作</h4><ul>\n<li><strong>删除和更新的约束</strong>：当启用参照完整性时，不能删除或修改<code>department</code>表中的一个部门名称，如果它在<code>instructor</code>表中作为外键被引用，除非同时更新或删除引用该值的所有行。</li>\n<li><strong>数据一致性</strong>：通过参照完整性约束，可以避免数据孤岛的产生，即避免在引用表中存在无法对应到主表的外键值。</li>\n</ul>\n<h4 id=\"数学表述\"><a href=\"#数学表述\" class=\"headerlink\" title=\"数学表述\"></a>数学表述</h4><p>在关系代数中，参照完整性可以表示为子集关系，其中一个表的特定列是另一个表特定列的子集。</p>\n<ul>\n<li><strong>表达式</strong><ul>\n<li><p>例如，如果<code>course</code>表中的<code>dept_name</code>是外键，那么所有在<code>course</code>表中的<code>dept_name</code>值必须是<code>department</code>表中<code>dept_name</code>值的子集：<br>$$<br>\\Pi_{dept_name}(course)  \\in \\Pi_{dept_name}(department)<br>$$</p>\n</li>\n<li><p>这里，$\\Pi$符号代表投影操作，用于提取指定的列。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"级联操作\"><a href=\"#级联操作\" class=\"headerlink\" title=\"级联操作\"></a>级联操作</h3><h4 id=\"ON-DELETE-CASCADE\"><a href=\"#ON-DELETE-CASCADE\" class=\"headerlink\" title=\"ON DELETE CASCADE\"></a>ON DELETE CASCADE</h4><ul>\n<li><strong>定义</strong>：如果主键表中的一行被删除，那么在外键表中依赖于该行的所有行也将被自动删除。</li>\n<li><strong>用途</strong>：这个选项用于维护数据库的参照完整性，确保不会有悬挂的引用存在于数据库中。</li>\n</ul>\n<h4 id=\"ON-UPDATE-CASCADE\"><a href=\"#ON-UPDATE-CASCADE\" class=\"headerlink\" title=\"ON UPDATE CASCADE\"></a>ON UPDATE CASCADE</h4><ul>\n<li><strong>定义</strong>：如果主键表中的一行被更新（尤其是关键字段），那么在外键表中依赖于该行的所有行的相关字段也将被自动更新。</li>\n<li><strong>用途</strong>：这个选项同样用于维护数据库的参照完整性，确保外键表中的数据随主键表的更新而更新。</li>\n</ul>\n<h4 id=\"其他级联操作\"><a href=\"#其他级联操作\" class=\"headerlink\" title=\"其他级联操作\"></a>其他级联操作</h4><p>set null, set default</p>\n<h3 id=\"事务过程中的完整性约束\"><a href=\"#事务过程中的完整性约束\" class=\"headerlink\" title=\"事务过程中的完整性约束\"></a>事务过程中的完整性约束</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">table</span> person (ID  <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">10</span>),<br>                    name <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">40</span>), <br>                    mother <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">10</span>),<br>                    father  <span class=\"hljs-type\">char</span>(<span class=\"hljs-number\">10</span>),<br>                    <span class=\"hljs-keyword\">primary</span> key ID,<br>                    <span class=\"hljs-keyword\">foreign</span> key father <span class=\"hljs-keyword\">references</span> person, <span class=\"hljs-keyword\">foreign</span> key mother <span class=\"hljs-keyword\">references</span> person);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"格式转换-Formatting-Functions\"><a href=\"#格式转换-Formatting-Functions\" class=\"headerlink\" title=\"格式转换(Formatting Functions)\"></a>格式转换(Formatting Functions)</h2><ul>\n<li>数据转换需求<ul>\n<li>特定数字位数：有时数值数据需要以特定的数字位数显示，这可能需要使用零填充数字或截断到特定的小数位。</li>\n<li>特定格式：数据可能需要以特定格式显示，例如日期格式化为“月-日-年”或“日-月-年”。这有助于在数据呈现时保持一致性，尤其是在用于报告、用户界面或进一步处理时。</li>\n</ul>\n</li>\n<li>数据库格式化函数：<ul>\n<li>MySQL：提供FORMAT函数，允许您将数字格式化为特定的小数位，有助于美化数据显示。</li>\n<li>Oracle 和 PostgreSQL：提供TO_CHAR、TO_NUMBER和TO_DATE等函数。这些函数对于数据类型转换非常灵活，可以在显示和处理数据时进行数据类型的转换和格式化。</li>\n<li>SQL Server：提供CONVERT函数，同样支持数据类型的转换和格式化，使数据更适合特定的显示或处理需求。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CAST-CONVERT-操作\"><a href=\"#CAST-CONVERT-操作\" class=\"headerlink\" title=\"CAST\\CONVERT 操作\"></a>CAST\\CONVERT 操作</h3><p><code>CAST</code>和<code>CONVERT</code>是<code>SQL</code>中用于数据类型转换的两个函数。</p>\n<h4 id=\"CAST-函数\"><a href=\"#CAST-函数\" class=\"headerlink\" title=\"CAST 函数\"></a>CAST 函数</h4><p><code>CAST</code>函数的语法比较直接，用于将一个表达式转换为指定的数据类型。其基本语法结构如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-built_in\">CAST</span>(expression <span class=\"hljs-keyword\">AS</span> data_type)<br></code></pre></td></tr></table></figure>\n\n<p><strong>参数说明：</strong></p>\n<ul>\n<li><p>expression：要转换的表达式。</p>\n</li>\n<li><p>data_type：目标数据类型，可以是整数、小数、日期等。</p>\n</li>\n<li><p>示例:<br>将字符串 ‘2021-12-31’ 转换为日期类型：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">CAST</span>(<span class=\"hljs-string\">&#x27;2021-12-31&#x27;</span> <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-type\">DATE</span>);<br></code></pre></td></tr></table></figure>\n\n<p>将数字类型的字符串 ‘123’ 转换为整型</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">CAST</span>(<span class=\"hljs-string\">&#x27;123&#x27;</span> <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-type\">INT</span>);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"CONVERT-函数\"><a href=\"#CONVERT-函数\" class=\"headerlink\" title=\"CONVERT 函数\"></a>CONVERT 函数</h4><p><code>CONVERT</code>函数功能类似于<code>CAST</code>，但语法更灵活，允许在进行类型转换的同时指定一些格式设置。其基本语法结构如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CONVERT</span>(data_type, expression [, style])<br></code></pre></td></tr></table></figure>\n\n<p><strong>参数说明：</strong></p>\n<ul>\n<li><p>data_type: 目标数据类型。</p>\n</li>\n<li><p>expression: 要转换的表达式。</p>\n</li>\n<li><p>style(可选): 用于日期和时间类型转换的格式代码，这个参数在<code>SQL Server</code>中特别有用，可以控制日期和时间数据的显示格式。</p>\n</li>\n<li><p>示例:<br>将日期时间转换为格式化的字符串（SQL Server）：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">CONVERT</span>(<span class=\"hljs-type\">VARCHAR</span>, GETDATE(), <span class=\"hljs-number\">101</span>); <span class=\"hljs-comment\">-- 输出 mm/dd/yyyy 格式的日期</span><br></code></pre></td></tr></table></figure>\n\n<p>将字符串 ‘2021-12-31’ 转换为日期类型：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-keyword\">CONVERT</span>(<span class=\"hljs-type\">DATE</span>, <span class=\"hljs-string\">&#x27;2021-12-31&#x27;</span>);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<p><strong>下面直接给出一些相关解释</strong><br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2_1.png\" alt=\"格式转换_1\"><br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2_2.png\" alt=\"格式转换_2\"><br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2_3.png\" alt=\"格式转换_3\"><br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2_4.png\" alt=\"格式转换_4\"></p>\n<h2 id=\"存储约束\"><a href=\"#存储约束\" class=\"headerlink\" title=\"存储约束\"></a>存储约束</h2><h3 id=\"大型对象存储\"><a href=\"#大型对象存储\" class=\"headerlink\" title=\"大型对象存储\"></a>大型对象存储</h3><p>在数据库中，针对需要存储大量数据的场景（如照片、视频等），常使用以下两种数据类型：</p>\n<ul>\n<li><p><strong>BLOB (Binary Large Object)</strong>:</p>\n<ul>\n<li><p>用于存储大量的未解释二进制数据。</p>\n</li>\n<li><p>例如，定义一个可以存储10MB大小的图像：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">image <span class=\"hljs-type\">BLOB</span>(<span class=\"hljs-number\">10</span>MB)<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>CLOB (Character Large Object)</strong>:</p>\n<ul>\n<li><p>用于存储大量的文本数据。</p>\n</li>\n<li><p>例如，定义一个可以存储10KB文本数据的 CLOB：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\">book_view <span class=\"hljs-type\">CLOB</span>(<span class=\"hljs-number\">10</span>KB)<br></code></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"XML-数据类型\"><a href=\"#XML-数据类型\" class=\"headerlink\" title=\"XML 数据类型\"></a>XML 数据类型</h3><ul>\n<li><p>XML 数据类型用于在关系数据库中存储和查询结构化的 XML 数据。</p>\n</li>\n<li><p>示例：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> book (<br>    book_id <span class=\"hljs-type\">INT</span> <span class=\"hljs-keyword\">PRIMARY</span> KEY,<br>    book_view <span class=\"hljs-type\">CLOB</span>(<span class=\"hljs-number\">10</span>KB),<br>    image <span class=\"hljs-type\">BLOB</span>(<span class=\"hljs-number\">10</span>MB),<br>    movie <span class=\"hljs-type\">BLOB</span>(<span class=\"hljs-number\">2</span>GB),<br>    catalog XML<br>);<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"用户定义类型-UDT\"><a href=\"#用户定义类型-UDT\" class=\"headerlink\" title=\"用户定义类型 (UDT)\"></a>用户定义类型 (UDT)</h3><ul>\n<li><p>使用<code>CREATE TYPE</code>语句可以定义新的数据类型，用于表定义中。</p>\n</li>\n<li><p>示例：定义一个代表货币的类型：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> TYPE Dollars <span class=\"hljs-keyword\">AS</span> <span class=\"hljs-type\">NUMERIC</span>(<span class=\"hljs-number\">12</span>,<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">FINAL</span>;<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"用户定义域\"><a href=\"#用户定义域\" class=\"headerlink\" title=\"用户定义域\"></a>用户定义域</h3><ul>\n<li><p><code>CREATE DOMAIN</code>语句创建带有特定约束的自定义域，用于更细致的数据控制。</p>\n</li>\n<li><p>示例：定义一个代表货币的类型：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> DOMAIN person_name <span class=\"hljs-type\">CHAR</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span>;<br><span class=\"hljs-keyword\">CREATE</span> DOMAIN degree_level <span class=\"hljs-type\">VARCHAR</span>(<span class=\"hljs-number\">10</span>)<br><span class=\"hljs-keyword\">CONSTRAINT</span> degree_level_test<br><span class=\"hljs-keyword\">CHECK</span> (<span class=\"hljs-keyword\">value</span> <span class=\"hljs-keyword\">IN</span> (<span class=\"hljs-string\">&#x27;Bachelors&#x27;</span>, <span class=\"hljs-string\">&#x27;Masters&#x27;</span>, <span class=\"hljs-string\">&#x27;Doctorate&#x27;</span>));<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"数据库的三级层次结构\"><a href=\"#数据库的三级层次结构\" class=\"headerlink\" title=\"数据库的三级层次结构\"></a>数据库的三级层次结构</h2><p>在现代数据库系统中，存在一个三级层次结构，用以组织和管理数据对象，如关系和视图。这一结构提供了对数据库对象的逻辑分类和隔离，便于管理和访问。</p>\n<h3 id=\"目录（Catalogs）\"><a href=\"#目录（Catalogs）\" class=\"headerlink\" title=\"目录（Catalogs）\"></a>目录（Catalogs）</h3><ul>\n<li>目录也常被称为数据库（Database）。</li>\n<li>一个数据库系统可以包含多个目录，每个目录可包含多个模式（Schemas）。</li>\n<li>示例：<code>catalog5</code> 可以看作是一个目录。</li>\n</ul>\n<h3 id=\"模式（Schemas）\"><a href=\"#模式（Schemas）\" class=\"headerlink\" title=\"模式（Schemas）\"></a>模式（Schemas）</h3><ul>\n<li>模式是存储关系（Relations）和视图（Views）的容器。</li>\n<li>模式对象代表了数据库对象的所有权上下文。</li>\n<li>示例：<code>univ_schema</code> 是 <code>catalog5</code> 目录中的一个模式。</li>\n</ul>\n<h3 id=\"关系与视图（SQL-Objects）\"><a href=\"#关系与视图（SQL-Objects）\" class=\"headerlink\" title=\"关系与视图（SQL Objects）\"></a>关系与视图（SQL Objects）</h3><ul>\n<li>关系和视图是存储在模式中的SQL对象。</li>\n<li>这些对象可以通过三部分名称来访问，例如：<code>catalog5.univ_schema.course</code>。</li>\n</ul>\n<h3 id=\"数据库连接与用户环境\"><a href=\"#数据库连接与用户环境\" class=\"headerlink\" title=\"数据库连接与用户环境\"></a>数据库连接与用户环境</h3><ul>\n<li>要对数据库执行任何操作，用户必须首先连接到数据库。</li>\n<li>用户需要提供用户名和通常的密码来验证用户身份。</li>\n<li>每个用户都有一个默认的目录和模式，且此组合对于用户是唯一的。</li>\n<li>SQL环境包括用户标识符、连接、目录和模式等。</li>\n</ul>\n<p>通过这种结构化的管理方式，数据库不仅能够提高数据访问的效率，还能加强数据安全性和隔离性。这对于处理大量复杂数据的企业级应用尤为重要。</p>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(6)/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png\" alt=\"数据库三层次结构\"></p>\n<h2 id=\"断言-Assertions\"><a href=\"#断言-Assertions\" class=\"headerlink\" title=\"断言(Assertions)\"></a>断言(Assertions)</h2><p>断言是一个谓词表达式，用于表示数据库应始终满足的条件。例如，域约束和引用完整性约束。</p>\n<ul>\n<li><p>断言形式：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs sql\"><span class=\"hljs-keyword\">CREATE</span> ASSERTION <span class=\"hljs-operator\">&lt;</span>assertion<span class=\"hljs-operator\">-</span>name<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">CHECK</span> <span class=\"hljs-operator\">&lt;</span>predicate<span class=\"hljs-operator\">&gt;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>断言的实施可能会导致显著的性能开销，因为数据库管理系统（DBMS）需要在每次数据库修改时验证断言的有效性。因此，应谨慎使用断言。</p>\n</li>\n</ul>\n<p><strong>示例</strong>:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> ASSERTION credits_earned_constraints <span class=\"hljs-keyword\">CHECK</span> (<br>    <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">EXISTS</span> (<br>        <span class=\"hljs-keyword\">SELECT</span> ID <span class=\"hljs-keyword\">FROM</span> student<br>        <span class=\"hljs-keyword\">WHERE</span> tot_cred <span class=\"hljs-operator\">&lt;&gt;</span> (<br>            <span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-built_in\">SUM</span>(credits) <span class=\"hljs-keyword\">FROM</span> takes <span class=\"hljs-keyword\">NATURAL</span> <span class=\"hljs-keyword\">JOIN</span> course<br>            <span class=\"hljs-keyword\">WHERE</span> student.ID <span class=\"hljs-operator\">=</span> takes.ID <span class=\"hljs-keyword\">AND</span> grade <span class=\"hljs-keyword\">IS</span> <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">AND</span> grade <span class=\"hljs-operator\">&lt;&gt;</span> <span class=\"hljs-string\">&#x27;F&#x27;</span><br>        )<br>    )<br>)<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"索引-Indexes\"><a href=\"#索引-Indexes\" class=\"headerlink\" title=\"索引(Indexes)\"></a>索引(Indexes)</h2><p>索引是一个使数据库系统能够有效找到具有特定属性值的元组的数据结构，而无需扫描整个关系的所有元组。</p>\n<ul>\n<li><p>创建索引的命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> INDEX <span class=\"hljs-operator\">&lt;</span>name<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-operator\">&lt;</span>relation<span class=\"hljs-operator\">-</span>name<span class=\"hljs-operator\">&gt;</span> (attribute);<br></code></pre></td></tr></table></figure>\n</li>\n<li><p>创建索引能够有效提高根据索引查找的速度，因为索引的本质是另外维护了一张图，在这个过程中并不用遍历整张表。但是这同时增加了数据库在存储上的开销</p>\n</li>\n<li><p>一旦索引创建完成，当我们执行涉及到索引列的查询时，数据库管理系统会自动使用这个索引来加速查找过程。</p>\n</li>\n</ul>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">CREATE</span> INDEX idx_registration_date <span class=\"hljs-keyword\">ON</span> students(registration_date);<br><span class=\"hljs-keyword\">SELECT</span> <span class=\"hljs-operator\">*</span> <span class=\"hljs-keyword\">FROM</span> students <span class=\"hljs-keyword\">WHERE</span> registration_date <span class=\"hljs-operator\">&gt;=</span> <span class=\"hljs-string\">&#x27;2021-01-01&#x27;</span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"访问授权（Authorization）\"><a href=\"#访问授权（Authorization）\" class=\"headerlink\" title=\"访问授权（Authorization）\"></a>访问授权（Authorization）</h2><p>数据库系统中的访问授权可以控制不同用户对数据库的不同部分的访问权限。授权类型包括读取、插入、更新和删除。</p>\n<ul>\n<li><p>授权命令：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">GRANT</span> <span class=\"hljs-operator\">&lt;</span>privilege list<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">ON</span> <span class=\"hljs-operator\">&lt;</span>relation<span class=\"hljs-operator\">-</span>name <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">view</span><span class=\"hljs-operator\">-</span>name<span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-keyword\">TO</span> <span class=\"hljs-operator\">&lt;</span><span class=\"hljs-keyword\">user</span><span class=\"hljs-operator\">-</span>list<span class=\"hljs-operator\">&gt;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p>数据库部分的授权形式</p>\n<ul>\n<li>**读取(Read)**：允许读取数据，但不能修改数据。</li>\n<li>**插入(Insert)**：允许插入新数据，但不能修改现有数据。</li>\n<li>**更新(Update)**：允许修改数据，但不能删除数据。</li>\n<li>**删除(Delete)**：允许删除数据。</li>\n</ul>\n</li>\n<li><p>修改数据库架构的授权形式</p>\n<ul>\n<li>**资源(Resources)**：允许创建新的关系。</li>\n<li>**变更(Alteration)**：允许在关系中添加或删除属性。</li>\n<li>**删除(Drop)**：允许删除关系。</li>\n<li>**索引(Index)**：与索引相关的权限。</li>\n</ul>\n</li>\n<li><p><strong>all privileges</strong>：所有权限</p>\n</li>\n<li><p>用户列表内容</p>\n<ul>\n<li>user_id</li>\n<li>public, which allows all valid users the privilege granted</li>\n<li>角色(role)</li>\n</ul>\n</li>\n</ul>\n<p><strong>示例</strong>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">on</span> instructor <span class=\"hljs-keyword\">to</span> U1, U2, U3;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"创建和管理角色\"><a href=\"#创建和管理角色\" class=\"headerlink\" title=\"创建和管理角色\"></a>创建和管理角色</h2><p>角色是一种用于管理权限的机制，可以简化权限的分配和管理过程。角色可以包含一组权限，并且可以被授予给用户或其他角色。</p>\n<h3 id=\"创建角色\"><a href=\"#创建角色\" class=\"headerlink\" title=\"创建角色\"></a>创建角色</h3><p>使用<code>create role</code>语句来创建一个新的角色。例如，创建一个名为<code>instructor</code>的角色：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">create</span> role instructor;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"授权角色\"><a href=\"#授权角色\" class=\"headerlink\" title=\"授权角色\"></a>授权角色</h3><p>将角色授予用户，使用户可以获得该角色所拥有的权限。例如，将<code>instructor</code>角色授予用户<code>Amit</code></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">grant</span> instructor <span class=\"hljs-keyword\">to</span> Amit;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"角色的权限管理\"><a href=\"#角色的权限管理\" class=\"headerlink\" title=\"角色的权限管理\"></a>角色的权限管理</h3><p>可以直接向角色授权特定的数据库操作权限。例如，授予<code>instructor</code>角色在<code>takes</code>表上的选择权限：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">select</span> <span class=\"hljs-keyword\">on</span> takes <span class=\"hljs-keyword\">to</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"角色的继承\"><a href=\"#角色的继承\" class=\"headerlink\" title=\"角色的继承\"></a>角色的继承</h3><p>角色可以被授予给其他角色，从而实现权限的继承。例如，创建一个名为<code>teaching_assistant</code>的角色，并将其授予<code>instructor</code>角色。这样，<code>instructor</code>角色会继承<code>teaching_assistant</code>角色的所有权限：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">create</span> role teaching_assistant;<br><span class=\"hljs-keyword\">grant</span> teaching_assistant <span class=\"hljs-keyword\">to</span> instructor;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"角色链\"><a href=\"#角色链\" class=\"headerlink\" title=\"角色链\"></a>角色链</h3><p>角色可以形成一个授权链，其中每个角色可以被授予给其他角色。例如，创建一个<code>dean</code>角色，并将<code>instructor</code>角色授予<code>dean</code>，然后将<code>dean</code>角色授予用户<code>Satoshi</code>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs SQL\"><span class=\"hljs-keyword\">create</span> role dean;<br><span class=\"hljs-keyword\">grant</span> instructor <span class=\"hljs-keyword\">to</span> dean;<br><span class=\"hljs-keyword\">grant</span> dean <span class=\"hljs-keyword\">to</span> Satoshi;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"视图权限\"><a href=\"#视图权限\" class=\"headerlink\" title=\"视图权限\"></a>视图权限</h2><p>视图权限和语法的使用和上述同理</p>\n"},{"title":"数据库(7)","date":"2024-12-22T15:12:53.000Z","_content":"好吧，操作系统也有`ER`图，不知道为何，我很讨厌软件工程的这种教学内容，但是我很支持软件工程这种工业化流水线式的软件规划本身，在此叠甲。\n不过的确如此，对于复杂系统的设计，往往都需要进行相应的前置研究。\n\n![E-R diagram for a university enterprise](/img/数据库(7)/ER_1.png)\n\n## 数据库设计过程和方法\n\n### 整体设计过程\n\n**数据库架构设计一班分为三级**：\n\n- 概念设计\n- 逻辑设计\n- 物理设计\n\n![数据库设计整体过程](/img/数据库(7)/数据库整体设计过程.png)\n\n类似于一般软件工程中的设计过程，在数据库设计的过程中，首先进行进行需求分析，然后是相关的概念设计、逻辑设计和物理设计。在逻辑设计的过程中会生成初始关系模式并且规范化关系架构。\n\n![DBS设计](/img/数据库(7)/DBS设计.png)\n\n- 数据库应用系统(DBAS)设计\n  - DB, DBMS, application programs\n- DBAS设计过程\n  - 生命周期包括五个阶段：\n        项目规划、需求分析、系统设计、实现与部署、运行管理与维护等\n  - 根据软件组成和各自功能，分为三条设计主线：\n    - 数据组织与存储设计、数据访问与处理设计、应用设计\n    - 分别用于设计数据库、数据库事务和应用程序\n  - 根据数据库系统三级模式结构，设计阶段分为三个步骤：\n    - 概念设计、逻辑设计、物理设计\n    - 每一步设计内容涵盖了三条设计主线。\n  \n![设计过程](/img/数据库(7)/设计过程.png)\n\n## E-R模型(实体关系模型0)(概念设计)\n\n- E-R数据关系模型常常被用来帮助代表 DB 整体逻辑结构的数据库设计\n- ER设计有助于将实际企业的含义和交互映射到概念架构上。\n\n**对于ER关系模型往往包含如下三个内容**：\n\n- 实体集\n- 关系集\n- 属性\n\n### Entity Sets（实体集，实体型）\n\n- 定义：实体是存在且可与其他对象区分开来的对象。\n  - 示例：特定人员、公司\n- 实体集是一组共享相同属性的相同类型的实体。\n  - 示例：人员集、公司\n- 实体由一组属性表示，即，实体集的描述性属性\n  - 例：\n    instructor = (ID, name, street, city, salary )\n    course= (course_id, title, credits)\n- 属性的子集构成主键;即，唯一标识实体集的每个成员。\n\n对于实体本身，其有实体属性和属性相应的值组成\n对于一个实体的定义一般如下\n$$\n\\texttt{instructor-set} = \\left\\{ \\langle \\texttt{instructor\\_ID}, \\texttt{instructor\\_name} \\rangle \\mid \\texttt{instructor\\_ID} \\in D_1, \\texttt{instructor\\_name} \\in D_2 \\right\\} \\subseteq D_1 \\times D_2\n$$\n\n### Relationship Sets(关系集)\n\n- 此处的关系是指不同实体之间的联系\n  **Example**：\n\n  | 44553 (Peltier) | advisor | 22222 (Einstein) |\n  |-----------------|---------|------------------|\n  | student entity  | relationship set | instructor entity |\n\n- 一个关系集往往包含$n$个实体之间数学关系一般表示如下\n  $$\n  \\{ (e_1, e_2, \\dots, e_n) \\mid e_1 \\in E_1, e_2 \\in E_2, \\dots, e_n \\in E_n \\}\n  $$\n  **Example**\n  $(44553,22222) \\in advisor$\n- 同一实体集中存在会存在多个关系，一个关系实体包含了现实世界实体中存在的实体\n- 同理，对于属性而言，其本身可以存在于多个关系中\n- 关系的实体集不必是不同的，实体集中的每个匹配项在关系中都起着一个作用\n  - 实体在关系中扮演的角色称为该实体的角色\n- 大多数数据关系集都属于二元关系，二元关系设计两个实体集，但是同时也存在三元关系，如下\n  例如：学生在导师的指导下参与研究项目。\n  ![三元关系](/img/数据库(7)/三元关系.png)\n- 对于属性的值域往往可以是自行定义的一定范围，也可以是类似于在数据库定义中的枚举形式(check...in...),同时也可以是类似于结构体的形式，即**复合属性**。\n  ![复合属性](/img/数据库(7)/复合属性.png)\n  相同于数据库，其本身的属性域中也可以包含`NULL`，即表示该属性对实体不适用或不存在，或者该属性的值存在，但当前“未知”\n- 复合属性允许将属性分解为子部分，\n\n### 映射基数约束\n\n\n\n\n\n\n\n\n## E-R 图简化为关系架构(逻辑设计)\n\n## 示例","source":"_posts/数据库-7.md","raw":"---\ntitle: 数据库(7)\ndate: 2024-12-22 23:12:53\ntags:\n    - 学习笔记\n    - 数据库\n---\n好吧，操作系统也有`ER`图，不知道为何，我很讨厌软件工程的这种教学内容，但是我很支持软件工程这种工业化流水线式的软件规划本身，在此叠甲。\n不过的确如此，对于复杂系统的设计，往往都需要进行相应的前置研究。\n\n![E-R diagram for a university enterprise](/img/数据库(7)/ER_1.png)\n\n## 数据库设计过程和方法\n\n### 整体设计过程\n\n**数据库架构设计一班分为三级**：\n\n- 概念设计\n- 逻辑设计\n- 物理设计\n\n![数据库设计整体过程](/img/数据库(7)/数据库整体设计过程.png)\n\n类似于一般软件工程中的设计过程，在数据库设计的过程中，首先进行进行需求分析，然后是相关的概念设计、逻辑设计和物理设计。在逻辑设计的过程中会生成初始关系模式并且规范化关系架构。\n\n![DBS设计](/img/数据库(7)/DBS设计.png)\n\n- 数据库应用系统(DBAS)设计\n  - DB, DBMS, application programs\n- DBAS设计过程\n  - 生命周期包括五个阶段：\n        项目规划、需求分析、系统设计、实现与部署、运行管理与维护等\n  - 根据软件组成和各自功能，分为三条设计主线：\n    - 数据组织与存储设计、数据访问与处理设计、应用设计\n    - 分别用于设计数据库、数据库事务和应用程序\n  - 根据数据库系统三级模式结构，设计阶段分为三个步骤：\n    - 概念设计、逻辑设计、物理设计\n    - 每一步设计内容涵盖了三条设计主线。\n  \n![设计过程](/img/数据库(7)/设计过程.png)\n\n## E-R模型(实体关系模型0)(概念设计)\n\n- E-R数据关系模型常常被用来帮助代表 DB 整体逻辑结构的数据库设计\n- ER设计有助于将实际企业的含义和交互映射到概念架构上。\n\n**对于ER关系模型往往包含如下三个内容**：\n\n- 实体集\n- 关系集\n- 属性\n\n### Entity Sets（实体集，实体型）\n\n- 定义：实体是存在且可与其他对象区分开来的对象。\n  - 示例：特定人员、公司\n- 实体集是一组共享相同属性的相同类型的实体。\n  - 示例：人员集、公司\n- 实体由一组属性表示，即，实体集的描述性属性\n  - 例：\n    instructor = (ID, name, street, city, salary )\n    course= (course_id, title, credits)\n- 属性的子集构成主键;即，唯一标识实体集的每个成员。\n\n对于实体本身，其有实体属性和属性相应的值组成\n对于一个实体的定义一般如下\n$$\n\\texttt{instructor-set} = \\left\\{ \\langle \\texttt{instructor\\_ID}, \\texttt{instructor\\_name} \\rangle \\mid \\texttt{instructor\\_ID} \\in D_1, \\texttt{instructor\\_name} \\in D_2 \\right\\} \\subseteq D_1 \\times D_2\n$$\n\n### Relationship Sets(关系集)\n\n- 此处的关系是指不同实体之间的联系\n  **Example**：\n\n  | 44553 (Peltier) | advisor | 22222 (Einstein) |\n  |-----------------|---------|------------------|\n  | student entity  | relationship set | instructor entity |\n\n- 一个关系集往往包含$n$个实体之间数学关系一般表示如下\n  $$\n  \\{ (e_1, e_2, \\dots, e_n) \\mid e_1 \\in E_1, e_2 \\in E_2, \\dots, e_n \\in E_n \\}\n  $$\n  **Example**\n  $(44553,22222) \\in advisor$\n- 同一实体集中存在会存在多个关系，一个关系实体包含了现实世界实体中存在的实体\n- 同理，对于属性而言，其本身可以存在于多个关系中\n- 关系的实体集不必是不同的，实体集中的每个匹配项在关系中都起着一个作用\n  - 实体在关系中扮演的角色称为该实体的角色\n- 大多数数据关系集都属于二元关系，二元关系设计两个实体集，但是同时也存在三元关系，如下\n  例如：学生在导师的指导下参与研究项目。\n  ![三元关系](/img/数据库(7)/三元关系.png)\n- 对于属性的值域往往可以是自行定义的一定范围，也可以是类似于在数据库定义中的枚举形式(check...in...),同时也可以是类似于结构体的形式，即**复合属性**。\n  ![复合属性](/img/数据库(7)/复合属性.png)\n  相同于数据库，其本身的属性域中也可以包含`NULL`，即表示该属性对实体不适用或不存在，或者该属性的值存在，但当前“未知”\n- 复合属性允许将属性分解为子部分，\n\n### 映射基数约束\n\n\n\n\n\n\n\n\n## E-R 图简化为关系架构(逻辑设计)\n\n## 示例","slug":"数据库-7","published":1,"updated":"2024-12-25T11:59:21.653Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot7000g6d6eex939zfe","content":"<p>好吧，操作系统也有<code>ER</code>图，不知道为何，我很讨厌软件工程的这种教学内容，但是我很支持软件工程这种工业化流水线式的软件规划本身，在此叠甲。<br>不过的确如此，对于复杂系统的设计，往往都需要进行相应的前置研究。</p>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/ER_1.png\" alt=\"E-R diagram for a university enterprise\"></p>\n<h2 id=\"数据库设计过程和方法\"><a href=\"#数据库设计过程和方法\" class=\"headerlink\" title=\"数据库设计过程和方法\"></a>数据库设计过程和方法</h2><h3 id=\"整体设计过程\"><a href=\"#整体设计过程\" class=\"headerlink\" title=\"整体设计过程\"></a>整体设计过程</h3><p><strong>数据库架构设计一班分为三级</strong>：</p>\n<ul>\n<li>概念设计</li>\n<li>逻辑设计</li>\n<li>物理设计</li>\n</ul>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png\" alt=\"数据库设计整体过程\"></p>\n<p>类似于一般软件工程中的设计过程，在数据库设计的过程中，首先进行进行需求分析，然后是相关的概念设计、逻辑设计和物理设计。在逻辑设计的过程中会生成初始关系模式并且规范化关系架构。</p>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/DBS%E8%AE%BE%E8%AE%A1.png\" alt=\"DBS设计\"></p>\n<ul>\n<li>数据库应用系统(DBAS)设计<ul>\n<li>DB, DBMS, application programs</li>\n</ul>\n</li>\n<li>DBAS设计过程<ul>\n<li>生命周期包括五个阶段：<br>项目规划、需求分析、系统设计、实现与部署、运行管理与维护等</li>\n<li>根据软件组成和各自功能，分为三条设计主线：<ul>\n<li>数据组织与存储设计、数据访问与处理设计、应用设计</li>\n<li>分别用于设计数据库、数据库事务和应用程序</li>\n</ul>\n</li>\n<li>根据数据库系统三级模式结构，设计阶段分为三个步骤：<ul>\n<li>概念设计、逻辑设计、物理设计</li>\n<li>每一步设计内容涵盖了三条设计主线。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png\" alt=\"设计过程\"></p>\n<h2 id=\"E-R模型-实体关系模型0-概念设计\"><a href=\"#E-R模型-实体关系模型0-概念设计\" class=\"headerlink\" title=\"E-R模型(实体关系模型0)(概念设计)\"></a>E-R模型(实体关系模型0)(概念设计)</h2><ul>\n<li>E-R数据关系模型常常被用来帮助代表 DB 整体逻辑结构的数据库设计</li>\n<li>ER设计有助于将实际企业的含义和交互映射到概念架构上。</li>\n</ul>\n<p><strong>对于ER关系模型往往包含如下三个内容</strong>：</p>\n<ul>\n<li>实体集</li>\n<li>关系集</li>\n<li>属性</li>\n</ul>\n<h3 id=\"Entity-Sets（实体集，实体型）\"><a href=\"#Entity-Sets（实体集，实体型）\" class=\"headerlink\" title=\"Entity Sets（实体集，实体型）\"></a>Entity Sets（实体集，实体型）</h3><ul>\n<li>定义：实体是存在且可与其他对象区分开来的对象。<ul>\n<li>示例：特定人员、公司</li>\n</ul>\n</li>\n<li>实体集是一组共享相同属性的相同类型的实体。<ul>\n<li>示例：人员集、公司</li>\n</ul>\n</li>\n<li>实体由一组属性表示，即，实体集的描述性属性<ul>\n<li>例：<br>instructor &#x3D; (ID, name, street, city, salary )<br>course&#x3D; (course_id, title, credits)</li>\n</ul>\n</li>\n<li>属性的子集构成主键;即，唯一标识实体集的每个成员。</li>\n</ul>\n<p>对于实体本身，其有实体属性和属性相应的值组成<br>对于一个实体的定义一般如下<br>$$<br>\\texttt{instructor-set} &#x3D; \\left{ \\langle \\texttt{instructor_ID}, \\texttt{instructor_name} \\rangle \\mid \\texttt{instructor_ID} \\in D_1, \\texttt{instructor_name} \\in D_2 \\right} \\subseteq D_1 \\times D_2<br>$$</p>\n<h3 id=\"Relationship-Sets-关系集\"><a href=\"#Relationship-Sets-关系集\" class=\"headerlink\" title=\"Relationship Sets(关系集)\"></a>Relationship Sets(关系集)</h3><ul>\n<li><p>此处的关系是指不同实体之间的联系<br><strong>Example</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>44553 (Peltier)</th>\n<th>advisor</th>\n<th>22222 (Einstein)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>student entity</td>\n<td>relationship set</td>\n<td>instructor entity</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>一个关系集往往包含$n$个实体之间数学关系一般表示如下<br>$$<br>{ (e_1, e_2, \\dots, e_n) \\mid e_1 \\in E_1, e_2 \\in E_2, \\dots, e_n \\in E_n }<br>$$<br><strong>Example</strong><br>$(44553,22222) \\in advisor$</p>\n</li>\n<li><p>同一实体集中存在会存在多个关系，一个关系实体包含了现实世界实体中存在的实体</p>\n</li>\n<li><p>同理，对于属性而言，其本身可以存在于多个关系中</p>\n</li>\n<li><p>关系的实体集不必是不同的，实体集中的每个匹配项在关系中都起着一个作用</p>\n<ul>\n<li>实体在关系中扮演的角色称为该实体的角色</li>\n</ul>\n</li>\n<li><p>大多数数据关系集都属于二元关系，二元关系设计两个实体集，但是同时也存在三元关系，如下<br>例如：学生在导师的指导下参与研究项目。<br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/%E4%B8%89%E5%85%83%E5%85%B3%E7%B3%BB.png\" alt=\"三元关系\"></p>\n</li>\n<li><p>对于属性的值域往往可以是自行定义的一定范围，也可以是类似于在数据库定义中的枚举形式(check…in…),同时也可以是类似于结构体的形式，即<strong>复合属性</strong>。<br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/%E5%A4%8D%E5%90%88%E5%B1%9E%E6%80%A7.png\" alt=\"复合属性\"><br>相同于数据库，其本身的属性域中也可以包含<code>NULL</code>，即表示该属性对实体不适用或不存在，或者该属性的值存在，但当前“未知”</p>\n</li>\n<li><p>复合属性允许将属性分解为子部分，</p>\n</li>\n</ul>\n<h3 id=\"映射基数约束\"><a href=\"#映射基数约束\" class=\"headerlink\" title=\"映射基数约束\"></a>映射基数约束</h3><h2 id=\"E-R-图简化为关系架构-逻辑设计\"><a href=\"#E-R-图简化为关系架构-逻辑设计\" class=\"headerlink\" title=\"E-R 图简化为关系架构(逻辑设计)\"></a>E-R 图简化为关系架构(逻辑设计)</h2><h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2>","excerpt":"","more":"<p>好吧，操作系统也有<code>ER</code>图，不知道为何，我很讨厌软件工程的这种教学内容，但是我很支持软件工程这种工业化流水线式的软件规划本身，在此叠甲。<br>不过的确如此，对于复杂系统的设计，往往都需要进行相应的前置研究。</p>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/ER_1.png\" alt=\"E-R diagram for a university enterprise\"></p>\n<h2 id=\"数据库设计过程和方法\"><a href=\"#数据库设计过程和方法\" class=\"headerlink\" title=\"数据库设计过程和方法\"></a>数据库设计过程和方法</h2><h3 id=\"整体设计过程\"><a href=\"#整体设计过程\" class=\"headerlink\" title=\"整体设计过程\"></a>整体设计过程</h3><p><strong>数据库架构设计一班分为三级</strong>：</p>\n<ul>\n<li>概念设计</li>\n<li>逻辑设计</li>\n<li>物理设计</li>\n</ul>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B4%E4%BD%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png\" alt=\"数据库设计整体过程\"></p>\n<p>类似于一般软件工程中的设计过程，在数据库设计的过程中，首先进行进行需求分析，然后是相关的概念设计、逻辑设计和物理设计。在逻辑设计的过程中会生成初始关系模式并且规范化关系架构。</p>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/DBS%E8%AE%BE%E8%AE%A1.png\" alt=\"DBS设计\"></p>\n<ul>\n<li>数据库应用系统(DBAS)设计<ul>\n<li>DB, DBMS, application programs</li>\n</ul>\n</li>\n<li>DBAS设计过程<ul>\n<li>生命周期包括五个阶段：<br>项目规划、需求分析、系统设计、实现与部署、运行管理与维护等</li>\n<li>根据软件组成和各自功能，分为三条设计主线：<ul>\n<li>数据组织与存储设计、数据访问与处理设计、应用设计</li>\n<li>分别用于设计数据库、数据库事务和应用程序</li>\n</ul>\n</li>\n<li>根据数据库系统三级模式结构，设计阶段分为三个步骤：<ul>\n<li>概念设计、逻辑设计、物理设计</li>\n<li>每一步设计内容涵盖了三条设计主线。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png\" alt=\"设计过程\"></p>\n<h2 id=\"E-R模型-实体关系模型0-概念设计\"><a href=\"#E-R模型-实体关系模型0-概念设计\" class=\"headerlink\" title=\"E-R模型(实体关系模型0)(概念设计)\"></a>E-R模型(实体关系模型0)(概念设计)</h2><ul>\n<li>E-R数据关系模型常常被用来帮助代表 DB 整体逻辑结构的数据库设计</li>\n<li>ER设计有助于将实际企业的含义和交互映射到概念架构上。</li>\n</ul>\n<p><strong>对于ER关系模型往往包含如下三个内容</strong>：</p>\n<ul>\n<li>实体集</li>\n<li>关系集</li>\n<li>属性</li>\n</ul>\n<h3 id=\"Entity-Sets（实体集，实体型）\"><a href=\"#Entity-Sets（实体集，实体型）\" class=\"headerlink\" title=\"Entity Sets（实体集，实体型）\"></a>Entity Sets（实体集，实体型）</h3><ul>\n<li>定义：实体是存在且可与其他对象区分开来的对象。<ul>\n<li>示例：特定人员、公司</li>\n</ul>\n</li>\n<li>实体集是一组共享相同属性的相同类型的实体。<ul>\n<li>示例：人员集、公司</li>\n</ul>\n</li>\n<li>实体由一组属性表示，即，实体集的描述性属性<ul>\n<li>例：<br>instructor &#x3D; (ID, name, street, city, salary )<br>course&#x3D; (course_id, title, credits)</li>\n</ul>\n</li>\n<li>属性的子集构成主键;即，唯一标识实体集的每个成员。</li>\n</ul>\n<p>对于实体本身，其有实体属性和属性相应的值组成<br>对于一个实体的定义一般如下<br>$$<br>\\texttt{instructor-set} &#x3D; \\left{ \\langle \\texttt{instructor_ID}, \\texttt{instructor_name} \\rangle \\mid \\texttt{instructor_ID} \\in D_1, \\texttt{instructor_name} \\in D_2 \\right} \\subseteq D_1 \\times D_2<br>$$</p>\n<h3 id=\"Relationship-Sets-关系集\"><a href=\"#Relationship-Sets-关系集\" class=\"headerlink\" title=\"Relationship Sets(关系集)\"></a>Relationship Sets(关系集)</h3><ul>\n<li><p>此处的关系是指不同实体之间的联系<br><strong>Example</strong>：</p>\n<table>\n<thead>\n<tr>\n<th>44553 (Peltier)</th>\n<th>advisor</th>\n<th>22222 (Einstein)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>student entity</td>\n<td>relationship set</td>\n<td>instructor entity</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>一个关系集往往包含$n$个实体之间数学关系一般表示如下<br>$$<br>{ (e_1, e_2, \\dots, e_n) \\mid e_1 \\in E_1, e_2 \\in E_2, \\dots, e_n \\in E_n }<br>$$<br><strong>Example</strong><br>$(44553,22222) \\in advisor$</p>\n</li>\n<li><p>同一实体集中存在会存在多个关系，一个关系实体包含了现实世界实体中存在的实体</p>\n</li>\n<li><p>同理，对于属性而言，其本身可以存在于多个关系中</p>\n</li>\n<li><p>关系的实体集不必是不同的，实体集中的每个匹配项在关系中都起着一个作用</p>\n<ul>\n<li>实体在关系中扮演的角色称为该实体的角色</li>\n</ul>\n</li>\n<li><p>大多数数据关系集都属于二元关系，二元关系设计两个实体集，但是同时也存在三元关系，如下<br>例如：学生在导师的指导下参与研究项目。<br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/%E4%B8%89%E5%85%83%E5%85%B3%E7%B3%BB.png\" alt=\"三元关系\"></p>\n</li>\n<li><p>对于属性的值域往往可以是自行定义的一定范围，也可以是类似于在数据库定义中的枚举形式(check…in…),同时也可以是类似于结构体的形式，即<strong>复合属性</strong>。<br><img src=\"/img/%E6%95%B0%E6%8D%AE%E5%BA%93(7)/%E5%A4%8D%E5%90%88%E5%B1%9E%E6%80%A7.png\" alt=\"复合属性\"><br>相同于数据库，其本身的属性域中也可以包含<code>NULL</code>，即表示该属性对实体不适用或不存在，或者该属性的值存在，但当前“未知”</p>\n</li>\n<li><p>复合属性允许将属性分解为子部分，</p>\n</li>\n</ul>\n<h3 id=\"映射基数约束\"><a href=\"#映射基数约束\" class=\"headerlink\" title=\"映射基数约束\"></a>映射基数约束</h3><h2 id=\"E-R-图简化为关系架构-逻辑设计\"><a href=\"#E-R-图简化为关系架构-逻辑设计\" class=\"headerlink\" title=\"E-R 图简化为关系架构(逻辑设计)\"></a>E-R 图简化为关系架构(逻辑设计)</h2><h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2>"},{"title":"数据库(8)","date":"2024-12-27T07:45:59.000Z","_content":"\n## 文件组织形式\n\n### 文件逻辑/物理组织\n\n1. 逻辑结构\n   - 流式文件\n   - 基于记录文件\n   - 基于索引的文件\n2. 物理组织/结构\n   - 以`block`为单位，存储在`secondary storage`例如磁盘、SSD中\n   - 特征：contiguous(连续), linked(链接), indexed(索引)\n\nDB 存储为 DB 文件的集合(包括 SQL Server， 主文件，辅文件，日志文件)。其中，每个文件都是一个记录序列，每条记录都位于一系列字段中。一种方法DB存储方法中：记录大小是固定的，每个文件仅包含一种特定类型的记录，不同的文件用于不同的关系。\n\n每个文件都是一系列的记录，每一个关系表都是一组元组。DB的逻辑文件以元组为单位，而物理文件以记录为文件。\n\n存在几种常见的文件存储方式，此处不做过多描述。\n\n对于文件删除后的处理方式一般包含三种，具体可以查询资料。\n对于文件组织形式一般包含四种：`Heap File Organization`、`Sequential File Organization`、`Multitable Clustering File Organization`、`Hashing File Organization`。\n\n### 数据缓存\n\n#### 内存与磁盘(Buffer Manager)\n\n在数据库中，其查询数据往往需要从磁盘调入内存中。对于数据库控制数据缓存的核心思想是最小化`IO`数据的传输，并且最小化使用的内存。\n在实际的数据库读写过程中，其中双层隔离性是由逻辑读写和物理读写协作完成实现的。在这个过程中，数据库操作对于内存中的内容经过逻辑读写，在内存到磁盘的途径上，通过物理读写完成。\n对于内存与磁盘之间的写入写出存在很多优化算法，其中甚至包含一下预测算法，类似于分支指令集中的分支预测？在这个过程中还有锁的存在，类似于`x`锁和`s`锁，但是细微差别在于其中分别是`shared lock`和`exclusive lock`。\n\n#### 行式存储\n\n对于数据库存储中常见的行式存储，其本身更多的针对于一些特殊情景。\n\n- 优点\n  - Reduced IO if only some attributes are accessed\n  - Improved CPU cache performance \n  - Improved compression\n  - Vector processing on modern CPU architectures\n- 缺点\n  - Cost of tuple reconstruction from columnar representation\n  - Cost of tuple deletion and update\n  - Cost of decompression\n\n**数据存储格式的选择：**\n\n- 列式存储更适合决策支持：对于需要进行大量读取、分析和聚合计算的决策支持系统（如数据仓库），列式存储通常比行式存储更高效。\n- 行式存储更适合事务处理：对于需要频繁执行插入、更新和删除操作的事务处理系统（如在线事务处理系统），行式存储可以提供更好的性能。\n\n当列式存储的数据库被存放在内存中时，相比于行式存储，列式存储可以用于内存中的决策支持应用 压缩减少了内存需求。\n\n### 分页存储\n\n我从主观上认为就和操作系统中的分页存储方式一致。\n\n#### openGauss 段页式存储管理\n\nopenGauss 数据库采用了高效的段页式存储管理策略，这种策略类似于操作系统中的分页系统，但专门优化以适应数据库的需求。在 openGauss 中，存储结构被细分为几个关键组成部分：\n\n1. **段（Segment）**：\n   - 数据库中的每个数据库对象（如表、索引）都存储在称为\"段\"的结构中。每个段可以看作是数据库对象的物理和逻辑集合，它包含了一个或多个区（Extent）。\n\n2. **区（Extent）**：\n   - 一个区是由连续的页（Page）组成的，是段中的一个逻辑分区。每个区包含固定数量的页，这些页连续存储在磁盘上，从而减少数据访问时的磁盘寻址时间。\n\n3. **页（Page）**：\n   - 页是 openGauss 数据存储的基本单位，类似于操作系统中的内存页。每个页的大小固定，通常为 8KB。页内存储具体的数据行或索引条目，设计成固定大小有利于快速定位和数据一致性保证。\n\n##### 存储管理特点\n\n- **高效的空间利用**：通过将数据细分为段和区，openGauss 能够有效管理磁盘空间，减少碎片，提高数据存取效率。\n- **数据局部性优化**：相关数据存储在相邻的页中，提升查询效率，尤其是对于表扫描和范围查询。\n- **动态空间管理**：openGauss 能够动态分配和回收段和区的空间，根据数据库负载和数据增长自动调整，提供灵活的存储管理。\n- **事务和恢复**：每个页都包含有关其修改的信息，这些信息在事务处理和数据恢复中至关重要，确保了数据的一致性和可靠性。\n\n##### Oracle数据库中的7种数据库表类型\n\nOracle 数据库支持多种类型的表，每种表的组织方式对于不同的应用场景提供了特定的优势和功能。以下是这些表类型的详细介绍：\n\n1. 堆表（Heap-Organized Table）\n  堆表是 Oracle 和 openGauss 中的默认表类型。在这种类型的表中，数据在写入时无需考虑行存放的顺序，通常是按照写入时间的先后顺序存放。这样的存储方式使得写入速度较 \n  高，但由于数据是无序存放的，其读取效率相对较低。\n\n2. 索引组织表（Index-Organized Table, IOT）\n  索引组织表以索引的方式保存表数据，数据根据主键的顺序进行存储排列，这种方式显著提高了数据的访问速度。然而，这种类型的表的索引块需要保存所有字段的信息，因此需要更多 \n  的叶子页面来保存数据，可能在数据量较大时导致访问效率降低。如果主键频繁修改，对应的行也需要在不同的块之间移动，这会增加磁盘I/O和维护成本。\n\n3. 簇表（Cluster Table）\n  簇表（Cluster）允许根据连接键（Join Key）将多个数据表的数据保存在同一个数据库段中。这样做可以在某些场景下实现快速检索和连接。然而，在 openGauss 中，无法兼容 \n  此功能。\n\n4. 临时表（Temporary Table）\n  临时表是一种特殊类型的表，用于临时保存数据。这些表的数据只存储在临时表空间中，而非用户表空间，且对临时表的DML操作通常不记录事务日志。Oracle 临时表分为事务级临时 \n  表和会话级临时表，前者的数据只保存在事务的生命周期中，后者能支持会话的完整生命周期。\n\n5. 压缩表（Compressed Table）\n  通过对表数据进行压缩，可以节省存储空间，但压缩和解压缩过程需要消耗一定的CPU资源。Oracle 提供了基础压缩和OLTP压缩两种常用的压缩方式。\n\n6. 分区表（Partitioned Table）\n  分区表将大表按照规则分解成多张具有独立存储空间的实体表，面向应用是一张表，但物理上由多个分区组成。每个分区都是一个独立对象，可以单独处理，也可以作为更大对象的一部 \n   分。分区类型包括范围分区、列表分区、哈希分区和复合分区。\n  \n  - **范围分区**：根据数据表的某个值范围进行分区。\n  - **列表分区**：根据所有可能的值，指定应该插入哪个分区。\n\n7. 嵌套表（Nested Table）\n  嵌套表允许将一张表作为另一张表的列存储，这对于存储复杂数据类型和支持对象关系特性尤为有用。\n\n","source":"_posts/数据库-8.md","raw":"---\ntitle: 数据库(8)\ndate: 2024-12-27 15:45:59\ntags:\n    - 学习笔记\n    - 数据库\n---\n\n## 文件组织形式\n\n### 文件逻辑/物理组织\n\n1. 逻辑结构\n   - 流式文件\n   - 基于记录文件\n   - 基于索引的文件\n2. 物理组织/结构\n   - 以`block`为单位，存储在`secondary storage`例如磁盘、SSD中\n   - 特征：contiguous(连续), linked(链接), indexed(索引)\n\nDB 存储为 DB 文件的集合(包括 SQL Server， 主文件，辅文件，日志文件)。其中，每个文件都是一个记录序列，每条记录都位于一系列字段中。一种方法DB存储方法中：记录大小是固定的，每个文件仅包含一种特定类型的记录，不同的文件用于不同的关系。\n\n每个文件都是一系列的记录，每一个关系表都是一组元组。DB的逻辑文件以元组为单位，而物理文件以记录为文件。\n\n存在几种常见的文件存储方式，此处不做过多描述。\n\n对于文件删除后的处理方式一般包含三种，具体可以查询资料。\n对于文件组织形式一般包含四种：`Heap File Organization`、`Sequential File Organization`、`Multitable Clustering File Organization`、`Hashing File Organization`。\n\n### 数据缓存\n\n#### 内存与磁盘(Buffer Manager)\n\n在数据库中，其查询数据往往需要从磁盘调入内存中。对于数据库控制数据缓存的核心思想是最小化`IO`数据的传输，并且最小化使用的内存。\n在实际的数据库读写过程中，其中双层隔离性是由逻辑读写和物理读写协作完成实现的。在这个过程中，数据库操作对于内存中的内容经过逻辑读写，在内存到磁盘的途径上，通过物理读写完成。\n对于内存与磁盘之间的写入写出存在很多优化算法，其中甚至包含一下预测算法，类似于分支指令集中的分支预测？在这个过程中还有锁的存在，类似于`x`锁和`s`锁，但是细微差别在于其中分别是`shared lock`和`exclusive lock`。\n\n#### 行式存储\n\n对于数据库存储中常见的行式存储，其本身更多的针对于一些特殊情景。\n\n- 优点\n  - Reduced IO if only some attributes are accessed\n  - Improved CPU cache performance \n  - Improved compression\n  - Vector processing on modern CPU architectures\n- 缺点\n  - Cost of tuple reconstruction from columnar representation\n  - Cost of tuple deletion and update\n  - Cost of decompression\n\n**数据存储格式的选择：**\n\n- 列式存储更适合决策支持：对于需要进行大量读取、分析和聚合计算的决策支持系统（如数据仓库），列式存储通常比行式存储更高效。\n- 行式存储更适合事务处理：对于需要频繁执行插入、更新和删除操作的事务处理系统（如在线事务处理系统），行式存储可以提供更好的性能。\n\n当列式存储的数据库被存放在内存中时，相比于行式存储，列式存储可以用于内存中的决策支持应用 压缩减少了内存需求。\n\n### 分页存储\n\n我从主观上认为就和操作系统中的分页存储方式一致。\n\n#### openGauss 段页式存储管理\n\nopenGauss 数据库采用了高效的段页式存储管理策略，这种策略类似于操作系统中的分页系统，但专门优化以适应数据库的需求。在 openGauss 中，存储结构被细分为几个关键组成部分：\n\n1. **段（Segment）**：\n   - 数据库中的每个数据库对象（如表、索引）都存储在称为\"段\"的结构中。每个段可以看作是数据库对象的物理和逻辑集合，它包含了一个或多个区（Extent）。\n\n2. **区（Extent）**：\n   - 一个区是由连续的页（Page）组成的，是段中的一个逻辑分区。每个区包含固定数量的页，这些页连续存储在磁盘上，从而减少数据访问时的磁盘寻址时间。\n\n3. **页（Page）**：\n   - 页是 openGauss 数据存储的基本单位，类似于操作系统中的内存页。每个页的大小固定，通常为 8KB。页内存储具体的数据行或索引条目，设计成固定大小有利于快速定位和数据一致性保证。\n\n##### 存储管理特点\n\n- **高效的空间利用**：通过将数据细分为段和区，openGauss 能够有效管理磁盘空间，减少碎片，提高数据存取效率。\n- **数据局部性优化**：相关数据存储在相邻的页中，提升查询效率，尤其是对于表扫描和范围查询。\n- **动态空间管理**：openGauss 能够动态分配和回收段和区的空间，根据数据库负载和数据增长自动调整，提供灵活的存储管理。\n- **事务和恢复**：每个页都包含有关其修改的信息，这些信息在事务处理和数据恢复中至关重要，确保了数据的一致性和可靠性。\n\n##### Oracle数据库中的7种数据库表类型\n\nOracle 数据库支持多种类型的表，每种表的组织方式对于不同的应用场景提供了特定的优势和功能。以下是这些表类型的详细介绍：\n\n1. 堆表（Heap-Organized Table）\n  堆表是 Oracle 和 openGauss 中的默认表类型。在这种类型的表中，数据在写入时无需考虑行存放的顺序，通常是按照写入时间的先后顺序存放。这样的存储方式使得写入速度较 \n  高，但由于数据是无序存放的，其读取效率相对较低。\n\n2. 索引组织表（Index-Organized Table, IOT）\n  索引组织表以索引的方式保存表数据，数据根据主键的顺序进行存储排列，这种方式显著提高了数据的访问速度。然而，这种类型的表的索引块需要保存所有字段的信息，因此需要更多 \n  的叶子页面来保存数据，可能在数据量较大时导致访问效率降低。如果主键频繁修改，对应的行也需要在不同的块之间移动，这会增加磁盘I/O和维护成本。\n\n3. 簇表（Cluster Table）\n  簇表（Cluster）允许根据连接键（Join Key）将多个数据表的数据保存在同一个数据库段中。这样做可以在某些场景下实现快速检索和连接。然而，在 openGauss 中，无法兼容 \n  此功能。\n\n4. 临时表（Temporary Table）\n  临时表是一种特殊类型的表，用于临时保存数据。这些表的数据只存储在临时表空间中，而非用户表空间，且对临时表的DML操作通常不记录事务日志。Oracle 临时表分为事务级临时 \n  表和会话级临时表，前者的数据只保存在事务的生命周期中，后者能支持会话的完整生命周期。\n\n5. 压缩表（Compressed Table）\n  通过对表数据进行压缩，可以节省存储空间，但压缩和解压缩过程需要消耗一定的CPU资源。Oracle 提供了基础压缩和OLTP压缩两种常用的压缩方式。\n\n6. 分区表（Partitioned Table）\n  分区表将大表按照规则分解成多张具有独立存储空间的实体表，面向应用是一张表，但物理上由多个分区组成。每个分区都是一个独立对象，可以单独处理，也可以作为更大对象的一部 \n   分。分区类型包括范围分区、列表分区、哈希分区和复合分区。\n  \n  - **范围分区**：根据数据表的某个值范围进行分区。\n  - **列表分区**：根据所有可能的值，指定应该插入哪个分区。\n\n7. 嵌套表（Nested Table）\n  嵌套表允许将一张表作为另一张表的列存储，这对于存储复杂数据类型和支持对象关系特性尤为有用。\n\n","slug":"数据库-8","published":1,"updated":"2024-12-28T05:32:49.686Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot8000j6d6eckkebcvz","content":"<h2 id=\"文件组织形式\"><a href=\"#文件组织形式\" class=\"headerlink\" title=\"文件组织形式\"></a>文件组织形式</h2><h3 id=\"文件逻辑-物理组织\"><a href=\"#文件逻辑-物理组织\" class=\"headerlink\" title=\"文件逻辑&#x2F;物理组织\"></a>文件逻辑&#x2F;物理组织</h3><ol>\n<li>逻辑结构<ul>\n<li>流式文件</li>\n<li>基于记录文件</li>\n<li>基于索引的文件</li>\n</ul>\n</li>\n<li>物理组织&#x2F;结构<ul>\n<li>以<code>block</code>为单位，存储在<code>secondary storage</code>例如磁盘、SSD中</li>\n<li>特征：contiguous(连续), linked(链接), indexed(索引)</li>\n</ul>\n</li>\n</ol>\n<p>DB 存储为 DB 文件的集合(包括 SQL Server， 主文件，辅文件，日志文件)。其中，每个文件都是一个记录序列，每条记录都位于一系列字段中。一种方法DB存储方法中：记录大小是固定的，每个文件仅包含一种特定类型的记录，不同的文件用于不同的关系。</p>\n<p>每个文件都是一系列的记录，每一个关系表都是一组元组。DB的逻辑文件以元组为单位，而物理文件以记录为文件。</p>\n<p>存在几种常见的文件存储方式，此处不做过多描述。</p>\n<p>对于文件删除后的处理方式一般包含三种，具体可以查询资料。<br>对于文件组织形式一般包含四种：<code>Heap File Organization</code>、<code>Sequential File Organization</code>、<code>Multitable Clustering File Organization</code>、<code>Hashing File Organization</code>。</p>\n<h3 id=\"数据缓存\"><a href=\"#数据缓存\" class=\"headerlink\" title=\"数据缓存\"></a>数据缓存</h3><h4 id=\"内存与磁盘-Buffer-Manager\"><a href=\"#内存与磁盘-Buffer-Manager\" class=\"headerlink\" title=\"内存与磁盘(Buffer Manager)\"></a>内存与磁盘(Buffer Manager)</h4><p>在数据库中，其查询数据往往需要从磁盘调入内存中。对于数据库控制数据缓存的核心思想是最小化<code>IO</code>数据的传输，并且最小化使用的内存。<br>在实际的数据库读写过程中，其中双层隔离性是由逻辑读写和物理读写协作完成实现的。在这个过程中，数据库操作对于内存中的内容经过逻辑读写，在内存到磁盘的途径上，通过物理读写完成。<br>对于内存与磁盘之间的写入写出存在很多优化算法，其中甚至包含一下预测算法，类似于分支指令集中的分支预测？在这个过程中还有锁的存在，类似于<code>x</code>锁和<code>s</code>锁，但是细微差别在于其中分别是<code>shared lock</code>和<code>exclusive lock</code>。</p>\n<h4 id=\"行式存储\"><a href=\"#行式存储\" class=\"headerlink\" title=\"行式存储\"></a>行式存储</h4><p>对于数据库存储中常见的行式存储，其本身更多的针对于一些特殊情景。</p>\n<ul>\n<li>优点<ul>\n<li>Reduced IO if only some attributes are accessed</li>\n<li>Improved CPU cache performance </li>\n<li>Improved compression</li>\n<li>Vector processing on modern CPU architectures</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>Cost of tuple reconstruction from columnar representation</li>\n<li>Cost of tuple deletion and update</li>\n<li>Cost of decompression</li>\n</ul>\n</li>\n</ul>\n<p><strong>数据存储格式的选择：</strong></p>\n<ul>\n<li>列式存储更适合决策支持：对于需要进行大量读取、分析和聚合计算的决策支持系统（如数据仓库），列式存储通常比行式存储更高效。</li>\n<li>行式存储更适合事务处理：对于需要频繁执行插入、更新和删除操作的事务处理系统（如在线事务处理系统），行式存储可以提供更好的性能。</li>\n</ul>\n<p>当列式存储的数据库被存放在内存中时，相比于行式存储，列式存储可以用于内存中的决策支持应用 压缩减少了内存需求。</p>\n<h3 id=\"分页存储\"><a href=\"#分页存储\" class=\"headerlink\" title=\"分页存储\"></a>分页存储</h3><p>我从主观上认为就和操作系统中的分页存储方式一致。</p>\n<h4 id=\"openGauss-段页式存储管理\"><a href=\"#openGauss-段页式存储管理\" class=\"headerlink\" title=\"openGauss 段页式存储管理\"></a>openGauss 段页式存储管理</h4><p>openGauss 数据库采用了高效的段页式存储管理策略，这种策略类似于操作系统中的分页系统，但专门优化以适应数据库的需求。在 openGauss 中，存储结构被细分为几个关键组成部分：</p>\n<ol>\n<li><p><strong>段（Segment）</strong>：</p>\n<ul>\n<li>数据库中的每个数据库对象（如表、索引）都存储在称为”段”的结构中。每个段可以看作是数据库对象的物理和逻辑集合，它包含了一个或多个区（Extent）。</li>\n</ul>\n</li>\n<li><p><strong>区（Extent）</strong>：</p>\n<ul>\n<li>一个区是由连续的页（Page）组成的，是段中的一个逻辑分区。每个区包含固定数量的页，这些页连续存储在磁盘上，从而减少数据访问时的磁盘寻址时间。</li>\n</ul>\n</li>\n<li><p><strong>页（Page）</strong>：</p>\n<ul>\n<li>页是 openGauss 数据存储的基本单位，类似于操作系统中的内存页。每个页的大小固定，通常为 8KB。页内存储具体的数据行或索引条目，设计成固定大小有利于快速定位和数据一致性保证。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"存储管理特点\"><a href=\"#存储管理特点\" class=\"headerlink\" title=\"存储管理特点\"></a>存储管理特点</h5><ul>\n<li><strong>高效的空间利用</strong>：通过将数据细分为段和区，openGauss 能够有效管理磁盘空间，减少碎片，提高数据存取效率。</li>\n<li><strong>数据局部性优化</strong>：相关数据存储在相邻的页中，提升查询效率，尤其是对于表扫描和范围查询。</li>\n<li><strong>动态空间管理</strong>：openGauss 能够动态分配和回收段和区的空间，根据数据库负载和数据增长自动调整，提供灵活的存储管理。</li>\n<li><strong>事务和恢复</strong>：每个页都包含有关其修改的信息，这些信息在事务处理和数据恢复中至关重要，确保了数据的一致性和可靠性。</li>\n</ul>\n<h5 id=\"Oracle数据库中的7种数据库表类型\"><a href=\"#Oracle数据库中的7种数据库表类型\" class=\"headerlink\" title=\"Oracle数据库中的7种数据库表类型\"></a>Oracle数据库中的7种数据库表类型</h5><p>Oracle 数据库支持多种类型的表，每种表的组织方式对于不同的应用场景提供了特定的优势和功能。以下是这些表类型的详细介绍：</p>\n<ol>\n<li><p>堆表（Heap-Organized Table）<br>  堆表是 Oracle 和 openGauss 中的默认表类型。在这种类型的表中，数据在写入时无需考虑行存放的顺序，通常是按照写入时间的先后顺序存放。这样的存储方式使得写入速度较<br>  高，但由于数据是无序存放的，其读取效率相对较低。</p>\n</li>\n<li><p>索引组织表（Index-Organized Table, IOT）<br>  索引组织表以索引的方式保存表数据，数据根据主键的顺序进行存储排列，这种方式显著提高了数据的访问速度。然而，这种类型的表的索引块需要保存所有字段的信息，因此需要更多<br>  的叶子页面来保存数据，可能在数据量较大时导致访问效率降低。如果主键频繁修改，对应的行也需要在不同的块之间移动，这会增加磁盘I&#x2F;O和维护成本。</p>\n</li>\n<li><p>簇表（Cluster Table）<br>  簇表（Cluster）允许根据连接键（Join Key）将多个数据表的数据保存在同一个数据库段中。这样做可以在某些场景下实现快速检索和连接。然而，在 openGauss 中，无法兼容<br>  此功能。</p>\n</li>\n<li><p>临时表（Temporary Table）<br>  临时表是一种特殊类型的表，用于临时保存数据。这些表的数据只存储在临时表空间中，而非用户表空间，且对临时表的DML操作通常不记录事务日志。Oracle 临时表分为事务级临时<br>  表和会话级临时表，前者的数据只保存在事务的生命周期中，后者能支持会话的完整生命周期。</p>\n</li>\n<li><p>压缩表（Compressed Table）<br>  通过对表数据进行压缩，可以节省存储空间，但压缩和解压缩过程需要消耗一定的CPU资源。Oracle 提供了基础压缩和OLTP压缩两种常用的压缩方式。</p>\n</li>\n<li><p>分区表（Partitioned Table）<br>  分区表将大表按照规则分解成多张具有独立存储空间的实体表，面向应用是一张表，但物理上由多个分区组成。每个分区都是一个独立对象，可以单独处理，也可以作为更大对象的一部<br>分。分区类型包括范围分区、列表分区、哈希分区和复合分区。</p>\n</li>\n</ol>\n<ul>\n<li><strong>范围分区</strong>：根据数据表的某个值范围进行分区。</li>\n<li><strong>列表分区</strong>：根据所有可能的值，指定应该插入哪个分区。</li>\n</ul>\n<ol start=\"7\">\n<li>嵌套表（Nested Table）<br>  嵌套表允许将一张表作为另一张表的列存储，这对于存储复杂数据类型和支持对象关系特性尤为有用。</li>\n</ol>\n","excerpt":"","more":"<h2 id=\"文件组织形式\"><a href=\"#文件组织形式\" class=\"headerlink\" title=\"文件组织形式\"></a>文件组织形式</h2><h3 id=\"文件逻辑-物理组织\"><a href=\"#文件逻辑-物理组织\" class=\"headerlink\" title=\"文件逻辑&#x2F;物理组织\"></a>文件逻辑&#x2F;物理组织</h3><ol>\n<li>逻辑结构<ul>\n<li>流式文件</li>\n<li>基于记录文件</li>\n<li>基于索引的文件</li>\n</ul>\n</li>\n<li>物理组织&#x2F;结构<ul>\n<li>以<code>block</code>为单位，存储在<code>secondary storage</code>例如磁盘、SSD中</li>\n<li>特征：contiguous(连续), linked(链接), indexed(索引)</li>\n</ul>\n</li>\n</ol>\n<p>DB 存储为 DB 文件的集合(包括 SQL Server， 主文件，辅文件，日志文件)。其中，每个文件都是一个记录序列，每条记录都位于一系列字段中。一种方法DB存储方法中：记录大小是固定的，每个文件仅包含一种特定类型的记录，不同的文件用于不同的关系。</p>\n<p>每个文件都是一系列的记录，每一个关系表都是一组元组。DB的逻辑文件以元组为单位，而物理文件以记录为文件。</p>\n<p>存在几种常见的文件存储方式，此处不做过多描述。</p>\n<p>对于文件删除后的处理方式一般包含三种，具体可以查询资料。<br>对于文件组织形式一般包含四种：<code>Heap File Organization</code>、<code>Sequential File Organization</code>、<code>Multitable Clustering File Organization</code>、<code>Hashing File Organization</code>。</p>\n<h3 id=\"数据缓存\"><a href=\"#数据缓存\" class=\"headerlink\" title=\"数据缓存\"></a>数据缓存</h3><h4 id=\"内存与磁盘-Buffer-Manager\"><a href=\"#内存与磁盘-Buffer-Manager\" class=\"headerlink\" title=\"内存与磁盘(Buffer Manager)\"></a>内存与磁盘(Buffer Manager)</h4><p>在数据库中，其查询数据往往需要从磁盘调入内存中。对于数据库控制数据缓存的核心思想是最小化<code>IO</code>数据的传输，并且最小化使用的内存。<br>在实际的数据库读写过程中，其中双层隔离性是由逻辑读写和物理读写协作完成实现的。在这个过程中，数据库操作对于内存中的内容经过逻辑读写，在内存到磁盘的途径上，通过物理读写完成。<br>对于内存与磁盘之间的写入写出存在很多优化算法，其中甚至包含一下预测算法，类似于分支指令集中的分支预测？在这个过程中还有锁的存在，类似于<code>x</code>锁和<code>s</code>锁，但是细微差别在于其中分别是<code>shared lock</code>和<code>exclusive lock</code>。</p>\n<h4 id=\"行式存储\"><a href=\"#行式存储\" class=\"headerlink\" title=\"行式存储\"></a>行式存储</h4><p>对于数据库存储中常见的行式存储，其本身更多的针对于一些特殊情景。</p>\n<ul>\n<li>优点<ul>\n<li>Reduced IO if only some attributes are accessed</li>\n<li>Improved CPU cache performance </li>\n<li>Improved compression</li>\n<li>Vector processing on modern CPU architectures</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>Cost of tuple reconstruction from columnar representation</li>\n<li>Cost of tuple deletion and update</li>\n<li>Cost of decompression</li>\n</ul>\n</li>\n</ul>\n<p><strong>数据存储格式的选择：</strong></p>\n<ul>\n<li>列式存储更适合决策支持：对于需要进行大量读取、分析和聚合计算的决策支持系统（如数据仓库），列式存储通常比行式存储更高效。</li>\n<li>行式存储更适合事务处理：对于需要频繁执行插入、更新和删除操作的事务处理系统（如在线事务处理系统），行式存储可以提供更好的性能。</li>\n</ul>\n<p>当列式存储的数据库被存放在内存中时，相比于行式存储，列式存储可以用于内存中的决策支持应用 压缩减少了内存需求。</p>\n<h3 id=\"分页存储\"><a href=\"#分页存储\" class=\"headerlink\" title=\"分页存储\"></a>分页存储</h3><p>我从主观上认为就和操作系统中的分页存储方式一致。</p>\n<h4 id=\"openGauss-段页式存储管理\"><a href=\"#openGauss-段页式存储管理\" class=\"headerlink\" title=\"openGauss 段页式存储管理\"></a>openGauss 段页式存储管理</h4><p>openGauss 数据库采用了高效的段页式存储管理策略，这种策略类似于操作系统中的分页系统，但专门优化以适应数据库的需求。在 openGauss 中，存储结构被细分为几个关键组成部分：</p>\n<ol>\n<li><p><strong>段（Segment）</strong>：</p>\n<ul>\n<li>数据库中的每个数据库对象（如表、索引）都存储在称为”段”的结构中。每个段可以看作是数据库对象的物理和逻辑集合，它包含了一个或多个区（Extent）。</li>\n</ul>\n</li>\n<li><p><strong>区（Extent）</strong>：</p>\n<ul>\n<li>一个区是由连续的页（Page）组成的，是段中的一个逻辑分区。每个区包含固定数量的页，这些页连续存储在磁盘上，从而减少数据访问时的磁盘寻址时间。</li>\n</ul>\n</li>\n<li><p><strong>页（Page）</strong>：</p>\n<ul>\n<li>页是 openGauss 数据存储的基本单位，类似于操作系统中的内存页。每个页的大小固定，通常为 8KB。页内存储具体的数据行或索引条目，设计成固定大小有利于快速定位和数据一致性保证。</li>\n</ul>\n</li>\n</ol>\n<h5 id=\"存储管理特点\"><a href=\"#存储管理特点\" class=\"headerlink\" title=\"存储管理特点\"></a>存储管理特点</h5><ul>\n<li><strong>高效的空间利用</strong>：通过将数据细分为段和区，openGauss 能够有效管理磁盘空间，减少碎片，提高数据存取效率。</li>\n<li><strong>数据局部性优化</strong>：相关数据存储在相邻的页中，提升查询效率，尤其是对于表扫描和范围查询。</li>\n<li><strong>动态空间管理</strong>：openGauss 能够动态分配和回收段和区的空间，根据数据库负载和数据增长自动调整，提供灵活的存储管理。</li>\n<li><strong>事务和恢复</strong>：每个页都包含有关其修改的信息，这些信息在事务处理和数据恢复中至关重要，确保了数据的一致性和可靠性。</li>\n</ul>\n<h5 id=\"Oracle数据库中的7种数据库表类型\"><a href=\"#Oracle数据库中的7种数据库表类型\" class=\"headerlink\" title=\"Oracle数据库中的7种数据库表类型\"></a>Oracle数据库中的7种数据库表类型</h5><p>Oracle 数据库支持多种类型的表，每种表的组织方式对于不同的应用场景提供了特定的优势和功能。以下是这些表类型的详细介绍：</p>\n<ol>\n<li><p>堆表（Heap-Organized Table）<br>  堆表是 Oracle 和 openGauss 中的默认表类型。在这种类型的表中，数据在写入时无需考虑行存放的顺序，通常是按照写入时间的先后顺序存放。这样的存储方式使得写入速度较<br>  高，但由于数据是无序存放的，其读取效率相对较低。</p>\n</li>\n<li><p>索引组织表（Index-Organized Table, IOT）<br>  索引组织表以索引的方式保存表数据，数据根据主键的顺序进行存储排列，这种方式显著提高了数据的访问速度。然而，这种类型的表的索引块需要保存所有字段的信息，因此需要更多<br>  的叶子页面来保存数据，可能在数据量较大时导致访问效率降低。如果主键频繁修改，对应的行也需要在不同的块之间移动，这会增加磁盘I&#x2F;O和维护成本。</p>\n</li>\n<li><p>簇表（Cluster Table）<br>  簇表（Cluster）允许根据连接键（Join Key）将多个数据表的数据保存在同一个数据库段中。这样做可以在某些场景下实现快速检索和连接。然而，在 openGauss 中，无法兼容<br>  此功能。</p>\n</li>\n<li><p>临时表（Temporary Table）<br>  临时表是一种特殊类型的表，用于临时保存数据。这些表的数据只存储在临时表空间中，而非用户表空间，且对临时表的DML操作通常不记录事务日志。Oracle 临时表分为事务级临时<br>  表和会话级临时表，前者的数据只保存在事务的生命周期中，后者能支持会话的完整生命周期。</p>\n</li>\n<li><p>压缩表（Compressed Table）<br>  通过对表数据进行压缩，可以节省存储空间，但压缩和解压缩过程需要消耗一定的CPU资源。Oracle 提供了基础压缩和OLTP压缩两种常用的压缩方式。</p>\n</li>\n<li><p>分区表（Partitioned Table）<br>  分区表将大表按照规则分解成多张具有独立存储空间的实体表，面向应用是一张表，但物理上由多个分区组成。每个分区都是一个独立对象，可以单独处理，也可以作为更大对象的一部<br>分。分区类型包括范围分区、列表分区、哈希分区和复合分区。</p>\n</li>\n</ol>\n<ul>\n<li><strong>范围分区</strong>：根据数据表的某个值范围进行分区。</li>\n<li><strong>列表分区</strong>：根据所有可能的值，指定应该插入哪个分区。</li>\n</ul>\n<ol start=\"7\">\n<li>嵌套表（Nested Table）<br>  嵌套表允许将一张表作为另一张表的列存储，这对于存储复杂数据类型和支持对象关系特性尤为有用。</li>\n</ol>\n"},{"title":"软件工程(1)","date":"2024-10-23T10:02:31.000Z","_content":"# 软件生命周期模型\n软件生命周期模型是一个框架，描述从软件需求定义直至软件经使用后废弃位置，跨越整个生存期的软件开发、运行和维护所实施的全部过程、活动和任务，同时描述生命周期不同阶段产生的软件工件，明确活动的执行角色等。\n![软件生命周期](/img/软件工程(1)/软件生命周期.png)\n## 软件过程\n在整个软件生命周期的系统**开发、运行和维护**过程红锁实施的全部过程、活动和任务的结构框架。通常用**软件过程模型**来描述软件过程。\n## 软件过程模型\n如下是几种传统的模型种类：\n1. **瀑布模型**\n   - **特点**：瀑布模型按照严格的阶段顺序执行，每个阶段（需求分析、设计、编码、测试、维护）必须完成后才能进入下一阶段，后续阶段不能回溯。\n   - **适用场景**：适用于需求明确且固定、开发流程清晰、变更较少的项目，如银行、政府系统等具有较高安全性和稳定性要求的项目。\n\n2. **演化模型**\n   - **特点**：该模型通过反复的迭代和反馈逐步完善软件，每次迭代后根据反馈改进设计和实现。\n   - **适用场景**：适合需求不完全明确、需要频繁变更或改进的软件项目，如科研项目和快速变化的市场环境中的产品。\n\n3. **增量模型**\n   - **特点**：将整个系统的开发划分为多个增量，每个增量实现部分功能，最终通过多个增量的叠加构建完整系统。\n   - **适用场景**：适用于需要快速交付部分功能的软件项目，如大型软件系统、复杂的企业应用，或需求不可能一次性完成的项目。\n\n4. **喷泉模型**\n   - **特点**：喷泉模型强调各个开发活动之间可以重叠进行，特别适合面向对象的开发。开发流程是连续的、迭代的，没有严格的阶段划分。\n   - **适用场景**：多用于面向对象的开发项目，如使用面向对象语言（如Java或C++）开发的系统。\n\n5. **V模型和W模型**\n   - **特点**：V模型是瀑布模型的扩展，在开发阶段的每一步后都有相应的验证与确认活动；W模型进一步加强了测试的频率与覆盖范围。\n   - **适用场景**：适用于对软件质量和测试要求高的项目，如医疗系统、航空软件等对测试和验证要求严格的场景。\n\n6. **螺旋模型**\n   - **特点**：螺旋模型结合了瀑布模型和迭代开发的优势，重点是风险管理，每次迭代都包括风险分析，并根据风险调整项目计划。\n   - **适用场景**：适用于大型复杂项目或具有高风险因素的项目，如航天、国防系统开发。\n\n7. **构件组装模型**\n   - **特点**：通过复用现有的构件或模块，减少开发时间和成本，强调模块化设计和组装。\n   - **适用场景**：适用于大型软件项目，特别是那些可以通过构件化的方式进行开发的系统，如企业级应用、ERP系统。\n\n8. **快速应用开发模型**\n   - **特点**：通过快速原型和频繁的用户反馈，缩短开发周期，快速交付功能齐全的产品版本。\n   - **适用场景**：适用于对开发速度要求高且用户反馈至关重要的项目，如互联网应用、手机App开发。\n\n9. **原型方法**\n   - **特点**：先构建软件的初步原型，经过用户的评估和反馈，反复改进，直到最终产品满足需求。\n   - **适用场景**：适合需求不明确或不完整的项目，或需要通过用户反馈不断优化的项目，如产品原型设计、用户界面开发等。\n\n其中主要介绍瀑布模型、UP模型、喷泉模型和演化模型等\n#### 瀑布模型\n瀑布模型为软件开发和软件维护提供了一种有效的管理模式，它在软件开发早起为消除非结构化软件、降低软件复杂度、促进软件开发工程化起着显著作用。\n其在不同开发阶段有不同的特征：\n1. **需求分析阶段**：\n   - **特征**：通过与客户沟通和分析业务需求，确定软件的功能需求和非功能需求，并形成详细的需求文档（Software Requirements Specification, SRS）。\n   - **输出**：需求规格说明书（SRS），包含系统功能、性能、安全性等要求。\n\n2. **系统设计阶段**：\n   - **特征**：基于需求规格说明书进行系统架构设计，确定系统的模块划分、数据结构、接口设计等。分为概要设计（高层设计）和详细设计（低层设计）。\n   - **输出**：系统设计文档，包含软件架构图、模块设计、数据库设计等内容。\n\n3. **编码实现阶段**：\n   - **特征**：根据系统设计文档，开发人员编写代码，完成各个模块的实现。代码需要遵循设计规范，并保证实现符合需求。\n   - **输出**：源代码、可执行程序、代码注释和开发文档。\n\n4. **测试阶段**：\n   - **特征**：对编码后的软件进行测试，包括单元测试、集成测试、系统测试和验收测试，确保软件功能的正确性和性能的稳定性。测试通常依据需求规格说明书进行，验证是否满足所有要求。\n   - **输出**：测试报告，包含测试用例、测试结果、缺陷报告等。\n\n5. **部署与维护阶段**：\n   - **特征**：将软件交付客户使用，并进行系统的安装和配置。维护包括修复错误、处理用户反馈、性能优化和系统升级。维护阶段可能需要多次修订和更新。\n   - **输出**：用户手册、维护文档、补丁程序、更新版本。\n\n其中共有的特征为:\n- 本阶段的工作对象来自上一阶段活动的输出，这些输出一般是代表上一阶段活动结束的里程碑式的文档\n- 根据本阶段的活动规程执行相应的任务\n- 产生本阶段活动相关产出，并将其作为下一阶段活动的输入\n  \n#### 演化模型\n使用瀑布模型人们认识到，由于需求很难调研充分，所以很难一次性开发成功\n演化模型提倡两次开发：\n  - 第一次是试验开发，得到试验性的原型产品，其目标只是在于探索可行性，弄清软件需求\n  - 第二次在此基础上获得较为满意的软件产品\n  ![演化模型](/img/软件工程(1)/演化模型.png)\n  演化模型一般适用于：\n  - 需求不清楚\n  - 小型或中小型系统\n  - 开发周期短\n\n#### 增量模型\n首先对最核心或最清晰的需求进行分析、设计、实现、测试并集成到系统中。再按照优先级逐步对后续的需求进行上述工作，逐步建成一个完整的开发方法。其**结合了瀑布模型和演化模型的优点**。 \n![增量模型](/img/软件工程(1)/演化模型.png)\n\n#### 喷泉模型\n- 喷泉模型也称迭代模型，认为软件开发过程的各个阶段是相互重叠，反复多次的。\n- 各个开发阶段没有特定的次序要求，完全可以并行进行，可以在某个开发阶段中随时补充其他任何开发阶段中遗漏的需求\n\n\n#### V模型和W模型\n相对于瀑布模型，V模型将测试活动提前，提高了其驾驭风险的能力，而W模型进一步加强了测试的频率与覆盖范围。\n![V模型和W模型](/img/软件工程(1)/V模型和W模型.png)\n\n#### 螺旋模型\n螺旋模型主要针对大型软件项目的开发周期长、风险高的特点\n![螺旋模型](/img/软件工程(1)/螺旋模型.png)\n螺旋模型本身含有四个象限内容：\n  - 制定计划：确定软件项目目标；明确对软件开发过程和软件产品的约束；制定详细的项目管理计划；根据当前的需求和风险因素，制定实施方案，并进行可行性分析，选定一个实施方案，并对其进行规划。\n  - 风险分析：明确每一个项目风险，估计风险发生的可能性、频率、损害程度，并制定风险管理措施，规避这些风险。\n  - 实施工程：针对每一个开发阶段的任务要求参照某一种生命周期模型执行本开发阶段的活动\n  - 客户评价：客户使用原型，反馈修改意见；根据客户的反馈，对产品及其周边开发过程进行评审，决定是否具备到下一个开发阶段的能力。\n\n#### 构件组装模型\n利用模块化思想将整个系统模块化，并在一定构建模型的支持下复用构件库中软件构件，通过组装高效率、高质量地构造软件系统。构建组装模型的本质上是演化的，开发过程是迭代的。\n构建组装模型的开发过程就是构建组装的的过程，维护党的过程就是构件升级、替换和扩充的过程。\n![构件组装模型](/img/软件工程(1)/构件组装模型.png)\n\n#### 快速应用开发模型（RAD）\nRAD是一个增量型的软件开发模型，强调极短的开发周期\n![快速应用开发模型](/img/软件工程(1)/快速应用开发模型.png)\n\n\n\n\n\n\n| 软件生命周期模型 | 优点                                                                                                                                                                                                                                                                                                                                                                 | 缺点                                                                                                                                                                                                                                      |\n| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 瀑布模型         | 降低了软件开发的复杂程度，提高了软件开发过程的透明性及软件开发过程的可管理性 ； <br>推迟了软件实现，强调在软件实现前必须进行分析和设计工作；<br>以项目的阶段评审和文档控制为手段，有效地对整个开发过程进行指导，保证了阶段之间的正确衔接； <br>能够及时发现并纠正开发过程中存在的缺陷，从而使产品达到预期的质量要求；                                                | 模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题； <br>模型的风险控制能力较弱； <br>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加工作量； <br>管理人员可能根据文档评估进度产生错误结论；           |\n| 演化模型         | 明确用户需求、提高系统质量、降低开发风险                                                                                                                                                                                                                                                                                                                             | 难于管理、结构较差、技术不成熟；<br>可能会抛弃瀑布模型文档控制的特点；<br>可能会导致最后的软件系统的系统结构较差                                                                                                                          |\n| 增量模型         | 客户可以在第一次增量后就使用到系统的核心功能，增强了客户使用系统的信心；<br>项目总体失败的风险降低，因为核心功能线开发出来，即使某一次增量失败，核心功能的产品仍然可以使用；<br>由于增量是由按照从高到低的优先级确定的，最高优先级的功能得到最多次的测试，保障了系统重要部分功能的可靠性；<br>所有增量都是在同一个体系结构指导下形成的，提高了系统稳定性和可维护性。 | 增量粒度难以选择；<br> 确定所有需求比较困难                                                                                                                                                                                               |\n| 喷泉模型         | 提高开发效率；<br>缩短开发周期                                                                                                                                                                                                                                                                                                                                       | 难以管理，工作计划要随时更新                                                                                                                                                                                                              |\n| 构件组装模型     | 充分利用软件复用，提高了软件开发效率；<br>允许多个项目同时开发，降低了效率，提高了可维护性，可实现分布提交软件产品                                                                                                                                                                                                                                                   | 缺乏通用的构件组装标准，风险较大； <br> 构件可重用性和高效性之间不可协调；<br> 由于过分依赖构件，构件指质量影响着最终的产品质量。                                                                                                         |\n| 快速应用开发模型 |                                                                                                                                                                                                                                                                                                                                                                      | 并非所有应用都适合采用RAD；<br>由于时间约束，开发人员和客户必须在极短时间内完成一系列需求分析，沟通配合不当都会导致RAD模型的失败；<br>RAD适合于管理信息系统的开发，对于其他类型的系统，如技术风险较高、与外围系统互操作性较高等，不太合适 |\n\n![模型开发特定及适用场合](/img/软件工程(1)/模型开发特定及适用场合.png)\n\n\n","source":"_posts/软件工程-1.md","raw":"---\ntitle: 软件工程(1)\ndate: 2024-10-23 18:02:31\ntags:\n    - 学习笔记\n---\n# 软件生命周期模型\n软件生命周期模型是一个框架，描述从软件需求定义直至软件经使用后废弃位置，跨越整个生存期的软件开发、运行和维护所实施的全部过程、活动和任务，同时描述生命周期不同阶段产生的软件工件，明确活动的执行角色等。\n![软件生命周期](/img/软件工程(1)/软件生命周期.png)\n## 软件过程\n在整个软件生命周期的系统**开发、运行和维护**过程红锁实施的全部过程、活动和任务的结构框架。通常用**软件过程模型**来描述软件过程。\n## 软件过程模型\n如下是几种传统的模型种类：\n1. **瀑布模型**\n   - **特点**：瀑布模型按照严格的阶段顺序执行，每个阶段（需求分析、设计、编码、测试、维护）必须完成后才能进入下一阶段，后续阶段不能回溯。\n   - **适用场景**：适用于需求明确且固定、开发流程清晰、变更较少的项目，如银行、政府系统等具有较高安全性和稳定性要求的项目。\n\n2. **演化模型**\n   - **特点**：该模型通过反复的迭代和反馈逐步完善软件，每次迭代后根据反馈改进设计和实现。\n   - **适用场景**：适合需求不完全明确、需要频繁变更或改进的软件项目，如科研项目和快速变化的市场环境中的产品。\n\n3. **增量模型**\n   - **特点**：将整个系统的开发划分为多个增量，每个增量实现部分功能，最终通过多个增量的叠加构建完整系统。\n   - **适用场景**：适用于需要快速交付部分功能的软件项目，如大型软件系统、复杂的企业应用，或需求不可能一次性完成的项目。\n\n4. **喷泉模型**\n   - **特点**：喷泉模型强调各个开发活动之间可以重叠进行，特别适合面向对象的开发。开发流程是连续的、迭代的，没有严格的阶段划分。\n   - **适用场景**：多用于面向对象的开发项目，如使用面向对象语言（如Java或C++）开发的系统。\n\n5. **V模型和W模型**\n   - **特点**：V模型是瀑布模型的扩展，在开发阶段的每一步后都有相应的验证与确认活动；W模型进一步加强了测试的频率与覆盖范围。\n   - **适用场景**：适用于对软件质量和测试要求高的项目，如医疗系统、航空软件等对测试和验证要求严格的场景。\n\n6. **螺旋模型**\n   - **特点**：螺旋模型结合了瀑布模型和迭代开发的优势，重点是风险管理，每次迭代都包括风险分析，并根据风险调整项目计划。\n   - **适用场景**：适用于大型复杂项目或具有高风险因素的项目，如航天、国防系统开发。\n\n7. **构件组装模型**\n   - **特点**：通过复用现有的构件或模块，减少开发时间和成本，强调模块化设计和组装。\n   - **适用场景**：适用于大型软件项目，特别是那些可以通过构件化的方式进行开发的系统，如企业级应用、ERP系统。\n\n8. **快速应用开发模型**\n   - **特点**：通过快速原型和频繁的用户反馈，缩短开发周期，快速交付功能齐全的产品版本。\n   - **适用场景**：适用于对开发速度要求高且用户反馈至关重要的项目，如互联网应用、手机App开发。\n\n9. **原型方法**\n   - **特点**：先构建软件的初步原型，经过用户的评估和反馈，反复改进，直到最终产品满足需求。\n   - **适用场景**：适合需求不明确或不完整的项目，或需要通过用户反馈不断优化的项目，如产品原型设计、用户界面开发等。\n\n其中主要介绍瀑布模型、UP模型、喷泉模型和演化模型等\n#### 瀑布模型\n瀑布模型为软件开发和软件维护提供了一种有效的管理模式，它在软件开发早起为消除非结构化软件、降低软件复杂度、促进软件开发工程化起着显著作用。\n其在不同开发阶段有不同的特征：\n1. **需求分析阶段**：\n   - **特征**：通过与客户沟通和分析业务需求，确定软件的功能需求和非功能需求，并形成详细的需求文档（Software Requirements Specification, SRS）。\n   - **输出**：需求规格说明书（SRS），包含系统功能、性能、安全性等要求。\n\n2. **系统设计阶段**：\n   - **特征**：基于需求规格说明书进行系统架构设计，确定系统的模块划分、数据结构、接口设计等。分为概要设计（高层设计）和详细设计（低层设计）。\n   - **输出**：系统设计文档，包含软件架构图、模块设计、数据库设计等内容。\n\n3. **编码实现阶段**：\n   - **特征**：根据系统设计文档，开发人员编写代码，完成各个模块的实现。代码需要遵循设计规范，并保证实现符合需求。\n   - **输出**：源代码、可执行程序、代码注释和开发文档。\n\n4. **测试阶段**：\n   - **特征**：对编码后的软件进行测试，包括单元测试、集成测试、系统测试和验收测试，确保软件功能的正确性和性能的稳定性。测试通常依据需求规格说明书进行，验证是否满足所有要求。\n   - **输出**：测试报告，包含测试用例、测试结果、缺陷报告等。\n\n5. **部署与维护阶段**：\n   - **特征**：将软件交付客户使用，并进行系统的安装和配置。维护包括修复错误、处理用户反馈、性能优化和系统升级。维护阶段可能需要多次修订和更新。\n   - **输出**：用户手册、维护文档、补丁程序、更新版本。\n\n其中共有的特征为:\n- 本阶段的工作对象来自上一阶段活动的输出，这些输出一般是代表上一阶段活动结束的里程碑式的文档\n- 根据本阶段的活动规程执行相应的任务\n- 产生本阶段活动相关产出，并将其作为下一阶段活动的输入\n  \n#### 演化模型\n使用瀑布模型人们认识到，由于需求很难调研充分，所以很难一次性开发成功\n演化模型提倡两次开发：\n  - 第一次是试验开发，得到试验性的原型产品，其目标只是在于探索可行性，弄清软件需求\n  - 第二次在此基础上获得较为满意的软件产品\n  ![演化模型](/img/软件工程(1)/演化模型.png)\n  演化模型一般适用于：\n  - 需求不清楚\n  - 小型或中小型系统\n  - 开发周期短\n\n#### 增量模型\n首先对最核心或最清晰的需求进行分析、设计、实现、测试并集成到系统中。再按照优先级逐步对后续的需求进行上述工作，逐步建成一个完整的开发方法。其**结合了瀑布模型和演化模型的优点**。 \n![增量模型](/img/软件工程(1)/演化模型.png)\n\n#### 喷泉模型\n- 喷泉模型也称迭代模型，认为软件开发过程的各个阶段是相互重叠，反复多次的。\n- 各个开发阶段没有特定的次序要求，完全可以并行进行，可以在某个开发阶段中随时补充其他任何开发阶段中遗漏的需求\n\n\n#### V模型和W模型\n相对于瀑布模型，V模型将测试活动提前，提高了其驾驭风险的能力，而W模型进一步加强了测试的频率与覆盖范围。\n![V模型和W模型](/img/软件工程(1)/V模型和W模型.png)\n\n#### 螺旋模型\n螺旋模型主要针对大型软件项目的开发周期长、风险高的特点\n![螺旋模型](/img/软件工程(1)/螺旋模型.png)\n螺旋模型本身含有四个象限内容：\n  - 制定计划：确定软件项目目标；明确对软件开发过程和软件产品的约束；制定详细的项目管理计划；根据当前的需求和风险因素，制定实施方案，并进行可行性分析，选定一个实施方案，并对其进行规划。\n  - 风险分析：明确每一个项目风险，估计风险发生的可能性、频率、损害程度，并制定风险管理措施，规避这些风险。\n  - 实施工程：针对每一个开发阶段的任务要求参照某一种生命周期模型执行本开发阶段的活动\n  - 客户评价：客户使用原型，反馈修改意见；根据客户的反馈，对产品及其周边开发过程进行评审，决定是否具备到下一个开发阶段的能力。\n\n#### 构件组装模型\n利用模块化思想将整个系统模块化，并在一定构建模型的支持下复用构件库中软件构件，通过组装高效率、高质量地构造软件系统。构建组装模型的本质上是演化的，开发过程是迭代的。\n构建组装模型的开发过程就是构建组装的的过程，维护党的过程就是构件升级、替换和扩充的过程。\n![构件组装模型](/img/软件工程(1)/构件组装模型.png)\n\n#### 快速应用开发模型（RAD）\nRAD是一个增量型的软件开发模型，强调极短的开发周期\n![快速应用开发模型](/img/软件工程(1)/快速应用开发模型.png)\n\n\n\n\n\n\n| 软件生命周期模型 | 优点                                                                                                                                                                                                                                                                                                                                                                 | 缺点                                                                                                                                                                                                                                      |\n| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| 瀑布模型         | 降低了软件开发的复杂程度，提高了软件开发过程的透明性及软件开发过程的可管理性 ； <br>推迟了软件实现，强调在软件实现前必须进行分析和设计工作；<br>以项目的阶段评审和文档控制为手段，有效地对整个开发过程进行指导，保证了阶段之间的正确衔接； <br>能够及时发现并纠正开发过程中存在的缺陷，从而使产品达到预期的质量要求；                                                | 模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题； <br>模型的风险控制能力较弱； <br>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加工作量； <br>管理人员可能根据文档评估进度产生错误结论；           |\n| 演化模型         | 明确用户需求、提高系统质量、降低开发风险                                                                                                                                                                                                                                                                                                                             | 难于管理、结构较差、技术不成熟；<br>可能会抛弃瀑布模型文档控制的特点；<br>可能会导致最后的软件系统的系统结构较差                                                                                                                          |\n| 增量模型         | 客户可以在第一次增量后就使用到系统的核心功能，增强了客户使用系统的信心；<br>项目总体失败的风险降低，因为核心功能线开发出来，即使某一次增量失败，核心功能的产品仍然可以使用；<br>由于增量是由按照从高到低的优先级确定的，最高优先级的功能得到最多次的测试，保障了系统重要部分功能的可靠性；<br>所有增量都是在同一个体系结构指导下形成的，提高了系统稳定性和可维护性。 | 增量粒度难以选择；<br> 确定所有需求比较困难                                                                                                                                                                                               |\n| 喷泉模型         | 提高开发效率；<br>缩短开发周期                                                                                                                                                                                                                                                                                                                                       | 难以管理，工作计划要随时更新                                                                                                                                                                                                              |\n| 构件组装模型     | 充分利用软件复用，提高了软件开发效率；<br>允许多个项目同时开发，降低了效率，提高了可维护性，可实现分布提交软件产品                                                                                                                                                                                                                                                   | 缺乏通用的构件组装标准，风险较大； <br> 构件可重用性和高效性之间不可协调；<br> 由于过分依赖构件，构件指质量影响着最终的产品质量。                                                                                                         |\n| 快速应用开发模型 |                                                                                                                                                                                                                                                                                                                                                                      | 并非所有应用都适合采用RAD；<br>由于时间约束，开发人员和客户必须在极短时间内完成一系列需求分析，沟通配合不当都会导致RAD模型的失败；<br>RAD适合于管理信息系统的开发，对于其他类型的系统，如技术风险较高、与外围系统互操作性较高等，不太合适 |\n\n![模型开发特定及适用场合](/img/软件工程(1)/模型开发特定及适用场合.png)\n\n\n","slug":"软件工程-1","published":1,"updated":"2024-12-20T04:27:29.409Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot8000l6d6e1bk3a761","content":"<h1 id=\"软件生命周期模型\"><a href=\"#软件生命周期模型\" class=\"headerlink\" title=\"软件生命周期模型\"></a>软件生命周期模型</h1><p>软件生命周期模型是一个框架，描述从软件需求定义直至软件经使用后废弃位置，跨越整个生存期的软件开发、运行和维护所实施的全部过程、活动和任务，同时描述生命周期不同阶段产生的软件工件，明确活动的执行角色等。<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"软件生命周期\"></p>\n<h2 id=\"软件过程\"><a href=\"#软件过程\" class=\"headerlink\" title=\"软件过程\"></a>软件过程</h2><p>在整个软件生命周期的系统<strong>开发、运行和维护</strong>过程红锁实施的全部过程、活动和任务的结构框架。通常用<strong>软件过程模型</strong>来描述软件过程。</p>\n<h2 id=\"软件过程模型\"><a href=\"#软件过程模型\" class=\"headerlink\" title=\"软件过程模型\"></a>软件过程模型</h2><p>如下是几种传统的模型种类：</p>\n<ol>\n<li><p><strong>瀑布模型</strong></p>\n<ul>\n<li><strong>特点</strong>：瀑布模型按照严格的阶段顺序执行，每个阶段（需求分析、设计、编码、测试、维护）必须完成后才能进入下一阶段，后续阶段不能回溯。</li>\n<li><strong>适用场景</strong>：适用于需求明确且固定、开发流程清晰、变更较少的项目，如银行、政府系统等具有较高安全性和稳定性要求的项目。</li>\n</ul>\n</li>\n<li><p><strong>演化模型</strong></p>\n<ul>\n<li><strong>特点</strong>：该模型通过反复的迭代和反馈逐步完善软件，每次迭代后根据反馈改进设计和实现。</li>\n<li><strong>适用场景</strong>：适合需求不完全明确、需要频繁变更或改进的软件项目，如科研项目和快速变化的市场环境中的产品。</li>\n</ul>\n</li>\n<li><p><strong>增量模型</strong></p>\n<ul>\n<li><strong>特点</strong>：将整个系统的开发划分为多个增量，每个增量实现部分功能，最终通过多个增量的叠加构建完整系统。</li>\n<li><strong>适用场景</strong>：适用于需要快速交付部分功能的软件项目，如大型软件系统、复杂的企业应用，或需求不可能一次性完成的项目。</li>\n</ul>\n</li>\n<li><p><strong>喷泉模型</strong></p>\n<ul>\n<li><strong>特点</strong>：喷泉模型强调各个开发活动之间可以重叠进行，特别适合面向对象的开发。开发流程是连续的、迭代的，没有严格的阶段划分。</li>\n<li><strong>适用场景</strong>：多用于面向对象的开发项目，如使用面向对象语言（如Java或C++）开发的系统。</li>\n</ul>\n</li>\n<li><p><strong>V模型和W模型</strong></p>\n<ul>\n<li><strong>特点</strong>：V模型是瀑布模型的扩展，在开发阶段的每一步后都有相应的验证与确认活动；W模型进一步加强了测试的频率与覆盖范围。</li>\n<li><strong>适用场景</strong>：适用于对软件质量和测试要求高的项目，如医疗系统、航空软件等对测试和验证要求严格的场景。</li>\n</ul>\n</li>\n<li><p><strong>螺旋模型</strong></p>\n<ul>\n<li><strong>特点</strong>：螺旋模型结合了瀑布模型和迭代开发的优势，重点是风险管理，每次迭代都包括风险分析，并根据风险调整项目计划。</li>\n<li><strong>适用场景</strong>：适用于大型复杂项目或具有高风险因素的项目，如航天、国防系统开发。</li>\n</ul>\n</li>\n<li><p><strong>构件组装模型</strong></p>\n<ul>\n<li><strong>特点</strong>：通过复用现有的构件或模块，减少开发时间和成本，强调模块化设计和组装。</li>\n<li><strong>适用场景</strong>：适用于大型软件项目，特别是那些可以通过构件化的方式进行开发的系统，如企业级应用、ERP系统。</li>\n</ul>\n</li>\n<li><p><strong>快速应用开发模型</strong></p>\n<ul>\n<li><strong>特点</strong>：通过快速原型和频繁的用户反馈，缩短开发周期，快速交付功能齐全的产品版本。</li>\n<li><strong>适用场景</strong>：适用于对开发速度要求高且用户反馈至关重要的项目，如互联网应用、手机App开发。</li>\n</ul>\n</li>\n<li><p><strong>原型方法</strong></p>\n<ul>\n<li><strong>特点</strong>：先构建软件的初步原型，经过用户的评估和反馈，反复改进，直到最终产品满足需求。</li>\n<li><strong>适用场景</strong>：适合需求不明确或不完整的项目，或需要通过用户反馈不断优化的项目，如产品原型设计、用户界面开发等。</li>\n</ul>\n</li>\n</ol>\n<p>其中主要介绍瀑布模型、UP模型、喷泉模型和演化模型等</p>\n<h4 id=\"瀑布模型\"><a href=\"#瀑布模型\" class=\"headerlink\" title=\"瀑布模型\"></a>瀑布模型</h4><p>瀑布模型为软件开发和软件维护提供了一种有效的管理模式，它在软件开发早起为消除非结构化软件、降低软件复杂度、促进软件开发工程化起着显著作用。<br>其在不同开发阶段有不同的特征：</p>\n<ol>\n<li><p><strong>需求分析阶段</strong>：</p>\n<ul>\n<li><strong>特征</strong>：通过与客户沟通和分析业务需求，确定软件的功能需求和非功能需求，并形成详细的需求文档（Software Requirements Specification, SRS）。</li>\n<li><strong>输出</strong>：需求规格说明书（SRS），包含系统功能、性能、安全性等要求。</li>\n</ul>\n</li>\n<li><p><strong>系统设计阶段</strong>：</p>\n<ul>\n<li><strong>特征</strong>：基于需求规格说明书进行系统架构设计，确定系统的模块划分、数据结构、接口设计等。分为概要设计（高层设计）和详细设计（低层设计）。</li>\n<li><strong>输出</strong>：系统设计文档，包含软件架构图、模块设计、数据库设计等内容。</li>\n</ul>\n</li>\n<li><p><strong>编码实现阶段</strong>：</p>\n<ul>\n<li><strong>特征</strong>：根据系统设计文档，开发人员编写代码，完成各个模块的实现。代码需要遵循设计规范，并保证实现符合需求。</li>\n<li><strong>输出</strong>：源代码、可执行程序、代码注释和开发文档。</li>\n</ul>\n</li>\n<li><p><strong>测试阶段</strong>：</p>\n<ul>\n<li><strong>特征</strong>：对编码后的软件进行测试，包括单元测试、集成测试、系统测试和验收测试，确保软件功能的正确性和性能的稳定性。测试通常依据需求规格说明书进行，验证是否满足所有要求。</li>\n<li><strong>输出</strong>：测试报告，包含测试用例、测试结果、缺陷报告等。</li>\n</ul>\n</li>\n<li><p><strong>部署与维护阶段</strong>：</p>\n<ul>\n<li><strong>特征</strong>：将软件交付客户使用，并进行系统的安装和配置。维护包括修复错误、处理用户反馈、性能优化和系统升级。维护阶段可能需要多次修订和更新。</li>\n<li><strong>输出</strong>：用户手册、维护文档、补丁程序、更新版本。</li>\n</ul>\n</li>\n</ol>\n<p>其中共有的特征为:</p>\n<ul>\n<li>本阶段的工作对象来自上一阶段活动的输出，这些输出一般是代表上一阶段活动结束的里程碑式的文档</li>\n<li>根据本阶段的活动规程执行相应的任务</li>\n<li>产生本阶段活动相关产出，并将其作为下一阶段活动的输入</li>\n</ul>\n<h4 id=\"演化模型\"><a href=\"#演化模型\" class=\"headerlink\" title=\"演化模型\"></a>演化模型</h4><p>使用瀑布模型人们认识到，由于需求很难调研充分，所以很难一次性开发成功<br>演化模型提倡两次开发：</p>\n<ul>\n<li>第一次是试验开发，得到试验性的原型产品，其目标只是在于探索可行性，弄清软件需求</li>\n<li>第二次在此基础上获得较为满意的软件产品<br>  <img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E6%BC%94%E5%8C%96%E6%A8%A1%E5%9E%8B.png\" alt=\"演化模型\"><br>  演化模型一般适用于：</li>\n<li>需求不清楚</li>\n<li>小型或中小型系统</li>\n<li>开发周期短</li>\n</ul>\n<h4 id=\"增量模型\"><a href=\"#增量模型\" class=\"headerlink\" title=\"增量模型\"></a>增量模型</h4><p>首先对最核心或最清晰的需求进行分析、设计、实现、测试并集成到系统中。再按照优先级逐步对后续的需求进行上述工作，逐步建成一个完整的开发方法。其<strong>结合了瀑布模型和演化模型的优点</strong>。<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E6%BC%94%E5%8C%96%E6%A8%A1%E5%9E%8B.png\" alt=\"增量模型\"></p>\n<h4 id=\"喷泉模型\"><a href=\"#喷泉模型\" class=\"headerlink\" title=\"喷泉模型\"></a>喷泉模型</h4><ul>\n<li>喷泉模型也称迭代模型，认为软件开发过程的各个阶段是相互重叠，反复多次的。</li>\n<li>各个开发阶段没有特定的次序要求，完全可以并行进行，可以在某个开发阶段中随时补充其他任何开发阶段中遗漏的需求</li>\n</ul>\n<h4 id=\"V模型和W模型\"><a href=\"#V模型和W模型\" class=\"headerlink\" title=\"V模型和W模型\"></a>V模型和W模型</h4><p>相对于瀑布模型，V模型将测试活动提前，提高了其驾驭风险的能力，而W模型进一步加强了测试的频率与覆盖范围。<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/V%E6%A8%A1%E5%9E%8B%E5%92%8CW%E6%A8%A1%E5%9E%8B.png\" alt=\"V模型和W模型\"></p>\n<h4 id=\"螺旋模型\"><a href=\"#螺旋模型\" class=\"headerlink\" title=\"螺旋模型\"></a>螺旋模型</h4><p>螺旋模型主要针对大型软件项目的开发周期长、风险高的特点<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.png\" alt=\"螺旋模型\"><br>螺旋模型本身含有四个象限内容：</p>\n<ul>\n<li>制定计划：确定软件项目目标；明确对软件开发过程和软件产品的约束；制定详细的项目管理计划；根据当前的需求和风险因素，制定实施方案，并进行可行性分析，选定一个实施方案，并对其进行规划。</li>\n<li>风险分析：明确每一个项目风险，估计风险发生的可能性、频率、损害程度，并制定风险管理措施，规避这些风险。</li>\n<li>实施工程：针对每一个开发阶段的任务要求参照某一种生命周期模型执行本开发阶段的活动</li>\n<li>客户评价：客户使用原型，反馈修改意见；根据客户的反馈，对产品及其周边开发过程进行评审，决定是否具备到下一个开发阶段的能力。</li>\n</ul>\n<h4 id=\"构件组装模型\"><a href=\"#构件组装模型\" class=\"headerlink\" title=\"构件组装模型\"></a>构件组装模型</h4><p>利用模块化思想将整个系统模块化，并在一定构建模型的支持下复用构件库中软件构件，通过组装高效率、高质量地构造软件系统。构建组装模型的本质上是演化的，开发过程是迭代的。<br>构建组装模型的开发过程就是构建组装的的过程，维护党的过程就是构件升级、替换和扩充的过程。<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E6%9E%84%E4%BB%B6%E7%BB%84%E8%A3%85%E6%A8%A1%E5%9E%8B.png\" alt=\"构件组装模型\"></p>\n<h4 id=\"快速应用开发模型（RAD）\"><a href=\"#快速应用开发模型（RAD）\" class=\"headerlink\" title=\"快速应用开发模型（RAD）\"></a>快速应用开发模型（RAD）</h4><p>RAD是一个增量型的软件开发模型，强调极短的开发周期<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E5%BF%AB%E9%80%9F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B.png\" alt=\"快速应用开发模型\"></p>\n<table>\n<thead>\n<tr>\n<th>软件生命周期模型</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>瀑布模型</td>\n<td>降低了软件开发的复杂程度，提高了软件开发过程的透明性及软件开发过程的可管理性 ； <br>推迟了软件实现，强调在软件实现前必须进行分析和设计工作；<br>以项目的阶段评审和文档控制为手段，有效地对整个开发过程进行指导，保证了阶段之间的正确衔接； <br>能够及时发现并纠正开发过程中存在的缺陷，从而使产品达到预期的质量要求；</td>\n<td>模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题； <br>模型的风险控制能力较弱； <br>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加工作量； <br>管理人员可能根据文档评估进度产生错误结论；</td>\n</tr>\n<tr>\n<td>演化模型</td>\n<td>明确用户需求、提高系统质量、降低开发风险</td>\n<td>难于管理、结构较差、技术不成熟；<br>可能会抛弃瀑布模型文档控制的特点；<br>可能会导致最后的软件系统的系统结构较差</td>\n</tr>\n<tr>\n<td>增量模型</td>\n<td>客户可以在第一次增量后就使用到系统的核心功能，增强了客户使用系统的信心；<br>项目总体失败的风险降低，因为核心功能线开发出来，即使某一次增量失败，核心功能的产品仍然可以使用；<br>由于增量是由按照从高到低的优先级确定的，最高优先级的功能得到最多次的测试，保障了系统重要部分功能的可靠性；<br>所有增量都是在同一个体系结构指导下形成的，提高了系统稳定性和可维护性。</td>\n<td>增量粒度难以选择；<br> 确定所有需求比较困难</td>\n</tr>\n<tr>\n<td>喷泉模型</td>\n<td>提高开发效率；<br>缩短开发周期</td>\n<td>难以管理，工作计划要随时更新</td>\n</tr>\n<tr>\n<td>构件组装模型</td>\n<td>充分利用软件复用，提高了软件开发效率；<br>允许多个项目同时开发，降低了效率，提高了可维护性，可实现分布提交软件产品</td>\n<td>缺乏通用的构件组装标准，风险较大； <br> 构件可重用性和高效性之间不可协调；<br> 由于过分依赖构件，构件指质量影响着最终的产品质量。</td>\n</tr>\n<tr>\n<td>快速应用开发模型</td>\n<td></td>\n<td>并非所有应用都适合采用RAD；<br>由于时间约束，开发人员和客户必须在极短时间内完成一系列需求分析，沟通配合不当都会导致RAD模型的失败；<br>RAD适合于管理信息系统的开发，对于其他类型的系统，如技术风险较高、与外围系统互操作性较高等，不太合适</td>\n</tr>\n</tbody></table>\n<p><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E7%89%B9%E5%AE%9A%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88.png\" alt=\"模型开发特定及适用场合\"></p>\n","excerpt":"","more":"<h1 id=\"软件生命周期模型\"><a href=\"#软件生命周期模型\" class=\"headerlink\" title=\"软件生命周期模型\"></a>软件生命周期模型</h1><p>软件生命周期模型是一个框架，描述从软件需求定义直至软件经使用后废弃位置，跨越整个生存期的软件开发、运行和维护所实施的全部过程、活动和任务，同时描述生命周期不同阶段产生的软件工件，明确活动的执行角色等。<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png\" alt=\"软件生命周期\"></p>\n<h2 id=\"软件过程\"><a href=\"#软件过程\" class=\"headerlink\" title=\"软件过程\"></a>软件过程</h2><p>在整个软件生命周期的系统<strong>开发、运行和维护</strong>过程红锁实施的全部过程、活动和任务的结构框架。通常用<strong>软件过程模型</strong>来描述软件过程。</p>\n<h2 id=\"软件过程模型\"><a href=\"#软件过程模型\" class=\"headerlink\" title=\"软件过程模型\"></a>软件过程模型</h2><p>如下是几种传统的模型种类：</p>\n<ol>\n<li><p><strong>瀑布模型</strong></p>\n<ul>\n<li><strong>特点</strong>：瀑布模型按照严格的阶段顺序执行，每个阶段（需求分析、设计、编码、测试、维护）必须完成后才能进入下一阶段，后续阶段不能回溯。</li>\n<li><strong>适用场景</strong>：适用于需求明确且固定、开发流程清晰、变更较少的项目，如银行、政府系统等具有较高安全性和稳定性要求的项目。</li>\n</ul>\n</li>\n<li><p><strong>演化模型</strong></p>\n<ul>\n<li><strong>特点</strong>：该模型通过反复的迭代和反馈逐步完善软件，每次迭代后根据反馈改进设计和实现。</li>\n<li><strong>适用场景</strong>：适合需求不完全明确、需要频繁变更或改进的软件项目，如科研项目和快速变化的市场环境中的产品。</li>\n</ul>\n</li>\n<li><p><strong>增量模型</strong></p>\n<ul>\n<li><strong>特点</strong>：将整个系统的开发划分为多个增量，每个增量实现部分功能，最终通过多个增量的叠加构建完整系统。</li>\n<li><strong>适用场景</strong>：适用于需要快速交付部分功能的软件项目，如大型软件系统、复杂的企业应用，或需求不可能一次性完成的项目。</li>\n</ul>\n</li>\n<li><p><strong>喷泉模型</strong></p>\n<ul>\n<li><strong>特点</strong>：喷泉模型强调各个开发活动之间可以重叠进行，特别适合面向对象的开发。开发流程是连续的、迭代的，没有严格的阶段划分。</li>\n<li><strong>适用场景</strong>：多用于面向对象的开发项目，如使用面向对象语言（如Java或C++）开发的系统。</li>\n</ul>\n</li>\n<li><p><strong>V模型和W模型</strong></p>\n<ul>\n<li><strong>特点</strong>：V模型是瀑布模型的扩展，在开发阶段的每一步后都有相应的验证与确认活动；W模型进一步加强了测试的频率与覆盖范围。</li>\n<li><strong>适用场景</strong>：适用于对软件质量和测试要求高的项目，如医疗系统、航空软件等对测试和验证要求严格的场景。</li>\n</ul>\n</li>\n<li><p><strong>螺旋模型</strong></p>\n<ul>\n<li><strong>特点</strong>：螺旋模型结合了瀑布模型和迭代开发的优势，重点是风险管理，每次迭代都包括风险分析，并根据风险调整项目计划。</li>\n<li><strong>适用场景</strong>：适用于大型复杂项目或具有高风险因素的项目，如航天、国防系统开发。</li>\n</ul>\n</li>\n<li><p><strong>构件组装模型</strong></p>\n<ul>\n<li><strong>特点</strong>：通过复用现有的构件或模块，减少开发时间和成本，强调模块化设计和组装。</li>\n<li><strong>适用场景</strong>：适用于大型软件项目，特别是那些可以通过构件化的方式进行开发的系统，如企业级应用、ERP系统。</li>\n</ul>\n</li>\n<li><p><strong>快速应用开发模型</strong></p>\n<ul>\n<li><strong>特点</strong>：通过快速原型和频繁的用户反馈，缩短开发周期，快速交付功能齐全的产品版本。</li>\n<li><strong>适用场景</strong>：适用于对开发速度要求高且用户反馈至关重要的项目，如互联网应用、手机App开发。</li>\n</ul>\n</li>\n<li><p><strong>原型方法</strong></p>\n<ul>\n<li><strong>特点</strong>：先构建软件的初步原型，经过用户的评估和反馈，反复改进，直到最终产品满足需求。</li>\n<li><strong>适用场景</strong>：适合需求不明确或不完整的项目，或需要通过用户反馈不断优化的项目，如产品原型设计、用户界面开发等。</li>\n</ul>\n</li>\n</ol>\n<p>其中主要介绍瀑布模型、UP模型、喷泉模型和演化模型等</p>\n<h4 id=\"瀑布模型\"><a href=\"#瀑布模型\" class=\"headerlink\" title=\"瀑布模型\"></a>瀑布模型</h4><p>瀑布模型为软件开发和软件维护提供了一种有效的管理模式，它在软件开发早起为消除非结构化软件、降低软件复杂度、促进软件开发工程化起着显著作用。<br>其在不同开发阶段有不同的特征：</p>\n<ol>\n<li><p><strong>需求分析阶段</strong>：</p>\n<ul>\n<li><strong>特征</strong>：通过与客户沟通和分析业务需求，确定软件的功能需求和非功能需求，并形成详细的需求文档（Software Requirements Specification, SRS）。</li>\n<li><strong>输出</strong>：需求规格说明书（SRS），包含系统功能、性能、安全性等要求。</li>\n</ul>\n</li>\n<li><p><strong>系统设计阶段</strong>：</p>\n<ul>\n<li><strong>特征</strong>：基于需求规格说明书进行系统架构设计，确定系统的模块划分、数据结构、接口设计等。分为概要设计（高层设计）和详细设计（低层设计）。</li>\n<li><strong>输出</strong>：系统设计文档，包含软件架构图、模块设计、数据库设计等内容。</li>\n</ul>\n</li>\n<li><p><strong>编码实现阶段</strong>：</p>\n<ul>\n<li><strong>特征</strong>：根据系统设计文档，开发人员编写代码，完成各个模块的实现。代码需要遵循设计规范，并保证实现符合需求。</li>\n<li><strong>输出</strong>：源代码、可执行程序、代码注释和开发文档。</li>\n</ul>\n</li>\n<li><p><strong>测试阶段</strong>：</p>\n<ul>\n<li><strong>特征</strong>：对编码后的软件进行测试，包括单元测试、集成测试、系统测试和验收测试，确保软件功能的正确性和性能的稳定性。测试通常依据需求规格说明书进行，验证是否满足所有要求。</li>\n<li><strong>输出</strong>：测试报告，包含测试用例、测试结果、缺陷报告等。</li>\n</ul>\n</li>\n<li><p><strong>部署与维护阶段</strong>：</p>\n<ul>\n<li><strong>特征</strong>：将软件交付客户使用，并进行系统的安装和配置。维护包括修复错误、处理用户反馈、性能优化和系统升级。维护阶段可能需要多次修订和更新。</li>\n<li><strong>输出</strong>：用户手册、维护文档、补丁程序、更新版本。</li>\n</ul>\n</li>\n</ol>\n<p>其中共有的特征为:</p>\n<ul>\n<li>本阶段的工作对象来自上一阶段活动的输出，这些输出一般是代表上一阶段活动结束的里程碑式的文档</li>\n<li>根据本阶段的活动规程执行相应的任务</li>\n<li>产生本阶段活动相关产出，并将其作为下一阶段活动的输入</li>\n</ul>\n<h4 id=\"演化模型\"><a href=\"#演化模型\" class=\"headerlink\" title=\"演化模型\"></a>演化模型</h4><p>使用瀑布模型人们认识到，由于需求很难调研充分，所以很难一次性开发成功<br>演化模型提倡两次开发：</p>\n<ul>\n<li>第一次是试验开发，得到试验性的原型产品，其目标只是在于探索可行性，弄清软件需求</li>\n<li>第二次在此基础上获得较为满意的软件产品<br>  <img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E6%BC%94%E5%8C%96%E6%A8%A1%E5%9E%8B.png\" alt=\"演化模型\"><br>  演化模型一般适用于：</li>\n<li>需求不清楚</li>\n<li>小型或中小型系统</li>\n<li>开发周期短</li>\n</ul>\n<h4 id=\"增量模型\"><a href=\"#增量模型\" class=\"headerlink\" title=\"增量模型\"></a>增量模型</h4><p>首先对最核心或最清晰的需求进行分析、设计、实现、测试并集成到系统中。再按照优先级逐步对后续的需求进行上述工作，逐步建成一个完整的开发方法。其<strong>结合了瀑布模型和演化模型的优点</strong>。<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E6%BC%94%E5%8C%96%E6%A8%A1%E5%9E%8B.png\" alt=\"增量模型\"></p>\n<h4 id=\"喷泉模型\"><a href=\"#喷泉模型\" class=\"headerlink\" title=\"喷泉模型\"></a>喷泉模型</h4><ul>\n<li>喷泉模型也称迭代模型，认为软件开发过程的各个阶段是相互重叠，反复多次的。</li>\n<li>各个开发阶段没有特定的次序要求，完全可以并行进行，可以在某个开发阶段中随时补充其他任何开发阶段中遗漏的需求</li>\n</ul>\n<h4 id=\"V模型和W模型\"><a href=\"#V模型和W模型\" class=\"headerlink\" title=\"V模型和W模型\"></a>V模型和W模型</h4><p>相对于瀑布模型，V模型将测试活动提前，提高了其驾驭风险的能力，而W模型进一步加强了测试的频率与覆盖范围。<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/V%E6%A8%A1%E5%9E%8B%E5%92%8CW%E6%A8%A1%E5%9E%8B.png\" alt=\"V模型和W模型\"></p>\n<h4 id=\"螺旋模型\"><a href=\"#螺旋模型\" class=\"headerlink\" title=\"螺旋模型\"></a>螺旋模型</h4><p>螺旋模型主要针对大型软件项目的开发周期长、风险高的特点<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.png\" alt=\"螺旋模型\"><br>螺旋模型本身含有四个象限内容：</p>\n<ul>\n<li>制定计划：确定软件项目目标；明确对软件开发过程和软件产品的约束；制定详细的项目管理计划；根据当前的需求和风险因素，制定实施方案，并进行可行性分析，选定一个实施方案，并对其进行规划。</li>\n<li>风险分析：明确每一个项目风险，估计风险发生的可能性、频率、损害程度，并制定风险管理措施，规避这些风险。</li>\n<li>实施工程：针对每一个开发阶段的任务要求参照某一种生命周期模型执行本开发阶段的活动</li>\n<li>客户评价：客户使用原型，反馈修改意见；根据客户的反馈，对产品及其周边开发过程进行评审，决定是否具备到下一个开发阶段的能力。</li>\n</ul>\n<h4 id=\"构件组装模型\"><a href=\"#构件组装模型\" class=\"headerlink\" title=\"构件组装模型\"></a>构件组装模型</h4><p>利用模块化思想将整个系统模块化，并在一定构建模型的支持下复用构件库中软件构件，通过组装高效率、高质量地构造软件系统。构建组装模型的本质上是演化的，开发过程是迭代的。<br>构建组装模型的开发过程就是构建组装的的过程，维护党的过程就是构件升级、替换和扩充的过程。<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E6%9E%84%E4%BB%B6%E7%BB%84%E8%A3%85%E6%A8%A1%E5%9E%8B.png\" alt=\"构件组装模型\"></p>\n<h4 id=\"快速应用开发模型（RAD）\"><a href=\"#快速应用开发模型（RAD）\" class=\"headerlink\" title=\"快速应用开发模型（RAD）\"></a>快速应用开发模型（RAD）</h4><p>RAD是一个增量型的软件开发模型，强调极短的开发周期<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E5%BF%AB%E9%80%9F%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B.png\" alt=\"快速应用开发模型\"></p>\n<table>\n<thead>\n<tr>\n<th>软件生命周期模型</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>瀑布模型</td>\n<td>降低了软件开发的复杂程度，提高了软件开发过程的透明性及软件开发过程的可管理性 ； <br>推迟了软件实现，强调在软件实现前必须进行分析和设计工作；<br>以项目的阶段评审和文档控制为手段，有效地对整个开发过程进行指导，保证了阶段之间的正确衔接； <br>能够及时发现并纠正开发过程中存在的缺陷，从而使产品达到预期的质量要求；</td>\n<td>模型缺乏灵活性，特别是无法解决软件需求不明确或不准确的问题； <br>模型的风险控制能力较弱； <br>瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加工作量； <br>管理人员可能根据文档评估进度产生错误结论；</td>\n</tr>\n<tr>\n<td>演化模型</td>\n<td>明确用户需求、提高系统质量、降低开发风险</td>\n<td>难于管理、结构较差、技术不成熟；<br>可能会抛弃瀑布模型文档控制的特点；<br>可能会导致最后的软件系统的系统结构较差</td>\n</tr>\n<tr>\n<td>增量模型</td>\n<td>客户可以在第一次增量后就使用到系统的核心功能，增强了客户使用系统的信心；<br>项目总体失败的风险降低，因为核心功能线开发出来，即使某一次增量失败，核心功能的产品仍然可以使用；<br>由于增量是由按照从高到低的优先级确定的，最高优先级的功能得到最多次的测试，保障了系统重要部分功能的可靠性；<br>所有增量都是在同一个体系结构指导下形成的，提高了系统稳定性和可维护性。</td>\n<td>增量粒度难以选择；<br> 确定所有需求比较困难</td>\n</tr>\n<tr>\n<td>喷泉模型</td>\n<td>提高开发效率；<br>缩短开发周期</td>\n<td>难以管理，工作计划要随时更新</td>\n</tr>\n<tr>\n<td>构件组装模型</td>\n<td>充分利用软件复用，提高了软件开发效率；<br>允许多个项目同时开发，降低了效率，提高了可维护性，可实现分布提交软件产品</td>\n<td>缺乏通用的构件组装标准，风险较大； <br> 构件可重用性和高效性之间不可协调；<br> 由于过分依赖构件，构件指质量影响着最终的产品质量。</td>\n</tr>\n<tr>\n<td>快速应用开发模型</td>\n<td></td>\n<td>并非所有应用都适合采用RAD；<br>由于时间约束，开发人员和客户必须在极短时间内完成一系列需求分析，沟通配合不当都会导致RAD模型的失败；<br>RAD适合于管理信息系统的开发，对于其他类型的系统，如技术风险较高、与外围系统互操作性较高等，不太合适</td>\n</tr>\n</tbody></table>\n<p><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(1)/%E6%A8%A1%E5%9E%8B%E5%BC%80%E5%8F%91%E7%89%B9%E5%AE%9A%E5%8F%8A%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88.png\" alt=\"模型开发特定及适用场合\"></p>\n"},{"title":"软件工程(2)","date":"2024-10-23T14:57:52.000Z","_content":"# 面向对象方法\n1. 对象\n   - 在软件工程中，一般存在三个对象：客观对象、问题对象和计算机对象\n   - 彼此之间的关系为 客观对象（抽象）$\\rightarrow$ 问题对象（封装）$\\leftrightarrow$ 计算机对象（模拟）\n   - 一个对象应该是具有状态、行为和标识符的实体，并且对象之间往往可以通过通信互相交互\n   - 对象具有下列4个性质：\n     - 自治性\n     - 封闭性\n     - 通信性\n     - 被动性\n\n2. 类\n    直接忽略吧，感觉都知道\n\n## UML\n### 定义\nUML是一中标准的图形化建模语言，它是面向对象分析与设计的一种标准标识\n- 它是一种**可视化的建模语言**，不是一种可视化的程序设计语言\n- 它是一种**建模语言规格说明**，不是工具或知识库的规格说明\n\n### 结构\n- 基本构造块 Basic building block\n  - 事物 Thing\n  - 关系 Relationship\n  - 图   Diagram\n- 语义规则 Rule\n  - name、scope、visibility、integrity、execution\n- 通用机制 Common mechanism\n  - specification、adornment（修饰）、common division、extensibility mechanism\n\n### 4+1图\n- UML用模型来描述系统的结构（静态特征）以及行为（动态特征）。从不同的视角为系统的架构建模，形成系统的不同视图（view），称为4+1图，**从一个需求的角度出发描述与系统设计的4个维度之间的关系**\n![UML视图](/img/软件工程(2)/UML视图.png)\n  - **用例视图：表示功能需求**，强调从用户的角度看到的或需要的系统功能。这种视图也叫做用户模型视图（user model view） 或场景视图（scenario view）\n  - 逻辑视图： 展现软件系统设计的静态结构的组成及特征，也称为结构模型视图（structural model view） 或静态视图（static view）\n  - 进程视图：描述软件系统设计的并发和同步等特性，**关注系统非功能性需求**，也称为行为模型视图（behavioral model view）、过程视图（process view）、 协作视图（collaborative view）和动态视图（dynamic view）\n  - 构件视图：关注软件代码的静态组织与管理，也称为实现模型视图（implementation \nmodel view ）和开发视图（development view）\n  - 部署视图：描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求（性能、可靠性等），也称为环境模型视图或物理视图（physical view）；\n\n### 9个基本图\n-  用例图（Use case diagram）：（从用户的角度）描述系统的功能；\n- 类图（Class diagram）：描述系统的静态结构（类及其相互关系）；\n- 对象图（Object diagram）： 描述系统在某个时刻的静态结构（对象及其相互关系）；\n- 顺序/序列图（Sequence diagram）：按时间顺序描述系统元素间的交互；\n- 协作图（Collaboration diagram）：按照时间和空间的顺序描述系统元素间的交互和它们之间\n的关系；\n- 状态图（State diagram）：描述了系统元素（对象）的状态条件和响应；\n- 活动图（Activity diagram）：描述了系统元素之间的活动；\n- 构件图（Component diagram）：描述了实现系统的元素（类或包）组织；\n- 部署图（Deployment diagram）：描述了环境元素的配置并把实现系统的元素映射到配置上\n![基本图分类(1)](/img/软件工程(2)/UML9个基本图(1).png)\n![基本图分类(2)](/img/软件工程(2)/UML9个基本图(2).png)\n\n值得注意的是，对于其中这些内容，在考题中往往是以其他视图的要求提出，所以UML视图与图之间的关系为：\n- **用例视图：使用用例图；**\n- **逻辑视图：使用类图、对象图，顺序图/协作图；**\n- 进程视图：使用状态图和活动图；\n- 构件视图：使用构件图；\n- 部署视图：使用部署图\n下面给出一些示例：\n- 用例图\n![用例图](/img/软件工程(2)/用例图.png)\n- 类图\n![类图](/img/软件工程(2)/类图.png)\n- 对象图\n![对象图](/img/软件工程(2)/对象图.png)\n- 组件/构件图\n![组件图](/img/软件工程(2)/组件图.png)\n- 部署图\n![部署图](/img/软件工程(2)/部署图.png)\n- 状态图\n![状态图](/img/软件工程(2)/状态图.png)\n- 活动图\n![活动图](/img/软件工程(2)/活动图.png)\n- 序列/顺序图\n![顺序图](/img/软件工程(2)/顺序图.png)\n- 协作图\n![协作图](/img/软件工程(2)/协作图.png)\n\n## 领域分析模型\n领域模型表示了需求分析阶段“当前系统”逻辑模型的静态结构。其针对某一特定领域内概念类或者对象的抽象可视化表示。\n领域模型主要用于概括地描述业务背景及重要的业务流程，帮助软件开发人员\n在短时间内尽快了解业务。\n- **业务背景**：可由用户需求说明书或者调研报告中具有代表业务概念或者业务对象的词汇获得，这些词汇可统称为“概念类”；并通过能够代表关系的词汇建立概念类之间的关系，表示成能够代表业务知识结构的**类图**；\n- **业务流程**：一般由提交请求的角色及提供服务的对象所执行的活动（活动及任务节点）构成，活动的输出一般有数据对象和传给另一个活动的消息组成，建议使用UML的**活动图**进行描述。\n\n### 创建领域分析模型\n- 理解领域模型对理解系统需求至关重要，领域模型的创建步骤如下：\n  - 第1步，找出当前需求中的候选概念类；\n  - 第2步，在领域模型中描述这些概念类。用问题域中的词汇对概念类进行命名，将与当前需求无关的概念类排除在外。\n  - 第3步，在概念类之间添加必要的关联来记录那些需要保存记忆的关系，概念之间的关系用关联、继承、组合/聚合来表示。\n  - 第4步，构建UML类图\n  - 第5步，在概念类中添加用来实现需求的必要属性。\n- 对于一个领域分析模型，其中的关联一般分为两种：\n  - “需要知道”型关联：需要将概念之间的关系信息保持一段时间的关联。领域模型中需要着重考虑。\n  - “只需理解”型关联：有助于增强对领域中关键概念的理解的关联。\n-  寻找关联时要遵循下述指导原则：\n   - 将注意力集中在需要知道型关联。\n   - 识别概念类比识别关联更重要，因此领域模型创建过程中应该更加注重概念\n类的识别。\n   - 太多的关联不仅不能有效地表示领域模型，反而容易使领域模型变得混乱。\n   - 避免显示冗余或导出关联。\n此处给出一个医院挂号处模型进行参考\n![医院挂号处](/img/软件工程(2)/医院挂号处.png)\n\n### UML类图的组成\n- UML类图用于描述类以及类之间的关系。\n- 类包含三个部分：\n  - 类名：表示问题域中的概念，含义清晰准确\n  - 属性：可见性 属性名：类型名= 初始值 {性质串}\n  - 操作：可见性 操作名（参数表）：返回值类型 {性质串}\n- 类的关系有：\n  - 关联：普通关联、导航关联、递归关联\n  - 组合与聚合\n  - 依赖和继承\nUML类图中的一个单位，其结构如下图\n![UML类结构](/img/软件工程(2)/UML类结构.png)\n其中应该包含上面的属性和下面部分的方法内容 \n![UML类_属性](/img/软件工程(2)/UML类_属性.png)\n![UML类_方法](/img/软件工程(2)/UML类_方法.png)\n![UML类_类和接口](/img/软件工程(2)/UML类_类和接口.png)\n![UML类_继承和实现](/img/软件工程(2)/UML类_继承和实现.png)\n![UML类_关联和依赖](/img/软件工程(2)/UML类_关联和依赖.png)\n![UML类_组合和聚合](/img/软件工程(2)/UML类_组合和聚合.png)\n\n关系箭头总览如下图\n![关系箭头总览](/img/软件工程(2)/关系箭头总览.png)\n关联箭头总览\n![关联箭头总览](/img/软件工程(2)/关联箭头总览.png)\n\n下面给出几个关联图案例\n![油画关系图](/img/软件工程(2)/油画关系图.png)\n![自然界UML图](/img/软件工程(2)/自然界UML图.png)\n\n## 用例模型\n- 用例模型由以下四个部分组成：\n  - 用例图；\n  - 用例说明；\n  - 系统顺序图（system sequence diagram，option）；\n  - 操作契约（operation contract，option）;\n- 以用例为核心从使用者的角度描述和解释待构建系统的功能需求\n用例模型的基本结构图如下：\n![用例模型基本结构](/img/软件工程(2)/用例模型基本结构.png)\n\n- 用例图由三个基本元素组成\n  - Actor：称为角色或者参与者，表示使用系统的对象，代表角色的不一定是人，\n也可以是组织、系统或设备；\n  - Use_case：称为用例，描述角色如何使用系统功能实现需求目标的一组成功\n场景和一系列失败场景的集合；\n  - Association：表示角色与用例之间的关系，以及用例和子用例之间的关系；\n \n### 基本用例和子用例\n- 基本用例：与角色直接相关的用例，表示系统的功能需求；\n- 子用例：通过场景描述分析归纳出的用例，也表示了系统的功能，是基本用例的一个组成部分；\n  - 包含子用例：多个基本用例中的某个与角色交互的场景具有相同的操作，且这些场景都是基本用例中必须执行的步骤，可以将其抽取出来作为基本用例的子用例；\n    ![基本用例与子用例(1)](/img/软件工程(2)/基本用例与子用例(1).png)\n  - 扩展子用例：（多个）基本用例中的某些场景存在相同的条件判断的情况，可以将其抽取出作为基本用例的子用例；\n    ![基本用例与子用例(2)](/img/软件工程(2)/基本用例与子用例(2).png)\n\n### 关系类型及其说明以及表示符号\n![关系类型及其说明以及表示符号](/img/软件工程(2)/关系类型及其说明以及表示符号.png)\n\n### 系统顺序图\n- 使用UML的sequence diagram描述角色与系统之间的\n交互场景实例；\n- 在用例描述的基础上需进一步确定角色与系统之间的交互信息，并以可编程的方式将其命名；\n- 系统顺序图中“一般”只需要三个UML的符号元素\n  - 顺序图中的对象图标：<类名：对象名>\n  - 角色，类的特殊标识；\n  - 代表软件系统的对象，一般使用system或者系统命名；\n  - 角色与system之间的交互信息，简称消息或操作；\n    - 同步消息：请求必须有应答才能发送后续消息；\n    - 异步消息：无须等待消息应答就可发送其他消息；\n    - 创建消息：创建一个对象实例的消息，SSD中不需要；\n    - 删除消息：删除一个对象实例的消息。\n    ![系统顺序图(1)](/img/软件工程(2)/系统顺序图(1).png)\n    ![系统顺序图(2)](/img/软件工程(2)/系统顺序图(2).png)\n\n> 注意：\n> 1. SSD是用于替代用例说明文本的一种方式；\n> 2. 图中只有两个对象，表示角色对象与系统对象；\n> 3. 图中的消息名称及参数要求以可编程的方式命名；\n> 4. 消息名称和参数可以通过一个列表使用中文说明具体含义；\n> 5. 用例图中的每个用例都应该对应一张SSD；\n> 6. 角色发给系统的指令（系统事件）是操作契约关注的元素~\n\n- 系统操作：即角色发给系统对象的请求，也称为系统事件；\n- 操作契约：契约的含义表示该系统接收到该系统请求后，为了能够得到按照约定必须返回的结果，该系统内规定必须有哪些业务对象（参考领域模型中的概念类）必须被激活、关联（协同）并记录哪些必须持久保存的数据（概念类属性值的改变）。它是后续软件设计活动中确定软件对象的参考依据\n\n![操作契约](/img/软件工程(2)/操作契约.png)\n\n- 创建操作契约的指导原则如下： \n  - 根据系统顺序图识别进入到系统内的所有系统事件，即操作；\n  - 针对每一个系统操作结合对应的领域模型，找到与此操作相关的概念类；\n  - 定义概念类响应该操作的以下三项内容；\n    - 对象实例创建和删除；\n    - 对象关联形成和断开；\n    - 对象属性修改。\n  - 后置条件中至少有一项存在，该操作才有存在的必要性！\n  - 后置条件的陈述应该是声明性的，以强调系统状态所发生的变化，无需考虑如何设计和实现的。","source":"_posts/软件工程-2.md","raw":"---\ntitle: 软件工程(2)\ndate: 2024-10-23 22:57:52\ntags:\n    - 学习笔记\n---\n# 面向对象方法\n1. 对象\n   - 在软件工程中，一般存在三个对象：客观对象、问题对象和计算机对象\n   - 彼此之间的关系为 客观对象（抽象）$\\rightarrow$ 问题对象（封装）$\\leftrightarrow$ 计算机对象（模拟）\n   - 一个对象应该是具有状态、行为和标识符的实体，并且对象之间往往可以通过通信互相交互\n   - 对象具有下列4个性质：\n     - 自治性\n     - 封闭性\n     - 通信性\n     - 被动性\n\n2. 类\n    直接忽略吧，感觉都知道\n\n## UML\n### 定义\nUML是一中标准的图形化建模语言，它是面向对象分析与设计的一种标准标识\n- 它是一种**可视化的建模语言**，不是一种可视化的程序设计语言\n- 它是一种**建模语言规格说明**，不是工具或知识库的规格说明\n\n### 结构\n- 基本构造块 Basic building block\n  - 事物 Thing\n  - 关系 Relationship\n  - 图   Diagram\n- 语义规则 Rule\n  - name、scope、visibility、integrity、execution\n- 通用机制 Common mechanism\n  - specification、adornment（修饰）、common division、extensibility mechanism\n\n### 4+1图\n- UML用模型来描述系统的结构（静态特征）以及行为（动态特征）。从不同的视角为系统的架构建模，形成系统的不同视图（view），称为4+1图，**从一个需求的角度出发描述与系统设计的4个维度之间的关系**\n![UML视图](/img/软件工程(2)/UML视图.png)\n  - **用例视图：表示功能需求**，强调从用户的角度看到的或需要的系统功能。这种视图也叫做用户模型视图（user model view） 或场景视图（scenario view）\n  - 逻辑视图： 展现软件系统设计的静态结构的组成及特征，也称为结构模型视图（structural model view） 或静态视图（static view）\n  - 进程视图：描述软件系统设计的并发和同步等特性，**关注系统非功能性需求**，也称为行为模型视图（behavioral model view）、过程视图（process view）、 协作视图（collaborative view）和动态视图（dynamic view）\n  - 构件视图：关注软件代码的静态组织与管理，也称为实现模型视图（implementation \nmodel view ）和开发视图（development view）\n  - 部署视图：描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求（性能、可靠性等），也称为环境模型视图或物理视图（physical view）；\n\n### 9个基本图\n-  用例图（Use case diagram）：（从用户的角度）描述系统的功能；\n- 类图（Class diagram）：描述系统的静态结构（类及其相互关系）；\n- 对象图（Object diagram）： 描述系统在某个时刻的静态结构（对象及其相互关系）；\n- 顺序/序列图（Sequence diagram）：按时间顺序描述系统元素间的交互；\n- 协作图（Collaboration diagram）：按照时间和空间的顺序描述系统元素间的交互和它们之间\n的关系；\n- 状态图（State diagram）：描述了系统元素（对象）的状态条件和响应；\n- 活动图（Activity diagram）：描述了系统元素之间的活动；\n- 构件图（Component diagram）：描述了实现系统的元素（类或包）组织；\n- 部署图（Deployment diagram）：描述了环境元素的配置并把实现系统的元素映射到配置上\n![基本图分类(1)](/img/软件工程(2)/UML9个基本图(1).png)\n![基本图分类(2)](/img/软件工程(2)/UML9个基本图(2).png)\n\n值得注意的是，对于其中这些内容，在考题中往往是以其他视图的要求提出，所以UML视图与图之间的关系为：\n- **用例视图：使用用例图；**\n- **逻辑视图：使用类图、对象图，顺序图/协作图；**\n- 进程视图：使用状态图和活动图；\n- 构件视图：使用构件图；\n- 部署视图：使用部署图\n下面给出一些示例：\n- 用例图\n![用例图](/img/软件工程(2)/用例图.png)\n- 类图\n![类图](/img/软件工程(2)/类图.png)\n- 对象图\n![对象图](/img/软件工程(2)/对象图.png)\n- 组件/构件图\n![组件图](/img/软件工程(2)/组件图.png)\n- 部署图\n![部署图](/img/软件工程(2)/部署图.png)\n- 状态图\n![状态图](/img/软件工程(2)/状态图.png)\n- 活动图\n![活动图](/img/软件工程(2)/活动图.png)\n- 序列/顺序图\n![顺序图](/img/软件工程(2)/顺序图.png)\n- 协作图\n![协作图](/img/软件工程(2)/协作图.png)\n\n## 领域分析模型\n领域模型表示了需求分析阶段“当前系统”逻辑模型的静态结构。其针对某一特定领域内概念类或者对象的抽象可视化表示。\n领域模型主要用于概括地描述业务背景及重要的业务流程，帮助软件开发人员\n在短时间内尽快了解业务。\n- **业务背景**：可由用户需求说明书或者调研报告中具有代表业务概念或者业务对象的词汇获得，这些词汇可统称为“概念类”；并通过能够代表关系的词汇建立概念类之间的关系，表示成能够代表业务知识结构的**类图**；\n- **业务流程**：一般由提交请求的角色及提供服务的对象所执行的活动（活动及任务节点）构成，活动的输出一般有数据对象和传给另一个活动的消息组成，建议使用UML的**活动图**进行描述。\n\n### 创建领域分析模型\n- 理解领域模型对理解系统需求至关重要，领域模型的创建步骤如下：\n  - 第1步，找出当前需求中的候选概念类；\n  - 第2步，在领域模型中描述这些概念类。用问题域中的词汇对概念类进行命名，将与当前需求无关的概念类排除在外。\n  - 第3步，在概念类之间添加必要的关联来记录那些需要保存记忆的关系，概念之间的关系用关联、继承、组合/聚合来表示。\n  - 第4步，构建UML类图\n  - 第5步，在概念类中添加用来实现需求的必要属性。\n- 对于一个领域分析模型，其中的关联一般分为两种：\n  - “需要知道”型关联：需要将概念之间的关系信息保持一段时间的关联。领域模型中需要着重考虑。\n  - “只需理解”型关联：有助于增强对领域中关键概念的理解的关联。\n-  寻找关联时要遵循下述指导原则：\n   - 将注意力集中在需要知道型关联。\n   - 识别概念类比识别关联更重要，因此领域模型创建过程中应该更加注重概念\n类的识别。\n   - 太多的关联不仅不能有效地表示领域模型，反而容易使领域模型变得混乱。\n   - 避免显示冗余或导出关联。\n此处给出一个医院挂号处模型进行参考\n![医院挂号处](/img/软件工程(2)/医院挂号处.png)\n\n### UML类图的组成\n- UML类图用于描述类以及类之间的关系。\n- 类包含三个部分：\n  - 类名：表示问题域中的概念，含义清晰准确\n  - 属性：可见性 属性名：类型名= 初始值 {性质串}\n  - 操作：可见性 操作名（参数表）：返回值类型 {性质串}\n- 类的关系有：\n  - 关联：普通关联、导航关联、递归关联\n  - 组合与聚合\n  - 依赖和继承\nUML类图中的一个单位，其结构如下图\n![UML类结构](/img/软件工程(2)/UML类结构.png)\n其中应该包含上面的属性和下面部分的方法内容 \n![UML类_属性](/img/软件工程(2)/UML类_属性.png)\n![UML类_方法](/img/软件工程(2)/UML类_方法.png)\n![UML类_类和接口](/img/软件工程(2)/UML类_类和接口.png)\n![UML类_继承和实现](/img/软件工程(2)/UML类_继承和实现.png)\n![UML类_关联和依赖](/img/软件工程(2)/UML类_关联和依赖.png)\n![UML类_组合和聚合](/img/软件工程(2)/UML类_组合和聚合.png)\n\n关系箭头总览如下图\n![关系箭头总览](/img/软件工程(2)/关系箭头总览.png)\n关联箭头总览\n![关联箭头总览](/img/软件工程(2)/关联箭头总览.png)\n\n下面给出几个关联图案例\n![油画关系图](/img/软件工程(2)/油画关系图.png)\n![自然界UML图](/img/软件工程(2)/自然界UML图.png)\n\n## 用例模型\n- 用例模型由以下四个部分组成：\n  - 用例图；\n  - 用例说明；\n  - 系统顺序图（system sequence diagram，option）；\n  - 操作契约（operation contract，option）;\n- 以用例为核心从使用者的角度描述和解释待构建系统的功能需求\n用例模型的基本结构图如下：\n![用例模型基本结构](/img/软件工程(2)/用例模型基本结构.png)\n\n- 用例图由三个基本元素组成\n  - Actor：称为角色或者参与者，表示使用系统的对象，代表角色的不一定是人，\n也可以是组织、系统或设备；\n  - Use_case：称为用例，描述角色如何使用系统功能实现需求目标的一组成功\n场景和一系列失败场景的集合；\n  - Association：表示角色与用例之间的关系，以及用例和子用例之间的关系；\n \n### 基本用例和子用例\n- 基本用例：与角色直接相关的用例，表示系统的功能需求；\n- 子用例：通过场景描述分析归纳出的用例，也表示了系统的功能，是基本用例的一个组成部分；\n  - 包含子用例：多个基本用例中的某个与角色交互的场景具有相同的操作，且这些场景都是基本用例中必须执行的步骤，可以将其抽取出来作为基本用例的子用例；\n    ![基本用例与子用例(1)](/img/软件工程(2)/基本用例与子用例(1).png)\n  - 扩展子用例：（多个）基本用例中的某些场景存在相同的条件判断的情况，可以将其抽取出作为基本用例的子用例；\n    ![基本用例与子用例(2)](/img/软件工程(2)/基本用例与子用例(2).png)\n\n### 关系类型及其说明以及表示符号\n![关系类型及其说明以及表示符号](/img/软件工程(2)/关系类型及其说明以及表示符号.png)\n\n### 系统顺序图\n- 使用UML的sequence diagram描述角色与系统之间的\n交互场景实例；\n- 在用例描述的基础上需进一步确定角色与系统之间的交互信息，并以可编程的方式将其命名；\n- 系统顺序图中“一般”只需要三个UML的符号元素\n  - 顺序图中的对象图标：<类名：对象名>\n  - 角色，类的特殊标识；\n  - 代表软件系统的对象，一般使用system或者系统命名；\n  - 角色与system之间的交互信息，简称消息或操作；\n    - 同步消息：请求必须有应答才能发送后续消息；\n    - 异步消息：无须等待消息应答就可发送其他消息；\n    - 创建消息：创建一个对象实例的消息，SSD中不需要；\n    - 删除消息：删除一个对象实例的消息。\n    ![系统顺序图(1)](/img/软件工程(2)/系统顺序图(1).png)\n    ![系统顺序图(2)](/img/软件工程(2)/系统顺序图(2).png)\n\n> 注意：\n> 1. SSD是用于替代用例说明文本的一种方式；\n> 2. 图中只有两个对象，表示角色对象与系统对象；\n> 3. 图中的消息名称及参数要求以可编程的方式命名；\n> 4. 消息名称和参数可以通过一个列表使用中文说明具体含义；\n> 5. 用例图中的每个用例都应该对应一张SSD；\n> 6. 角色发给系统的指令（系统事件）是操作契约关注的元素~\n\n- 系统操作：即角色发给系统对象的请求，也称为系统事件；\n- 操作契约：契约的含义表示该系统接收到该系统请求后，为了能够得到按照约定必须返回的结果，该系统内规定必须有哪些业务对象（参考领域模型中的概念类）必须被激活、关联（协同）并记录哪些必须持久保存的数据（概念类属性值的改变）。它是后续软件设计活动中确定软件对象的参考依据\n\n![操作契约](/img/软件工程(2)/操作契约.png)\n\n- 创建操作契约的指导原则如下： \n  - 根据系统顺序图识别进入到系统内的所有系统事件，即操作；\n  - 针对每一个系统操作结合对应的领域模型，找到与此操作相关的概念类；\n  - 定义概念类响应该操作的以下三项内容；\n    - 对象实例创建和删除；\n    - 对象关联形成和断开；\n    - 对象属性修改。\n  - 后置条件中至少有一项存在，该操作才有存在的必要性！\n  - 后置条件的陈述应该是声明性的，以强调系统状态所发生的变化，无需考虑如何设计和实现的。","slug":"软件工程-2","published":1,"updated":"2024-12-20T04:27:29.410Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot8000n6d6egklaaaem","content":"<h1 id=\"面向对象方法\"><a href=\"#面向对象方法\" class=\"headerlink\" title=\"面向对象方法\"></a>面向对象方法</h1><ol>\n<li><p>对象</p>\n<ul>\n<li>在软件工程中，一般存在三个对象：客观对象、问题对象和计算机对象</li>\n<li>彼此之间的关系为 客观对象（抽象）$\\rightarrow$ 问题对象（封装）$\\leftrightarrow$ 计算机对象（模拟）</li>\n<li>一个对象应该是具有状态、行为和标识符的实体，并且对象之间往往可以通过通信互相交互</li>\n<li>对象具有下列4个性质：<ul>\n<li>自治性</li>\n<li>封闭性</li>\n<li>通信性</li>\n<li>被动性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>类<br> 直接忽略吧，感觉都知道</p>\n</li>\n</ol>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>UML是一中标准的图形化建模语言，它是面向对象分析与设计的一种标准标识</p>\n<ul>\n<li>它是一种<strong>可视化的建模语言</strong>，不是一种可视化的程序设计语言</li>\n<li>它是一种<strong>建模语言规格说明</strong>，不是工具或知识库的规格说明</li>\n</ul>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><ul>\n<li>基本构造块 Basic building block<ul>\n<li>事物 Thing</li>\n<li>关系 Relationship</li>\n<li>图   Diagram</li>\n</ul>\n</li>\n<li>语义规则 Rule<ul>\n<li>name、scope、visibility、integrity、execution</li>\n</ul>\n</li>\n<li>通用机制 Common mechanism<ul>\n<li>specification、adornment（修饰）、common division、extensibility mechanism</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-1图\"><a href=\"#4-1图\" class=\"headerlink\" title=\"4+1图\"></a>4+1图</h3><ul>\n<li>UML用模型来描述系统的结构（静态特征）以及行为（动态特征）。从不同的视角为系统的架构建模，形成系统的不同视图（view），称为4+1图，<strong>从一个需求的角度出发描述与系统设计的4个维度之间的关系</strong><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E8%A7%86%E5%9B%BE.png\" alt=\"UML视图\"><ul>\n<li><strong>用例视图：表示功能需求</strong>，强调从用户的角度看到的或需要的系统功能。这种视图也叫做用户模型视图（user model view） 或场景视图（scenario view）</li>\n<li>逻辑视图： 展现软件系统设计的静态结构的组成及特征，也称为结构模型视图（structural model view） 或静态视图（static view）</li>\n<li>进程视图：描述软件系统设计的并发和同步等特性，<strong>关注系统非功能性需求</strong>，也称为行为模型视图（behavioral model view）、过程视图（process view）、 协作视图（collaborative view）和动态视图（dynamic view）</li>\n<li>构件视图：关注软件代码的静态组织与管理，也称为实现模型视图（implementation<br>model view ）和开发视图（development view）</li>\n<li>部署视图：描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求（性能、可靠性等），也称为环境模型视图或物理视图（physical view）；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"9个基本图\"><a href=\"#9个基本图\" class=\"headerlink\" title=\"9个基本图\"></a>9个基本图</h3><ul>\n<li>用例图（Use case diagram）：（从用户的角度）描述系统的功能；</li>\n<li>类图（Class diagram）：描述系统的静态结构（类及其相互关系）；</li>\n<li>对象图（Object diagram）： 描述系统在某个时刻的静态结构（对象及其相互关系）；</li>\n<li>顺序&#x2F;序列图（Sequence diagram）：按时间顺序描述系统元素间的交互；</li>\n<li>协作图（Collaboration diagram）：按照时间和空间的顺序描述系统元素间的交互和它们之间<br>的关系；</li>\n<li>状态图（State diagram）：描述了系统元素（对象）的状态条件和响应；</li>\n<li>活动图（Activity diagram）：描述了系统元素之间的活动；</li>\n<li>构件图（Component diagram）：描述了实现系统的元素（类或包）组织；</li>\n<li>部署图（Deployment diagram）：描述了环境元素的配置并把实现系统的元素映射到配置上<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML9%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%9B%BE(1).png\" alt=\"基本图分类(1)\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML9%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%9B%BE(2).png\" alt=\"基本图分类(2)\"></li>\n</ul>\n<p>值得注意的是，对于其中这些内容，在考题中往往是以其他视图的要求提出，所以UML视图与图之间的关系为：</p>\n<ul>\n<li><strong>用例视图：使用用例图；</strong></li>\n<li><strong>逻辑视图：使用类图、对象图，顺序图&#x2F;协作图；</strong></li>\n<li>进程视图：使用状态图和活动图；</li>\n<li>构件视图：使用构件图；</li>\n<li>部署视图：使用部署图<br>下面给出一些示例：</li>\n<li>用例图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%94%A8%E4%BE%8B%E5%9B%BE.png\" alt=\"用例图\"></li>\n<li>类图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%B1%BB%E5%9B%BE.png\" alt=\"类图\"></li>\n<li>对象图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%AF%B9%E8%B1%A1%E5%9B%BE.png\" alt=\"对象图\"></li>\n<li>组件&#x2F;构件图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%BB%84%E4%BB%B6%E5%9B%BE.png\" alt=\"组件图\"></li>\n<li>部署图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E9%83%A8%E7%BD%B2%E5%9B%BE.png\" alt=\"部署图\"></li>\n<li>状态图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%8A%B6%E6%80%81%E5%9B%BE.png\" alt=\"状态图\"></li>\n<li>活动图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E6%B4%BB%E5%8A%A8%E5%9B%BE.png\" alt=\"活动图\"></li>\n<li>序列&#x2F;顺序图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E9%A1%BA%E5%BA%8F%E5%9B%BE.png\" alt=\"顺序图\"></li>\n<li>协作图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%8D%8F%E4%BD%9C%E5%9B%BE.png\" alt=\"协作图\"></li>\n</ul>\n<h2 id=\"领域分析模型\"><a href=\"#领域分析模型\" class=\"headerlink\" title=\"领域分析模型\"></a>领域分析模型</h2><p>领域模型表示了需求分析阶段“当前系统”逻辑模型的静态结构。其针对某一特定领域内概念类或者对象的抽象可视化表示。<br>领域模型主要用于概括地描述业务背景及重要的业务流程，帮助软件开发人员<br>在短时间内尽快了解业务。</p>\n<ul>\n<li><strong>业务背景</strong>：可由用户需求说明书或者调研报告中具有代表业务概念或者业务对象的词汇获得，这些词汇可统称为“概念类”；并通过能够代表关系的词汇建立概念类之间的关系，表示成能够代表业务知识结构的<strong>类图</strong>；</li>\n<li><strong>业务流程</strong>：一般由提交请求的角色及提供服务的对象所执行的活动（活动及任务节点）构成，活动的输出一般有数据对象和传给另一个活动的消息组成，建议使用UML的<strong>活动图</strong>进行描述。</li>\n</ul>\n<h3 id=\"创建领域分析模型\"><a href=\"#创建领域分析模型\" class=\"headerlink\" title=\"创建领域分析模型\"></a>创建领域分析模型</h3><ul>\n<li>理解领域模型对理解系统需求至关重要，领域模型的创建步骤如下：<ul>\n<li>第1步，找出当前需求中的候选概念类；</li>\n<li>第2步，在领域模型中描述这些概念类。用问题域中的词汇对概念类进行命名，将与当前需求无关的概念类排除在外。</li>\n<li>第3步，在概念类之间添加必要的关联来记录那些需要保存记忆的关系，概念之间的关系用关联、继承、组合&#x2F;聚合来表示。</li>\n<li>第4步，构建UML类图</li>\n<li>第5步，在概念类中添加用来实现需求的必要属性。</li>\n</ul>\n</li>\n<li>对于一个领域分析模型，其中的关联一般分为两种：<ul>\n<li>“需要知道”型关联：需要将概念之间的关系信息保持一段时间的关联。领域模型中需要着重考虑。</li>\n<li>“只需理解”型关联：有助于增强对领域中关键概念的理解的关联。</li>\n</ul>\n</li>\n<li>寻找关联时要遵循下述指导原则：<ul>\n<li>将注意力集中在需要知道型关联。</li>\n<li>识别概念类比识别关联更重要，因此领域模型创建过程中应该更加注重概念<br>类的识别。</li>\n<li>太多的关联不仅不能有效地表示领域模型，反而容易使领域模型变得混乱。</li>\n<li>避免显示冗余或导出关联。<br>此处给出一个医院挂号处模型进行参考<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%8C%BB%E9%99%A2%E6%8C%82%E5%8F%B7%E5%A4%84.png\" alt=\"医院挂号处\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"UML类图的组成\"><a href=\"#UML类图的组成\" class=\"headerlink\" title=\"UML类图的组成\"></a>UML类图的组成</h3><ul>\n<li>UML类图用于描述类以及类之间的关系。</li>\n<li>类包含三个部分：<ul>\n<li>类名：表示问题域中的概念，含义清晰准确</li>\n<li>属性：可见性 属性名：类型名&#x3D; 初始值 {性质串}</li>\n<li>操作：可见性 操作名（参数表）：返回值类型 {性质串}</li>\n</ul>\n</li>\n<li>类的关系有：<ul>\n<li>关联：普通关联、导航关联、递归关联</li>\n<li>组合与聚合</li>\n<li>依赖和继承<br>UML类图中的一个单位，其结构如下图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB%E7%BB%93%E6%9E%84.png\" alt=\"UML类结构\"><br>其中应该包含上面的属性和下面部分的方法内容<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E5%B1%9E%E6%80%A7.png\" alt=\"UML类_属性\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E6%96%B9%E6%B3%95.png\" alt=\"UML类_方法\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3.png\" alt=\"UML类_类和接口\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0.png\" alt=\"UML类_继承和实现\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E5%85%B3%E8%81%94%E5%92%8C%E4%BE%9D%E8%B5%96.png\" alt=\"UML类_关联和依赖\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E7%BB%84%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88.png\" alt=\"UML类_组合和聚合\"></li>\n</ul>\n</li>\n</ul>\n<p>关系箭头总览如下图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%85%B3%E7%B3%BB%E7%AE%AD%E5%A4%B4%E6%80%BB%E8%A7%88.png\" alt=\"关系箭头总览\"><br>关联箭头总览<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%85%B3%E8%81%94%E7%AE%AD%E5%A4%B4%E6%80%BB%E8%A7%88.png\" alt=\"关联箭头总览\"></p>\n<p>下面给出几个关联图案例<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E6%B2%B9%E7%94%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"油画关系图\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E8%87%AA%E7%84%B6%E7%95%8CUML%E5%9B%BE.png\" alt=\"自然界UML图\"></p>\n<h2 id=\"用例模型\"><a href=\"#用例模型\" class=\"headerlink\" title=\"用例模型\"></a>用例模型</h2><ul>\n<li><p>用例模型由以下四个部分组成：</p>\n<ul>\n<li>用例图；</li>\n<li>用例说明；</li>\n<li>系统顺序图（system sequence diagram，option）；</li>\n<li>操作契约（operation contract，option）;</li>\n</ul>\n</li>\n<li><p>以用例为核心从使用者的角度描述和解释待构建系统的功能需求<br>用例模型的基本结构图如下：<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%94%A8%E4%BE%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png\" alt=\"用例模型基本结构\"></p>\n</li>\n<li><p>用例图由三个基本元素组成</p>\n<ul>\n<li>Actor：称为角色或者参与者，表示使用系统的对象，代表角色的不一定是人，<br>也可以是组织、系统或设备；</li>\n<li>Use_case：称为用例，描述角色如何使用系统功能实现需求目标的一组成功<br>场景和一系列失败场景的集合；</li>\n<li>Association：表示角色与用例之间的关系，以及用例和子用例之间的关系；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基本用例和子用例\"><a href=\"#基本用例和子用例\" class=\"headerlink\" title=\"基本用例和子用例\"></a>基本用例和子用例</h3><ul>\n<li>基本用例：与角色直接相关的用例，表示系统的功能需求；</li>\n<li>子用例：通过场景描述分析归纳出的用例，也表示了系统的功能，是基本用例的一个组成部分；<ul>\n<li>包含子用例：多个基本用例中的某个与角色交互的场景具有相同的操作，且这些场景都是基本用例中必须执行的步骤，可以将其抽取出来作为基本用例的子用例；<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%9F%BA%E6%9C%AC%E7%94%A8%E4%BE%8B%E4%B8%8E%E5%AD%90%E7%94%A8%E4%BE%8B(1).png\" alt=\"基本用例与子用例(1)\"></li>\n<li>扩展子用例：（多个）基本用例中的某些场景存在相同的条件判断的情况，可以将其抽取出作为基本用例的子用例；<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%9F%BA%E6%9C%AC%E7%94%A8%E4%BE%8B%E4%B8%8E%E5%AD%90%E7%94%A8%E4%BE%8B(2).png\" alt=\"基本用例与子用例(2)\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关系类型及其说明以及表示符号\"><a href=\"#关系类型及其说明以及表示符号\" class=\"headerlink\" title=\"关系类型及其说明以及表示符号\"></a>关系类型及其说明以及表示符号</h3><p><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%85%B3%E7%B3%BB%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E8%AF%B4%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%A1%A8%E7%A4%BA%E7%AC%A6%E5%8F%B7.png\" alt=\"关系类型及其说明以及表示符号\"></p>\n<h3 id=\"系统顺序图\"><a href=\"#系统顺序图\" class=\"headerlink\" title=\"系统顺序图\"></a>系统顺序图</h3><ul>\n<li>使用UML的sequence diagram描述角色与系统之间的<br>交互场景实例；</li>\n<li>在用例描述的基础上需进一步确定角色与系统之间的交互信息，并以可编程的方式将其命名；</li>\n<li>系统顺序图中“一般”只需要三个UML的符号元素<ul>\n<li>顺序图中的对象图标：&lt;类名：对象名&gt;</li>\n<li>角色，类的特殊标识；</li>\n<li>代表软件系统的对象，一般使用system或者系统命名；</li>\n<li>角色与system之间的交互信息，简称消息或操作；<ul>\n<li>同步消息：请求必须有应答才能发送后续消息；</li>\n<li>异步消息：无须等待消息应答就可发送其他消息；</li>\n<li>创建消息：创建一个对象实例的消息，SSD中不需要；</li>\n<li>删除消息：删除一个对象实例的消息。<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%B3%BB%E7%BB%9F%E9%A1%BA%E5%BA%8F%E5%9B%BE(1).png\" alt=\"系统顺序图(1)\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%B3%BB%E7%BB%9F%E9%A1%BA%E5%BA%8F%E5%9B%BE(2).png\" alt=\"系统顺序图(2)\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>SSD是用于替代用例说明文本的一种方式；</li>\n<li>图中只有两个对象，表示角色对象与系统对象；</li>\n<li>图中的消息名称及参数要求以可编程的方式命名；</li>\n<li>消息名称和参数可以通过一个列表使用中文说明具体含义；</li>\n<li>用例图中的每个用例都应该对应一张SSD；</li>\n<li>角色发给系统的指令（系统事件）是操作契约关注的元素~</li>\n</ol>\n</blockquote>\n<ul>\n<li>系统操作：即角色发给系统对象的请求，也称为系统事件；</li>\n<li>操作契约：契约的含义表示该系统接收到该系统请求后，为了能够得到按照约定必须返回的结果，该系统内规定必须有哪些业务对象（参考领域模型中的概念类）必须被激活、关联（协同）并记录哪些必须持久保存的数据（概念类属性值的改变）。它是后续软件设计活动中确定软件对象的参考依据</li>\n</ul>\n<p><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E6%93%8D%E4%BD%9C%E5%A5%91%E7%BA%A6.png\" alt=\"操作契约\"></p>\n<ul>\n<li>创建操作契约的指导原则如下： <ul>\n<li>根据系统顺序图识别进入到系统内的所有系统事件，即操作；</li>\n<li>针对每一个系统操作结合对应的领域模型，找到与此操作相关的概念类；</li>\n<li>定义概念类响应该操作的以下三项内容；<ul>\n<li>对象实例创建和删除；</li>\n<li>对象关联形成和断开；</li>\n<li>对象属性修改。</li>\n</ul>\n</li>\n<li>后置条件中至少有一项存在，该操作才有存在的必要性！</li>\n<li>后置条件的陈述应该是声明性的，以强调系统状态所发生的变化，无需考虑如何设计和实现的。</li>\n</ul>\n</li>\n</ul>\n","excerpt":"","more":"<h1 id=\"面向对象方法\"><a href=\"#面向对象方法\" class=\"headerlink\" title=\"面向对象方法\"></a>面向对象方法</h1><ol>\n<li><p>对象</p>\n<ul>\n<li>在软件工程中，一般存在三个对象：客观对象、问题对象和计算机对象</li>\n<li>彼此之间的关系为 客观对象（抽象）$\\rightarrow$ 问题对象（封装）$\\leftrightarrow$ 计算机对象（模拟）</li>\n<li>一个对象应该是具有状态、行为和标识符的实体，并且对象之间往往可以通过通信互相交互</li>\n<li>对象具有下列4个性质：<ul>\n<li>自治性</li>\n<li>封闭性</li>\n<li>通信性</li>\n<li>被动性</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>类<br> 直接忽略吧，感觉都知道</p>\n</li>\n</ol>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>UML是一中标准的图形化建模语言，它是面向对象分析与设计的一种标准标识</p>\n<ul>\n<li>它是一种<strong>可视化的建模语言</strong>，不是一种可视化的程序设计语言</li>\n<li>它是一种<strong>建模语言规格说明</strong>，不是工具或知识库的规格说明</li>\n</ul>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><ul>\n<li>基本构造块 Basic building block<ul>\n<li>事物 Thing</li>\n<li>关系 Relationship</li>\n<li>图   Diagram</li>\n</ul>\n</li>\n<li>语义规则 Rule<ul>\n<li>name、scope、visibility、integrity、execution</li>\n</ul>\n</li>\n<li>通用机制 Common mechanism<ul>\n<li>specification、adornment（修饰）、common division、extensibility mechanism</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-1图\"><a href=\"#4-1图\" class=\"headerlink\" title=\"4+1图\"></a>4+1图</h3><ul>\n<li>UML用模型来描述系统的结构（静态特征）以及行为（动态特征）。从不同的视角为系统的架构建模，形成系统的不同视图（view），称为4+1图，<strong>从一个需求的角度出发描述与系统设计的4个维度之间的关系</strong><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E8%A7%86%E5%9B%BE.png\" alt=\"UML视图\"><ul>\n<li><strong>用例视图：表示功能需求</strong>，强调从用户的角度看到的或需要的系统功能。这种视图也叫做用户模型视图（user model view） 或场景视图（scenario view）</li>\n<li>逻辑视图： 展现软件系统设计的静态结构的组成及特征，也称为结构模型视图（structural model view） 或静态视图（static view）</li>\n<li>进程视图：描述软件系统设计的并发和同步等特性，<strong>关注系统非功能性需求</strong>，也称为行为模型视图（behavioral model view）、过程视图（process view）、 协作视图（collaborative view）和动态视图（dynamic view）</li>\n<li>构件视图：关注软件代码的静态组织与管理，也称为实现模型视图（implementation<br>model view ）和开发视图（development view）</li>\n<li>部署视图：描述硬件的拓扑结构以及软件和硬件的映射问题，关注系统非功能性需求（性能、可靠性等），也称为环境模型视图或物理视图（physical view）；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"9个基本图\"><a href=\"#9个基本图\" class=\"headerlink\" title=\"9个基本图\"></a>9个基本图</h3><ul>\n<li>用例图（Use case diagram）：（从用户的角度）描述系统的功能；</li>\n<li>类图（Class diagram）：描述系统的静态结构（类及其相互关系）；</li>\n<li>对象图（Object diagram）： 描述系统在某个时刻的静态结构（对象及其相互关系）；</li>\n<li>顺序&#x2F;序列图（Sequence diagram）：按时间顺序描述系统元素间的交互；</li>\n<li>协作图（Collaboration diagram）：按照时间和空间的顺序描述系统元素间的交互和它们之间<br>的关系；</li>\n<li>状态图（State diagram）：描述了系统元素（对象）的状态条件和响应；</li>\n<li>活动图（Activity diagram）：描述了系统元素之间的活动；</li>\n<li>构件图（Component diagram）：描述了实现系统的元素（类或包）组织；</li>\n<li>部署图（Deployment diagram）：描述了环境元素的配置并把实现系统的元素映射到配置上<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML9%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%9B%BE(1).png\" alt=\"基本图分类(1)\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML9%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%9B%BE(2).png\" alt=\"基本图分类(2)\"></li>\n</ul>\n<p>值得注意的是，对于其中这些内容，在考题中往往是以其他视图的要求提出，所以UML视图与图之间的关系为：</p>\n<ul>\n<li><strong>用例视图：使用用例图；</strong></li>\n<li><strong>逻辑视图：使用类图、对象图，顺序图&#x2F;协作图；</strong></li>\n<li>进程视图：使用状态图和活动图；</li>\n<li>构件视图：使用构件图；</li>\n<li>部署视图：使用部署图<br>下面给出一些示例：</li>\n<li>用例图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%94%A8%E4%BE%8B%E5%9B%BE.png\" alt=\"用例图\"></li>\n<li>类图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%B1%BB%E5%9B%BE.png\" alt=\"类图\"></li>\n<li>对象图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%AF%B9%E8%B1%A1%E5%9B%BE.png\" alt=\"对象图\"></li>\n<li>组件&#x2F;构件图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%BB%84%E4%BB%B6%E5%9B%BE.png\" alt=\"组件图\"></li>\n<li>部署图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E9%83%A8%E7%BD%B2%E5%9B%BE.png\" alt=\"部署图\"></li>\n<li>状态图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%8A%B6%E6%80%81%E5%9B%BE.png\" alt=\"状态图\"></li>\n<li>活动图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E6%B4%BB%E5%8A%A8%E5%9B%BE.png\" alt=\"活动图\"></li>\n<li>序列&#x2F;顺序图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E9%A1%BA%E5%BA%8F%E5%9B%BE.png\" alt=\"顺序图\"></li>\n<li>协作图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%8D%8F%E4%BD%9C%E5%9B%BE.png\" alt=\"协作图\"></li>\n</ul>\n<h2 id=\"领域分析模型\"><a href=\"#领域分析模型\" class=\"headerlink\" title=\"领域分析模型\"></a>领域分析模型</h2><p>领域模型表示了需求分析阶段“当前系统”逻辑模型的静态结构。其针对某一特定领域内概念类或者对象的抽象可视化表示。<br>领域模型主要用于概括地描述业务背景及重要的业务流程，帮助软件开发人员<br>在短时间内尽快了解业务。</p>\n<ul>\n<li><strong>业务背景</strong>：可由用户需求说明书或者调研报告中具有代表业务概念或者业务对象的词汇获得，这些词汇可统称为“概念类”；并通过能够代表关系的词汇建立概念类之间的关系，表示成能够代表业务知识结构的<strong>类图</strong>；</li>\n<li><strong>业务流程</strong>：一般由提交请求的角色及提供服务的对象所执行的活动（活动及任务节点）构成，活动的输出一般有数据对象和传给另一个活动的消息组成，建议使用UML的<strong>活动图</strong>进行描述。</li>\n</ul>\n<h3 id=\"创建领域分析模型\"><a href=\"#创建领域分析模型\" class=\"headerlink\" title=\"创建领域分析模型\"></a>创建领域分析模型</h3><ul>\n<li>理解领域模型对理解系统需求至关重要，领域模型的创建步骤如下：<ul>\n<li>第1步，找出当前需求中的候选概念类；</li>\n<li>第2步，在领域模型中描述这些概念类。用问题域中的词汇对概念类进行命名，将与当前需求无关的概念类排除在外。</li>\n<li>第3步，在概念类之间添加必要的关联来记录那些需要保存记忆的关系，概念之间的关系用关联、继承、组合&#x2F;聚合来表示。</li>\n<li>第4步，构建UML类图</li>\n<li>第5步，在概念类中添加用来实现需求的必要属性。</li>\n</ul>\n</li>\n<li>对于一个领域分析模型，其中的关联一般分为两种：<ul>\n<li>“需要知道”型关联：需要将概念之间的关系信息保持一段时间的关联。领域模型中需要着重考虑。</li>\n<li>“只需理解”型关联：有助于增强对领域中关键概念的理解的关联。</li>\n</ul>\n</li>\n<li>寻找关联时要遵循下述指导原则：<ul>\n<li>将注意力集中在需要知道型关联。</li>\n<li>识别概念类比识别关联更重要，因此领域模型创建过程中应该更加注重概念<br>类的识别。</li>\n<li>太多的关联不仅不能有效地表示领域模型，反而容易使领域模型变得混乱。</li>\n<li>避免显示冗余或导出关联。<br>此处给出一个医院挂号处模型进行参考<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%8C%BB%E9%99%A2%E6%8C%82%E5%8F%B7%E5%A4%84.png\" alt=\"医院挂号处\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"UML类图的组成\"><a href=\"#UML类图的组成\" class=\"headerlink\" title=\"UML类图的组成\"></a>UML类图的组成</h3><ul>\n<li>UML类图用于描述类以及类之间的关系。</li>\n<li>类包含三个部分：<ul>\n<li>类名：表示问题域中的概念，含义清晰准确</li>\n<li>属性：可见性 属性名：类型名&#x3D; 初始值 {性质串}</li>\n<li>操作：可见性 操作名（参数表）：返回值类型 {性质串}</li>\n</ul>\n</li>\n<li>类的关系有：<ul>\n<li>关联：普通关联、导航关联、递归关联</li>\n<li>组合与聚合</li>\n<li>依赖和继承<br>UML类图中的一个单位，其结构如下图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB%E7%BB%93%E6%9E%84.png\" alt=\"UML类结构\"><br>其中应该包含上面的属性和下面部分的方法内容<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E5%B1%9E%E6%80%A7.png\" alt=\"UML类_属性\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E6%96%B9%E6%B3%95.png\" alt=\"UML类_方法\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3.png\" alt=\"UML类_类和接口\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0.png\" alt=\"UML类_继承和实现\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E5%85%B3%E8%81%94%E5%92%8C%E4%BE%9D%E8%B5%96.png\" alt=\"UML类_关联和依赖\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/UML%E7%B1%BB_%E7%BB%84%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88.png\" alt=\"UML类_组合和聚合\"></li>\n</ul>\n</li>\n</ul>\n<p>关系箭头总览如下图<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%85%B3%E7%B3%BB%E7%AE%AD%E5%A4%B4%E6%80%BB%E8%A7%88.png\" alt=\"关系箭头总览\"><br>关联箭头总览<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%85%B3%E8%81%94%E7%AE%AD%E5%A4%B4%E6%80%BB%E8%A7%88.png\" alt=\"关联箭头总览\"></p>\n<p>下面给出几个关联图案例<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E6%B2%B9%E7%94%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png\" alt=\"油画关系图\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E8%87%AA%E7%84%B6%E7%95%8CUML%E5%9B%BE.png\" alt=\"自然界UML图\"></p>\n<h2 id=\"用例模型\"><a href=\"#用例模型\" class=\"headerlink\" title=\"用例模型\"></a>用例模型</h2><ul>\n<li><p>用例模型由以下四个部分组成：</p>\n<ul>\n<li>用例图；</li>\n<li>用例说明；</li>\n<li>系统顺序图（system sequence diagram，option）；</li>\n<li>操作契约（operation contract，option）;</li>\n</ul>\n</li>\n<li><p>以用例为核心从使用者的角度描述和解释待构建系统的功能需求<br>用例模型的基本结构图如下：<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%94%A8%E4%BE%8B%E6%A8%A1%E5%9E%8B%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.png\" alt=\"用例模型基本结构\"></p>\n</li>\n<li><p>用例图由三个基本元素组成</p>\n<ul>\n<li>Actor：称为角色或者参与者，表示使用系统的对象，代表角色的不一定是人，<br>也可以是组织、系统或设备；</li>\n<li>Use_case：称为用例，描述角色如何使用系统功能实现需求目标的一组成功<br>场景和一系列失败场景的集合；</li>\n<li>Association：表示角色与用例之间的关系，以及用例和子用例之间的关系；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基本用例和子用例\"><a href=\"#基本用例和子用例\" class=\"headerlink\" title=\"基本用例和子用例\"></a>基本用例和子用例</h3><ul>\n<li>基本用例：与角色直接相关的用例，表示系统的功能需求；</li>\n<li>子用例：通过场景描述分析归纳出的用例，也表示了系统的功能，是基本用例的一个组成部分；<ul>\n<li>包含子用例：多个基本用例中的某个与角色交互的场景具有相同的操作，且这些场景都是基本用例中必须执行的步骤，可以将其抽取出来作为基本用例的子用例；<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%9F%BA%E6%9C%AC%E7%94%A8%E4%BE%8B%E4%B8%8E%E5%AD%90%E7%94%A8%E4%BE%8B(1).png\" alt=\"基本用例与子用例(1)\"></li>\n<li>扩展子用例：（多个）基本用例中的某些场景存在相同的条件判断的情况，可以将其抽取出作为基本用例的子用例；<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%9F%BA%E6%9C%AC%E7%94%A8%E4%BE%8B%E4%B8%8E%E5%AD%90%E7%94%A8%E4%BE%8B(2).png\" alt=\"基本用例与子用例(2)\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"关系类型及其说明以及表示符号\"><a href=\"#关系类型及其说明以及表示符号\" class=\"headerlink\" title=\"关系类型及其说明以及表示符号\"></a>关系类型及其说明以及表示符号</h3><p><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E5%85%B3%E7%B3%BB%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E8%AF%B4%E6%98%8E%E4%BB%A5%E5%8F%8A%E8%A1%A8%E7%A4%BA%E7%AC%A6%E5%8F%B7.png\" alt=\"关系类型及其说明以及表示符号\"></p>\n<h3 id=\"系统顺序图\"><a href=\"#系统顺序图\" class=\"headerlink\" title=\"系统顺序图\"></a>系统顺序图</h3><ul>\n<li>使用UML的sequence diagram描述角色与系统之间的<br>交互场景实例；</li>\n<li>在用例描述的基础上需进一步确定角色与系统之间的交互信息，并以可编程的方式将其命名；</li>\n<li>系统顺序图中“一般”只需要三个UML的符号元素<ul>\n<li>顺序图中的对象图标：&lt;类名：对象名&gt;</li>\n<li>角色，类的特殊标识；</li>\n<li>代表软件系统的对象，一般使用system或者系统命名；</li>\n<li>角色与system之间的交互信息，简称消息或操作；<ul>\n<li>同步消息：请求必须有应答才能发送后续消息；</li>\n<li>异步消息：无须等待消息应答就可发送其他消息；</li>\n<li>创建消息：创建一个对象实例的消息，SSD中不需要；</li>\n<li>删除消息：删除一个对象实例的消息。<br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%B3%BB%E7%BB%9F%E9%A1%BA%E5%BA%8F%E5%9B%BE(1).png\" alt=\"系统顺序图(1)\"><br><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E7%B3%BB%E7%BB%9F%E9%A1%BA%E5%BA%8F%E5%9B%BE(2).png\" alt=\"系统顺序图(2)\"></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：</p>\n<ol>\n<li>SSD是用于替代用例说明文本的一种方式；</li>\n<li>图中只有两个对象，表示角色对象与系统对象；</li>\n<li>图中的消息名称及参数要求以可编程的方式命名；</li>\n<li>消息名称和参数可以通过一个列表使用中文说明具体含义；</li>\n<li>用例图中的每个用例都应该对应一张SSD；</li>\n<li>角色发给系统的指令（系统事件）是操作契约关注的元素~</li>\n</ol>\n</blockquote>\n<ul>\n<li>系统操作：即角色发给系统对象的请求，也称为系统事件；</li>\n<li>操作契约：契约的含义表示该系统接收到该系统请求后，为了能够得到按照约定必须返回的结果，该系统内规定必须有哪些业务对象（参考领域模型中的概念类）必须被激活、关联（协同）并记录哪些必须持久保存的数据（概念类属性值的改变）。它是后续软件设计活动中确定软件对象的参考依据</li>\n</ul>\n<p><img src=\"/img/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B(2)/%E6%93%8D%E4%BD%9C%E5%A5%91%E7%BA%A6.png\" alt=\"操作契约\"></p>\n<ul>\n<li>创建操作契约的指导原则如下： <ul>\n<li>根据系统顺序图识别进入到系统内的所有系统事件，即操作；</li>\n<li>针对每一个系统操作结合对应的领域模型，找到与此操作相关的概念类；</li>\n<li>定义概念类响应该操作的以下三项内容；<ul>\n<li>对象实例创建和删除；</li>\n<li>对象关联形成和断开；</li>\n<li>对象属性修改。</li>\n</ul>\n</li>\n<li>后置条件中至少有一项存在，该操作才有存在的必要性！</li>\n<li>后置条件的陈述应该是声明性的，以强调系统状态所发生的变化，无需考虑如何设计和实现的。</li>\n</ul>\n</li>\n</ul>\n"},{"title":"软件工程(3)","date":"2024-10-31T14:19:45.000Z","_content":"# 软件与软件危机\n1. 软件\n   1. 定义：在计算机系统的支持下，能够完成特定功能和性能的**程序**、**数据**和相关的**文档**\n   2. 分类：按**功能**、**规模**、**工作方式**等分类。\n\n2. 软件危机\n   在计算机开发和维护中遇到的一系列严重问题\n   1. 包含两个方面\n      1. 如何开发软件\n      2. 如何维护软件\n   2. 软件危机的表现\n      1. 计划不准确\n      2. 用户不满意\n      3. 质量不可靠\n      4. 系统难维护\n      5. 文档不合适\n      6. 成本上升\n      7. 开发效率低\n   3. 产生软件危机的原因\n      1. 与软件本身的特点有感\n         1. 软件缺乏可见性\n         2. 可能存在测试阶段没能检测出来的错误\n         3. 软件维护通常意味着修正原来的计划，使得软件维护困难\n         4. 软件规模庞大，随着规模增加复杂性呈指数上升\n      2. 软件开发维护方法不正确\n         1. 忽视软件需求分析重要性，匆忙着手编程\n         2. 程序只是完整产品的一个组成部分\n         3. 需要清楚只重视程序而忽视软件配置其余成分的错误观念\n         4. 轻视维护是最大错误\n   4. 消除软件危机的方法\n      1. 对计算软件有正确的认识\n      2. 积累有效地原理、概念、技术和方法\n      3. 积极开发和使用计算机辅助开发软件\n      4. 探索更好的管理措施对开发搓成进行管控\n\n# 软件工程\n1. 定义：指导计算机软件**开发**和**维护**的**工程学科** \n   1. 它采用**工程**的概念、原理、技术和方法来**开发**和**维护**软件；\n   2. 它将**管理技术**与当前经过时间考验的二证明是正确的**技术方法**结合起来；\n   3. 它强调使用**生存周期**方法学和**结构化技术**；\n2. 软件工程基本原理\n   1. 用**分阶段**的软件工程周期计划进行严格的质量管理。\n   2. 坚持进行**阶段评审**。\n   3. 实行严格的**产品控制**。\n   4. 采用**现代化程序设计技术**。\n   5. 软件工程结果应该能清楚地**审查**。\n   6. 开发小组的人员应该**少而精**。\n   7. 承认**不断改进**软件工程实践的必要性。 \n\n3. 软件工程方法学（范型）\n   软件生命周期中使用的一整套**技术方法**的集合成为软件工程方法学。\n   1. 三要素：方法、工具和过程 \n   2. 分类\n      1. 结构化方法学\n         （结构化分析**SA**，结构化设计**SD**，结构化程序设计**SP**） \n         1. 采用**结构化**技术\n         1. 把**软件生成周期**的全过程依次划分为若干个阶段\n         2. 每一阶段的开始和结束都有**严格标准**\n         3. 每一阶段结束前需严格**审查和复审**\n      2. 面向对象方法学\n        （面向对象分析**OOA**，面向对象设计**OOD**，面向对象程序设计**OOP**）\n         1. 用**对象分解**取代传统方法学的功能分解\n         2. 把所有对象都划分成**类**\n         3. 按照父类和子类的关系，把若干相关类组成一个**层级结构**的系统\n         4. 对象间仅通过发送消息相互联系\n\n# 可行性研究\n1. 目的：用**最小代价**在**最短时间**内确定问题是否能解决\n2. 任务\n   1. 定义问题：分析和澄清问题定义\n   2. 导出**系统**模型\n      1. 物理模型：**系统流程图**SFD\n      2. 逻辑模型：**数据流图**DFD、**数据字典**DD\n      3. 探索解法：根据逻辑模型探索若干可供选择解法\n      4. 研究可行性\n         1. **技术可行性**：系统能否实现\n         2. **经济可行性**：进行**成本效益分析**，评估项目的**成本**\n         3. **操作可行性**（运行可行性）\n         4. 其他：法律、社会等\n   3. 步骤\n      1. 复查系统规模和目标\n      2. 研究在目前正在使用的系统\n      3. 导出信息系统的高层逻辑模型\n      4. 进一步定义问题\n      5. 导出和哦性价可供选择的解法\n      6. 推荐行动方针\n      7. 草拟开发计划\n      8. 书写文档提交审查\n   4. 结果：可行性研究报告\n      1. 系统概述\n      2. 可行性研究\n      3. 拟定开发机会\n      4. 结论意见","source":"_posts/软件工程-3.md","raw":"---\ntitle: 软件工程(3)\ndate: 2024-10-31 22:19:45\ntags:\n    - 学习笔记\n---\n# 软件与软件危机\n1. 软件\n   1. 定义：在计算机系统的支持下，能够完成特定功能和性能的**程序**、**数据**和相关的**文档**\n   2. 分类：按**功能**、**规模**、**工作方式**等分类。\n\n2. 软件危机\n   在计算机开发和维护中遇到的一系列严重问题\n   1. 包含两个方面\n      1. 如何开发软件\n      2. 如何维护软件\n   2. 软件危机的表现\n      1. 计划不准确\n      2. 用户不满意\n      3. 质量不可靠\n      4. 系统难维护\n      5. 文档不合适\n      6. 成本上升\n      7. 开发效率低\n   3. 产生软件危机的原因\n      1. 与软件本身的特点有感\n         1. 软件缺乏可见性\n         2. 可能存在测试阶段没能检测出来的错误\n         3. 软件维护通常意味着修正原来的计划，使得软件维护困难\n         4. 软件规模庞大，随着规模增加复杂性呈指数上升\n      2. 软件开发维护方法不正确\n         1. 忽视软件需求分析重要性，匆忙着手编程\n         2. 程序只是完整产品的一个组成部分\n         3. 需要清楚只重视程序而忽视软件配置其余成分的错误观念\n         4. 轻视维护是最大错误\n   4. 消除软件危机的方法\n      1. 对计算软件有正确的认识\n      2. 积累有效地原理、概念、技术和方法\n      3. 积极开发和使用计算机辅助开发软件\n      4. 探索更好的管理措施对开发搓成进行管控\n\n# 软件工程\n1. 定义：指导计算机软件**开发**和**维护**的**工程学科** \n   1. 它采用**工程**的概念、原理、技术和方法来**开发**和**维护**软件；\n   2. 它将**管理技术**与当前经过时间考验的二证明是正确的**技术方法**结合起来；\n   3. 它强调使用**生存周期**方法学和**结构化技术**；\n2. 软件工程基本原理\n   1. 用**分阶段**的软件工程周期计划进行严格的质量管理。\n   2. 坚持进行**阶段评审**。\n   3. 实行严格的**产品控制**。\n   4. 采用**现代化程序设计技术**。\n   5. 软件工程结果应该能清楚地**审查**。\n   6. 开发小组的人员应该**少而精**。\n   7. 承认**不断改进**软件工程实践的必要性。 \n\n3. 软件工程方法学（范型）\n   软件生命周期中使用的一整套**技术方法**的集合成为软件工程方法学。\n   1. 三要素：方法、工具和过程 \n   2. 分类\n      1. 结构化方法学\n         （结构化分析**SA**，结构化设计**SD**，结构化程序设计**SP**） \n         1. 采用**结构化**技术\n         1. 把**软件生成周期**的全过程依次划分为若干个阶段\n         2. 每一阶段的开始和结束都有**严格标准**\n         3. 每一阶段结束前需严格**审查和复审**\n      2. 面向对象方法学\n        （面向对象分析**OOA**，面向对象设计**OOD**，面向对象程序设计**OOP**）\n         1. 用**对象分解**取代传统方法学的功能分解\n         2. 把所有对象都划分成**类**\n         3. 按照父类和子类的关系，把若干相关类组成一个**层级结构**的系统\n         4. 对象间仅通过发送消息相互联系\n\n# 可行性研究\n1. 目的：用**最小代价**在**最短时间**内确定问题是否能解决\n2. 任务\n   1. 定义问题：分析和澄清问题定义\n   2. 导出**系统**模型\n      1. 物理模型：**系统流程图**SFD\n      2. 逻辑模型：**数据流图**DFD、**数据字典**DD\n      3. 探索解法：根据逻辑模型探索若干可供选择解法\n      4. 研究可行性\n         1. **技术可行性**：系统能否实现\n         2. **经济可行性**：进行**成本效益分析**，评估项目的**成本**\n         3. **操作可行性**（运行可行性）\n         4. 其他：法律、社会等\n   3. 步骤\n      1. 复查系统规模和目标\n      2. 研究在目前正在使用的系统\n      3. 导出信息系统的高层逻辑模型\n      4. 进一步定义问题\n      5. 导出和哦性价可供选择的解法\n      6. 推荐行动方针\n      7. 草拟开发计划\n      8. 书写文档提交审查\n   4. 结果：可行性研究报告\n      1. 系统概述\n      2. 可行性研究\n      3. 拟定开发机会\n      4. 结论意见","slug":"软件工程-3","published":1,"updated":"2024-12-20T04:27:29.410Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot9000p6d6e0dpb8f1f","content":"<h1 id=\"软件与软件危机\"><a href=\"#软件与软件危机\" class=\"headerlink\" title=\"软件与软件危机\"></a>软件与软件危机</h1><ol>\n<li><p>软件</p>\n<ol>\n<li>定义：在计算机系统的支持下，能够完成特定功能和性能的<strong>程序</strong>、<strong>数据</strong>和相关的<strong>文档</strong></li>\n<li>分类：按<strong>功能</strong>、<strong>规模</strong>、<strong>工作方式</strong>等分类。</li>\n</ol>\n</li>\n<li><p>软件危机<br>在计算机开发和维护中遇到的一系列严重问题</p>\n<ol>\n<li>包含两个方面<ol>\n<li>如何开发软件</li>\n<li>如何维护软件</li>\n</ol>\n</li>\n<li>软件危机的表现<ol>\n<li>计划不准确</li>\n<li>用户不满意</li>\n<li>质量不可靠</li>\n<li>系统难维护</li>\n<li>文档不合适</li>\n<li>成本上升</li>\n<li>开发效率低</li>\n</ol>\n</li>\n<li>产生软件危机的原因<ol>\n<li>与软件本身的特点有感<ol>\n<li>软件缺乏可见性</li>\n<li>可能存在测试阶段没能检测出来的错误</li>\n<li>软件维护通常意味着修正原来的计划，使得软件维护困难</li>\n<li>软件规模庞大，随着规模增加复杂性呈指数上升</li>\n</ol>\n</li>\n<li>软件开发维护方法不正确<ol>\n<li>忽视软件需求分析重要性，匆忙着手编程</li>\n<li>程序只是完整产品的一个组成部分</li>\n<li>需要清楚只重视程序而忽视软件配置其余成分的错误观念</li>\n<li>轻视维护是最大错误</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>消除软件危机的方法<ol>\n<li>对计算软件有正确的认识</li>\n<li>积累有效地原理、概念、技术和方法</li>\n<li>积极开发和使用计算机辅助开发软件</li>\n<li>探索更好的管理措施对开发搓成进行管控</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"软件工程\"><a href=\"#软件工程\" class=\"headerlink\" title=\"软件工程\"></a>软件工程</h1><ol>\n<li><p>定义：指导计算机软件<strong>开发</strong>和<strong>维护</strong>的<strong>工程学科</strong> </p>\n<ol>\n<li>它采用<strong>工程</strong>的概念、原理、技术和方法来<strong>开发</strong>和<strong>维护</strong>软件；</li>\n<li>它将<strong>管理技术</strong>与当前经过时间考验的二证明是正确的<strong>技术方法</strong>结合起来；</li>\n<li>它强调使用<strong>生存周期</strong>方法学和<strong>结构化技术</strong>；</li>\n</ol>\n</li>\n<li><p>软件工程基本原理</p>\n<ol>\n<li>用<strong>分阶段</strong>的软件工程周期计划进行严格的质量管理。</li>\n<li>坚持进行<strong>阶段评审</strong>。</li>\n<li>实行严格的<strong>产品控制</strong>。</li>\n<li>采用<strong>现代化程序设计技术</strong>。</li>\n<li>软件工程结果应该能清楚地<strong>审查</strong>。</li>\n<li>开发小组的人员应该<strong>少而精</strong>。</li>\n<li>承认<strong>不断改进</strong>软件工程实践的必要性。</li>\n</ol>\n</li>\n<li><p>软件工程方法学（范型）<br>软件生命周期中使用的一整套<strong>技术方法</strong>的集合成为软件工程方法学。</p>\n<ol>\n<li>三要素：方法、工具和过程 </li>\n<li>分类<ol>\n<li>结构化方法学<br>（结构化分析<strong>SA</strong>，结构化设计<strong>SD</strong>，结构化程序设计<strong>SP</strong>） <ol>\n<li>采用<strong>结构化</strong>技术</li>\n<li>把<strong>软件生成周期</strong>的全过程依次划分为若干个阶段</li>\n<li>每一阶段的开始和结束都有<strong>严格标准</strong></li>\n<li>每一阶段结束前需严格<strong>审查和复审</strong></li>\n</ol>\n</li>\n<li>面向对象方法学<br>  （面向对象分析<strong>OOA</strong>，面向对象设计<strong>OOD</strong>，面向对象程序设计<strong>OOP</strong>）<ol>\n<li>用<strong>对象分解</strong>取代传统方法学的功能分解</li>\n<li>把所有对象都划分成<strong>类</strong></li>\n<li>按照父类和子类的关系，把若干相关类组成一个<strong>层级结构</strong>的系统</li>\n<li>对象间仅通过发送消息相互联系</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"可行性研究\"><a href=\"#可行性研究\" class=\"headerlink\" title=\"可行性研究\"></a>可行性研究</h1><ol>\n<li>目的：用<strong>最小代价</strong>在<strong>最短时间</strong>内确定问题是否能解决</li>\n<li>任务<ol>\n<li>定义问题：分析和澄清问题定义</li>\n<li>导出<strong>系统</strong>模型<ol>\n<li>物理模型：<strong>系统流程图</strong>SFD</li>\n<li>逻辑模型：<strong>数据流图</strong>DFD、<strong>数据字典</strong>DD</li>\n<li>探索解法：根据逻辑模型探索若干可供选择解法</li>\n<li>研究可行性<ol>\n<li><strong>技术可行性</strong>：系统能否实现</li>\n<li><strong>经济可行性</strong>：进行<strong>成本效益分析</strong>，评估项目的<strong>成本</strong></li>\n<li><strong>操作可行性</strong>（运行可行性）</li>\n<li>其他：法律、社会等</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>步骤<ol>\n<li>复查系统规模和目标</li>\n<li>研究在目前正在使用的系统</li>\n<li>导出信息系统的高层逻辑模型</li>\n<li>进一步定义问题</li>\n<li>导出和哦性价可供选择的解法</li>\n<li>推荐行动方针</li>\n<li>草拟开发计划</li>\n<li>书写文档提交审查</li>\n</ol>\n</li>\n<li>结果：可行性研究报告<ol>\n<li>系统概述</li>\n<li>可行性研究</li>\n<li>拟定开发机会</li>\n<li>结论意见</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n","excerpt":"","more":"<h1 id=\"软件与软件危机\"><a href=\"#软件与软件危机\" class=\"headerlink\" title=\"软件与软件危机\"></a>软件与软件危机</h1><ol>\n<li><p>软件</p>\n<ol>\n<li>定义：在计算机系统的支持下，能够完成特定功能和性能的<strong>程序</strong>、<strong>数据</strong>和相关的<strong>文档</strong></li>\n<li>分类：按<strong>功能</strong>、<strong>规模</strong>、<strong>工作方式</strong>等分类。</li>\n</ol>\n</li>\n<li><p>软件危机<br>在计算机开发和维护中遇到的一系列严重问题</p>\n<ol>\n<li>包含两个方面<ol>\n<li>如何开发软件</li>\n<li>如何维护软件</li>\n</ol>\n</li>\n<li>软件危机的表现<ol>\n<li>计划不准确</li>\n<li>用户不满意</li>\n<li>质量不可靠</li>\n<li>系统难维护</li>\n<li>文档不合适</li>\n<li>成本上升</li>\n<li>开发效率低</li>\n</ol>\n</li>\n<li>产生软件危机的原因<ol>\n<li>与软件本身的特点有感<ol>\n<li>软件缺乏可见性</li>\n<li>可能存在测试阶段没能检测出来的错误</li>\n<li>软件维护通常意味着修正原来的计划，使得软件维护困难</li>\n<li>软件规模庞大，随着规模增加复杂性呈指数上升</li>\n</ol>\n</li>\n<li>软件开发维护方法不正确<ol>\n<li>忽视软件需求分析重要性，匆忙着手编程</li>\n<li>程序只是完整产品的一个组成部分</li>\n<li>需要清楚只重视程序而忽视软件配置其余成分的错误观念</li>\n<li>轻视维护是最大错误</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>消除软件危机的方法<ol>\n<li>对计算软件有正确的认识</li>\n<li>积累有效地原理、概念、技术和方法</li>\n<li>积极开发和使用计算机辅助开发软件</li>\n<li>探索更好的管理措施对开发搓成进行管控</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"软件工程\"><a href=\"#软件工程\" class=\"headerlink\" title=\"软件工程\"></a>软件工程</h1><ol>\n<li><p>定义：指导计算机软件<strong>开发</strong>和<strong>维护</strong>的<strong>工程学科</strong> </p>\n<ol>\n<li>它采用<strong>工程</strong>的概念、原理、技术和方法来<strong>开发</strong>和<strong>维护</strong>软件；</li>\n<li>它将<strong>管理技术</strong>与当前经过时间考验的二证明是正确的<strong>技术方法</strong>结合起来；</li>\n<li>它强调使用<strong>生存周期</strong>方法学和<strong>结构化技术</strong>；</li>\n</ol>\n</li>\n<li><p>软件工程基本原理</p>\n<ol>\n<li>用<strong>分阶段</strong>的软件工程周期计划进行严格的质量管理。</li>\n<li>坚持进行<strong>阶段评审</strong>。</li>\n<li>实行严格的<strong>产品控制</strong>。</li>\n<li>采用<strong>现代化程序设计技术</strong>。</li>\n<li>软件工程结果应该能清楚地<strong>审查</strong>。</li>\n<li>开发小组的人员应该<strong>少而精</strong>。</li>\n<li>承认<strong>不断改进</strong>软件工程实践的必要性。</li>\n</ol>\n</li>\n<li><p>软件工程方法学（范型）<br>软件生命周期中使用的一整套<strong>技术方法</strong>的集合成为软件工程方法学。</p>\n<ol>\n<li>三要素：方法、工具和过程 </li>\n<li>分类<ol>\n<li>结构化方法学<br>（结构化分析<strong>SA</strong>，结构化设计<strong>SD</strong>，结构化程序设计<strong>SP</strong>） <ol>\n<li>采用<strong>结构化</strong>技术</li>\n<li>把<strong>软件生成周期</strong>的全过程依次划分为若干个阶段</li>\n<li>每一阶段的开始和结束都有<strong>严格标准</strong></li>\n<li>每一阶段结束前需严格<strong>审查和复审</strong></li>\n</ol>\n</li>\n<li>面向对象方法学<br>  （面向对象分析<strong>OOA</strong>，面向对象设计<strong>OOD</strong>，面向对象程序设计<strong>OOP</strong>）<ol>\n<li>用<strong>对象分解</strong>取代传统方法学的功能分解</li>\n<li>把所有对象都划分成<strong>类</strong></li>\n<li>按照父类和子类的关系，把若干相关类组成一个<strong>层级结构</strong>的系统</li>\n<li>对象间仅通过发送消息相互联系</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h1 id=\"可行性研究\"><a href=\"#可行性研究\" class=\"headerlink\" title=\"可行性研究\"></a>可行性研究</h1><ol>\n<li>目的：用<strong>最小代价</strong>在<strong>最短时间</strong>内确定问题是否能解决</li>\n<li>任务<ol>\n<li>定义问题：分析和澄清问题定义</li>\n<li>导出<strong>系统</strong>模型<ol>\n<li>物理模型：<strong>系统流程图</strong>SFD</li>\n<li>逻辑模型：<strong>数据流图</strong>DFD、<strong>数据字典</strong>DD</li>\n<li>探索解法：根据逻辑模型探索若干可供选择解法</li>\n<li>研究可行性<ol>\n<li><strong>技术可行性</strong>：系统能否实现</li>\n<li><strong>经济可行性</strong>：进行<strong>成本效益分析</strong>，评估项目的<strong>成本</strong></li>\n<li><strong>操作可行性</strong>（运行可行性）</li>\n<li>其他：法律、社会等</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>步骤<ol>\n<li>复查系统规模和目标</li>\n<li>研究在目前正在使用的系统</li>\n<li>导出信息系统的高层逻辑模型</li>\n<li>进一步定义问题</li>\n<li>导出和哦性价可供选择的解法</li>\n<li>推荐行动方针</li>\n<li>草拟开发计划</li>\n<li>书写文档提交审查</li>\n</ol>\n</li>\n<li>结果：可行性研究报告<ol>\n<li>系统概述</li>\n<li>可行性研究</li>\n<li>拟定开发机会</li>\n<li>结论意见</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"远程连接X11VNC+SSH","date":"2024-10-17T14:27:54.000Z","_content":"对于实现Linux的远程连接，使用X11VNC是一个极好的选择。曾使用过tigerVNC和X0VNC，tigerVNC本身使用必须退出当前桌面，或者为此额外开创个一个用户以使用桌面，会达到文件隔离的效果，并不适合个人用户的长期使用，而对于X0VNC他本身在权限使用方面不够方面。\n作为个人用户，使用最好能类似于向日葵、ToDesk等软件，直接对物理桌面进行操控，虽然对于使用虚拟桌面有诸多缺点，但是是实际能满足个人需求的方式。\n首先对于Archlinux，进行X11VNC安装。\n```shell\nyay -S x11vnc\n```\n在WIKI中，提供了Xinetd和systemd两种方法来管理X11VNC，经过个人实验，使用Xinetd管理X11VNC进程可能会在Windows上显示`not RFB server`，不清楚其中具体问题，所以直接将X11VNC嵌入为一个systemd来进行管理和开机自启。\n\n首先需要确定当前桌面的授权文件是什么，这是关键中的关键。当其作为一个服务时，其必须确定其授权文件的具体位置，注意，不要使用`-auth guess`。在WIKI中指出授权文件地址一般为`/home/user/.Xauthority`，但是实际上在我使用的KDE6桌面环境中，授权文件并非如此，其位置在\n`/run/sddm/xauth_twJiKL`中，实际上该文件是随机生成的。\n继续参考WIKI给出的使用方法，稍微进行修改进行实践。\n先使用`vncpasswd`工具生成密码文件\n```shell\nvncpasswd  pwd_path(替换为你指定的存放密码的位置)\n```\n然后编写服务文件\n```shell\nsudo nano cat /etc/systemd/system/xinetd.service.d/override.conf\n```\n将文件内容填写为\n```shell\n[Service]\nExecStart=\nExecStart=/bin/bash -c \"/usr/bin/x11vnc -auth /var/run/sddm/* -display :0 -forever -loop -noxdamage -repeat -rfbauth /home/your_user/.vnc/passwd -rfbport 5901\"\nExecStartPre=/usr/bin/sleep 1\n```\n然后重新载入，启动服务并展现服务状态\n```shell\nsudo systemctl daemon-reload\nsudo systemctl start x11vnc\nsudo systemctl status x11vnc\n```\n如果服务正常启动，就可以先尝试连接啦。本身在Windows客户端推荐使用 VNCviewer进行使用，可以很好的调整桌面的大小，同时连接方便。\n首先查看服务器端电脑的IP\n```shell\nip a\n```\n很多时候电脑可能只会被分配一个局域网地址，这说明你目前只可以在同一局域网中连接上该电脑。在刚刚的文件编写中已经确定服务器端电脑的服务端口在 `5901`,所以在连接框中键入`ip::port`,就可以实现连接。\n\n但在实际使用中，一直开启X11VNC服务会可能产生轻微的资源占用同时不够安全，而且本质目的是远程控制个人计算机，所以使用SSH也是重要的一个工具，所以推荐使用SSH来首先进行服务器端主机连接，然后启动服务来再来使用`X11VNC`远程控制桌面，当然也可以使用\n```shell\nsudo systemctl enable x11vnc.service\n```\n来开机自启动X11VNC。\n\n服务端使用SSH相对而言非常简单，相对而言就是直接安装，纵享丝滑。\n```shell\nsudo pacman -S openssh \n```\n查看ssh的运行状态\n```shell\nsystemctl status sshd\n```\n启动ssh\n```shell\nsystemctl start sshd\n```\n设置开机自启动\n```shell\nsystemctl enable sshd\n```\n如果需要停止ssh，则使用\n```shell\nsystemctl stop sshd\n```\n为了连接电脑ssh，首先需要获取服务器端IP地址，上文中已经使用`ip a`获取过。\n于是乎，在ssh客户端电脑上使用ssh服务(个人会使用万能编辑器VSCODE)，键入 `user@IP`\n其中，作为个人PC使用，所以我的`user`选择了超级用户(本身也就只创了一个用户)。键入后输入密码，即电脑该用户密码，就可以实现访问了。\n\n在一般使用中，通过ssh连接上电脑\n```shell\nsystemctl start x11vnc\n```\n开启主机端的服务之后再通过VNCviewer连接进行查看，至此远程连接就做好了。\n","source":"_posts/远程连接X11VNC+SSH.md","raw":"---\ntitle: 远程连接X11VNC+SSH\ndate: 2024-10-17 22:27:54\ntags:\n    - Archlinux\n    - 学习笔记\n---\n对于实现Linux的远程连接，使用X11VNC是一个极好的选择。曾使用过tigerVNC和X0VNC，tigerVNC本身使用必须退出当前桌面，或者为此额外开创个一个用户以使用桌面，会达到文件隔离的效果，并不适合个人用户的长期使用，而对于X0VNC他本身在权限使用方面不够方面。\n作为个人用户，使用最好能类似于向日葵、ToDesk等软件，直接对物理桌面进行操控，虽然对于使用虚拟桌面有诸多缺点，但是是实际能满足个人需求的方式。\n首先对于Archlinux，进行X11VNC安装。\n```shell\nyay -S x11vnc\n```\n在WIKI中，提供了Xinetd和systemd两种方法来管理X11VNC，经过个人实验，使用Xinetd管理X11VNC进程可能会在Windows上显示`not RFB server`，不清楚其中具体问题，所以直接将X11VNC嵌入为一个systemd来进行管理和开机自启。\n\n首先需要确定当前桌面的授权文件是什么，这是关键中的关键。当其作为一个服务时，其必须确定其授权文件的具体位置，注意，不要使用`-auth guess`。在WIKI中指出授权文件地址一般为`/home/user/.Xauthority`，但是实际上在我使用的KDE6桌面环境中，授权文件并非如此，其位置在\n`/run/sddm/xauth_twJiKL`中，实际上该文件是随机生成的。\n继续参考WIKI给出的使用方法，稍微进行修改进行实践。\n先使用`vncpasswd`工具生成密码文件\n```shell\nvncpasswd  pwd_path(替换为你指定的存放密码的位置)\n```\n然后编写服务文件\n```shell\nsudo nano cat /etc/systemd/system/xinetd.service.d/override.conf\n```\n将文件内容填写为\n```shell\n[Service]\nExecStart=\nExecStart=/bin/bash -c \"/usr/bin/x11vnc -auth /var/run/sddm/* -display :0 -forever -loop -noxdamage -repeat -rfbauth /home/your_user/.vnc/passwd -rfbport 5901\"\nExecStartPre=/usr/bin/sleep 1\n```\n然后重新载入，启动服务并展现服务状态\n```shell\nsudo systemctl daemon-reload\nsudo systemctl start x11vnc\nsudo systemctl status x11vnc\n```\n如果服务正常启动，就可以先尝试连接啦。本身在Windows客户端推荐使用 VNCviewer进行使用，可以很好的调整桌面的大小，同时连接方便。\n首先查看服务器端电脑的IP\n```shell\nip a\n```\n很多时候电脑可能只会被分配一个局域网地址，这说明你目前只可以在同一局域网中连接上该电脑。在刚刚的文件编写中已经确定服务器端电脑的服务端口在 `5901`,所以在连接框中键入`ip::port`,就可以实现连接。\n\n但在实际使用中，一直开启X11VNC服务会可能产生轻微的资源占用同时不够安全，而且本质目的是远程控制个人计算机，所以使用SSH也是重要的一个工具，所以推荐使用SSH来首先进行服务器端主机连接，然后启动服务来再来使用`X11VNC`远程控制桌面，当然也可以使用\n```shell\nsudo systemctl enable x11vnc.service\n```\n来开机自启动X11VNC。\n\n服务端使用SSH相对而言非常简单，相对而言就是直接安装，纵享丝滑。\n```shell\nsudo pacman -S openssh \n```\n查看ssh的运行状态\n```shell\nsystemctl status sshd\n```\n启动ssh\n```shell\nsystemctl start sshd\n```\n设置开机自启动\n```shell\nsystemctl enable sshd\n```\n如果需要停止ssh，则使用\n```shell\nsystemctl stop sshd\n```\n为了连接电脑ssh，首先需要获取服务器端IP地址，上文中已经使用`ip a`获取过。\n于是乎，在ssh客户端电脑上使用ssh服务(个人会使用万能编辑器VSCODE)，键入 `user@IP`\n其中，作为个人PC使用，所以我的`user`选择了超级用户(本身也就只创了一个用户)。键入后输入密码，即电脑该用户密码，就可以实现访问了。\n\n在一般使用中，通过ssh连接上电脑\n```shell\nsystemctl start x11vnc\n```\n开启主机端的服务之后再通过VNCviewer连接进行查看，至此远程连接就做好了。\n","slug":"远程连接X11VNC+SSH","published":1,"updated":"2024-12-20T04:27:29.410Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot9000s6d6eh0la6fa9","content":"<p>对于实现Linux的远程连接，使用X11VNC是一个极好的选择。曾使用过tigerVNC和X0VNC，tigerVNC本身使用必须退出当前桌面，或者为此额外开创个一个用户以使用桌面，会达到文件隔离的效果，并不适合个人用户的长期使用，而对于X0VNC他本身在权限使用方面不够方面。<br>作为个人用户，使用最好能类似于向日葵、ToDesk等软件，直接对物理桌面进行操控，虽然对于使用虚拟桌面有诸多缺点，但是是实际能满足个人需求的方式。<br>首先对于Archlinux，进行X11VNC安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yay -S x11vnc<br></code></pre></td></tr></table></figure>\n<p>在WIKI中，提供了Xinetd和systemd两种方法来管理X11VNC，经过个人实验，使用Xinetd管理X11VNC进程可能会在Windows上显示<code>not RFB server</code>，不清楚其中具体问题，所以直接将X11VNC嵌入为一个systemd来进行管理和开机自启。</p>\n<p>首先需要确定当前桌面的授权文件是什么，这是关键中的关键。当其作为一个服务时，其必须确定其授权文件的具体位置，注意，不要使用<code>-auth guess</code>。在WIKI中指出授权文件地址一般为<code>/home/user/.Xauthority</code>，但是实际上在我使用的KDE6桌面环境中，授权文件并非如此，其位置在<br><code>/run/sddm/xauth_twJiKL</code>中，实际上该文件是随机生成的。<br>继续参考WIKI给出的使用方法，稍微进行修改进行实践。<br>先使用<code>vncpasswd</code>工具生成密码文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">vncpasswd  pwd_path(替换为你指定的存放密码的位置)<br></code></pre></td></tr></table></figure>\n<p>然后编写服务文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo nano cat /etc/systemd/system/xinetd.service.d/override.conf<br></code></pre></td></tr></table></figure>\n<p>将文件内容填写为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">[Service]<br>ExecStart=<br>ExecStart=/bin/bash -c &quot;/usr/bin/x11vnc -auth /var/run/sddm/* -display :0 -forever -loop -noxdamage -repeat -rfbauth /home/your_user/.vnc/passwd -rfbport 5901&quot;<br>ExecStartPre=/usr/bin/sleep 1<br></code></pre></td></tr></table></figure>\n<p>然后重新载入，启动服务并展现服务状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo systemctl daemon-reload<br>sudo systemctl start x11vnc<br>sudo systemctl status x11vnc<br></code></pre></td></tr></table></figure>\n<p>如果服务正常启动，就可以先尝试连接啦。本身在Windows客户端推荐使用 VNCviewer进行使用，可以很好的调整桌面的大小，同时连接方便。<br>首先查看服务器端电脑的IP</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ip a<br></code></pre></td></tr></table></figure>\n<p>很多时候电脑可能只会被分配一个局域网地址，这说明你目前只可以在同一局域网中连接上该电脑。在刚刚的文件编写中已经确定服务器端电脑的服务端口在 <code>5901</code>,所以在连接框中键入<code>ip::port</code>,就可以实现连接。</p>\n<p>但在实际使用中，一直开启X11VNC服务会可能产生轻微的资源占用同时不够安全，而且本质目的是远程控制个人计算机，所以使用SSH也是重要的一个工具，所以推荐使用SSH来首先进行服务器端主机连接，然后启动服务来再来使用<code>X11VNC</code>远程控制桌面，当然也可以使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo systemctl enable x11vnc.service<br></code></pre></td></tr></table></figure>\n<p>来开机自启动X11VNC。</p>\n<p>服务端使用SSH相对而言非常简单，相对而言就是直接安装，纵享丝滑。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo pacman -S openssh <br></code></pre></td></tr></table></figure>\n<p>查看ssh的运行状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl status sshd<br></code></pre></td></tr></table></figure>\n<p>启动ssh</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start sshd<br></code></pre></td></tr></table></figure>\n<p>设置开机自启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl enable sshd<br></code></pre></td></tr></table></figure>\n<p>如果需要停止ssh，则使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl stop sshd<br></code></pre></td></tr></table></figure>\n<p>为了连接电脑ssh，首先需要获取服务器端IP地址，上文中已经使用<code>ip a</code>获取过。<br>于是乎，在ssh客户端电脑上使用ssh服务(个人会使用万能编辑器VSCODE)，键入 <code>user@IP</code><br>其中，作为个人PC使用，所以我的<code>user</code>选择了超级用户(本身也就只创了一个用户)。键入后输入密码，即电脑该用户密码，就可以实现访问了。</p>\n<p>在一般使用中，通过ssh连接上电脑</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start x11vnc<br></code></pre></td></tr></table></figure>\n<p>开启主机端的服务之后再通过VNCviewer连接进行查看，至此远程连接就做好了。</p>\n","excerpt":"","more":"<p>对于实现Linux的远程连接，使用X11VNC是一个极好的选择。曾使用过tigerVNC和X0VNC，tigerVNC本身使用必须退出当前桌面，或者为此额外开创个一个用户以使用桌面，会达到文件隔离的效果，并不适合个人用户的长期使用，而对于X0VNC他本身在权限使用方面不够方面。<br>作为个人用户，使用最好能类似于向日葵、ToDesk等软件，直接对物理桌面进行操控，虽然对于使用虚拟桌面有诸多缺点，但是是实际能满足个人需求的方式。<br>首先对于Archlinux，进行X11VNC安装。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">yay -S x11vnc<br></code></pre></td></tr></table></figure>\n<p>在WIKI中，提供了Xinetd和systemd两种方法来管理X11VNC，经过个人实验，使用Xinetd管理X11VNC进程可能会在Windows上显示<code>not RFB server</code>，不清楚其中具体问题，所以直接将X11VNC嵌入为一个systemd来进行管理和开机自启。</p>\n<p>首先需要确定当前桌面的授权文件是什么，这是关键中的关键。当其作为一个服务时，其必须确定其授权文件的具体位置，注意，不要使用<code>-auth guess</code>。在WIKI中指出授权文件地址一般为<code>/home/user/.Xauthority</code>，但是实际上在我使用的KDE6桌面环境中，授权文件并非如此，其位置在<br><code>/run/sddm/xauth_twJiKL</code>中，实际上该文件是随机生成的。<br>继续参考WIKI给出的使用方法，稍微进行修改进行实践。<br>先使用<code>vncpasswd</code>工具生成密码文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">vncpasswd  pwd_path(替换为你指定的存放密码的位置)<br></code></pre></td></tr></table></figure>\n<p>然后编写服务文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo nano cat /etc/systemd/system/xinetd.service.d/override.conf<br></code></pre></td></tr></table></figure>\n<p>将文件内容填写为</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">[Service]<br>ExecStart=<br>ExecStart=/bin/bash -c &quot;/usr/bin/x11vnc -auth /var/run/sddm/* -display :0 -forever -loop -noxdamage -repeat -rfbauth /home/your_user/.vnc/passwd -rfbport 5901&quot;<br>ExecStartPre=/usr/bin/sleep 1<br></code></pre></td></tr></table></figure>\n<p>然后重新载入，启动服务并展现服务状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo systemctl daemon-reload<br>sudo systemctl start x11vnc<br>sudo systemctl status x11vnc<br></code></pre></td></tr></table></figure>\n<p>如果服务正常启动，就可以先尝试连接啦。本身在Windows客户端推荐使用 VNCviewer进行使用，可以很好的调整桌面的大小，同时连接方便。<br>首先查看服务器端电脑的IP</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">ip a<br></code></pre></td></tr></table></figure>\n<p>很多时候电脑可能只会被分配一个局域网地址，这说明你目前只可以在同一局域网中连接上该电脑。在刚刚的文件编写中已经确定服务器端电脑的服务端口在 <code>5901</code>,所以在连接框中键入<code>ip::port</code>,就可以实现连接。</p>\n<p>但在实际使用中，一直开启X11VNC服务会可能产生轻微的资源占用同时不够安全，而且本质目的是远程控制个人计算机，所以使用SSH也是重要的一个工具，所以推荐使用SSH来首先进行服务器端主机连接，然后启动服务来再来使用<code>X11VNC</code>远程控制桌面，当然也可以使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo systemctl enable x11vnc.service<br></code></pre></td></tr></table></figure>\n<p>来开机自启动X11VNC。</p>\n<p>服务端使用SSH相对而言非常简单，相对而言就是直接安装，纵享丝滑。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">sudo pacman -S openssh <br></code></pre></td></tr></table></figure>\n<p>查看ssh的运行状态</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl status sshd<br></code></pre></td></tr></table></figure>\n<p>启动ssh</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start sshd<br></code></pre></td></tr></table></figure>\n<p>设置开机自启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl enable sshd<br></code></pre></td></tr></table></figure>\n<p>如果需要停止ssh，则使用</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl stop sshd<br></code></pre></td></tr></table></figure>\n<p>为了连接电脑ssh，首先需要获取服务器端IP地址，上文中已经使用<code>ip a</code>获取过。<br>于是乎，在ssh客户端电脑上使用ssh服务(个人会使用万能编辑器VSCODE)，键入 <code>user@IP</code><br>其中，作为个人PC使用，所以我的<code>user</code>选择了超级用户(本身也就只创了一个用户)。键入后输入密码，即电脑该用户密码，就可以实现访问了。</p>\n<p>在一般使用中，通过ssh连接上电脑</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs shell\">systemctl start x11vnc<br></code></pre></td></tr></table></figure>\n<p>开启主机端的服务之后再通过VNCviewer连接进行查看，至此远程连接就做好了。</p>\n"},{"title":"项目介绍心得","date":"2024-11-01T07:56:28.000Z","_content":"","source":"_posts/项目介绍心得.md","raw":"---\ntitle: 项目介绍心得\ndate: 2024-11-01 15:56:28\ntags:\n---\n","slug":"项目介绍心得","published":1,"updated":"2024-12-20T04:27:29.410Z","comments":1,"layout":"post","photos":[],"_id":"cmgt4jot9000u6d6e4smabhe5","content":"","excerpt":"","more":""}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cmgt4jot200016d6e9boq76ca","tag_id":"cmgt4jot400036d6eaodk62fz","_id":"cmgt4jot7000f6d6edm6t90sg"},{"post_id":"cmgt4jot200016d6e9boq76ca","tag_id":"cmgt4jot500076d6e02336pe7","_id":"cmgt4jot8000h6d6e5s28165h"},{"post_id":"cmgt4jot200016d6e9boq76ca","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jot8000k6d6egeeccphe"},{"post_id":"cmgt4jot8000l6d6e1bk3a761","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jot9000o6d6e1i3r7ume"},{"post_id":"cmgt4jot8000n6d6egklaaaem","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jot9000q6d6e0slna27r"},{"post_id":"cmgt4jot9000p6d6e0dpb8f1f","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jot9000t6d6eb27ed8cn"},{"post_id":"cmgt4jot300026d6e85549f6q","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jot9000w6d6e3h1rf0wq"},{"post_id":"cmgt4jot300026d6e85549f6q","tag_id":"cmgt4jot400036d6eaodk62fz","_id":"cmgt4jota000x6d6e5115bcmw"},{"post_id":"cmgt4jot300026d6e85549f6q","tag_id":"cmgt4jot8000m6d6e6t2h5y3d","_id":"cmgt4jota000z6d6e05jwbex2"},{"post_id":"cmgt4jot300026d6e85549f6q","tag_id":"cmgt4jot9000r6d6e1jx45irf","_id":"cmgt4jota00106d6ecf4df7hl"},{"post_id":"cmgt4jot400046d6ec4240eei","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jota00126d6e9cmgeutb"},{"post_id":"cmgt4jot500056d6ehmk29vfk","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jota00136d6e2rai908l"},{"post_id":"cmgt4jot500066d6e85v50d6y","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jota00166d6edtkx63bm"},{"post_id":"cmgt4jot500066d6e85v50d6y","tag_id":"cmgt4jota00146d6ecizk6o17","_id":"cmgt4jota00176d6e2crr3udp"},{"post_id":"cmgt4jot500086d6e2g8aedpk","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jota001a6d6ecqrfaw4y"},{"post_id":"cmgt4jot500086d6e2g8aedpk","tag_id":"cmgt4jota00146d6ecizk6o17","_id":"cmgt4jota001b6d6eh8vv4irw"},{"post_id":"cmgt4jot600096d6e92adbbit","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jota001e6d6e803ycnj9"},{"post_id":"cmgt4jot600096d6e92adbbit","tag_id":"cmgt4jota00146d6ecizk6o17","_id":"cmgt4jota001f6d6e9uqo0a5n"},{"post_id":"cmgt4jot6000b6d6eg5a2fyu0","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jota001h6d6e877e4wrx"},{"post_id":"cmgt4jot6000b6d6eg5a2fyu0","tag_id":"cmgt4jota00146d6ecizk6o17","_id":"cmgt4jotb001i6d6edls6a1y6"},{"post_id":"cmgt4jot6000c6d6efzdpenj3","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jotb001k6d6eglvcerjm"},{"post_id":"cmgt4jot6000c6d6efzdpenj3","tag_id":"cmgt4jota00146d6ecizk6o17","_id":"cmgt4jotb001l6d6e67sl5zv8"},{"post_id":"cmgt4jot7000e6d6ehchghiz8","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jotb001n6d6efexz8h0w"},{"post_id":"cmgt4jot7000e6d6ehchghiz8","tag_id":"cmgt4jota00146d6ecizk6o17","_id":"cmgt4jotb001o6d6e11nl0cte"},{"post_id":"cmgt4jot7000g6d6eex939zfe","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jotb001q6d6e6przethy"},{"post_id":"cmgt4jot7000g6d6eex939zfe","tag_id":"cmgt4jota00146d6ecizk6o17","_id":"cmgt4jotb001r6d6edi94gidk"},{"post_id":"cmgt4jot8000j6d6eckkebcvz","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jotb001t6d6e7c618qod"},{"post_id":"cmgt4jot8000j6d6eckkebcvz","tag_id":"cmgt4jota00146d6ecizk6o17","_id":"cmgt4jotb001u6d6e3to39dva"},{"post_id":"cmgt4jot9000s6d6eh0la6fa9","tag_id":"cmgt4jotb001s6d6e7wwk6wqo","_id":"cmgt4jotb001v6d6eh8zj4haa"},{"post_id":"cmgt4jot9000s6d6eh0la6fa9","tag_id":"cmgt4jot6000a6d6e1okdcdn5","_id":"cmgt4jotb001w6d6eghtwa6y9"}],"Tag":[{"name":"三维视觉","_id":"cmgt4jot400036d6eaodk62fz"},{"name":"SLAM","_id":"cmgt4jot500076d6e02336pe7"},{"name":"学习笔记","_id":"cmgt4jot6000a6d6e1okdcdn5"},{"name":"深度估计","_id":"cmgt4jot8000m6d6e6t2h5y3d"},{"name":"论文阅读总结","_id":"cmgt4jot9000r6d6e1jx45irf"},{"name":"数据库","_id":"cmgt4jota00146d6ecizk6o17"},{"name":"Archlinux","_id":"cmgt4jotb001s6d6e7wwk6wqo"}]}}